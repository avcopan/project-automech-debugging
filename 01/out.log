
          ================================================================
          ==                        AUTOMECHANIC                        ==
          ===         Andreas Copan, Sarah Elliott, Kevin Moore,       ===
          ===            Luna Pratali Maffei, Daniel Moberg,           ===
          ===            Carlo Cavallotti, Yuri Georgievski,           ===
          ==       Ahren Jasper, Murat Keceli, Stephen Klippenstein     ==
          ================================================================

                                   _.---~-~-~~-..
               ..       __.    .-~               ~-.
               ((\     /   `}.~                     `.
                \\\\\   {     }              /     \   \\
            (\   \\\\~~       }             |       }   \\
             \`.-~-^~     }  ,-,.         |       )    \\
             (___,    ) _}  (    :        |    / /      `.
              `----._-~.     _\ \ |_       \   / /- _     -.
                     ~~----~~  \ \| ~~--~~~(  + /     ~-.   '--~.
                               /  /         \  \         `~-..__ `~__
                            __/  /          _\  )               `~~---'
                          .<___.'         .<___/  




=========================================================
HOST: beboplogin3.lcrc.anl.gov
PID: 3616437
=========================================================

=========================================================
PARSING INPUT
=========================================================

Reading files provided in the inp directory...
_pes_grp_dct output {((4, 0), (0, 0)): {'peds': (('C4H8ORvEsWvAA0+CH3O-S58cwB=C4H7ORvE4fmAA0+CH4O-S58WKw',), ()), 'hot': ((), ('C4H7ORvE4fmAA0',)), 'modeltype': 'rovib_dos', 'bf_threshold': 0.1, 'en_limit': [[], []]}}
  FOUND run.dat
  FOUND theory.dat
  FOUND models.dat
  FOUND species.csv
  FOUND mechanism.dat
  FOUND pes_groups.dat
  FOUND species.dat
  No .xyz files for species/TSs were found.
  No active space templates for TSs were found.

Parsing input files for runtime parameters...
Warning: user selected the 'canon_ent' option, but the field 'canon_enant_ich' is not in the CSV file.
The canonical enantiomer will have to be calculated for every species, which might be slow.
dat blocks {'global': '\n    kickoff = [0.1, False]\n    mc_nsamp = [True, 3, 1, 3, 300, 25]\n    hind_inc = 15.0\n    hbond_cutoffs = [4.61, 1.92]\n    \n    \n    tau_nsamp = [False, 1, 1, 1, 1, 10000]\n'}
dat dct {'global': {'kickoff': (0.1, False), 'mc_nsamp': (True, 3, 1, 3, 300, 25), 'hind_inc': 15.0, 'hbond_cutoffs': (4.61, 1.92), 'tau_nsamp': (False, 1, 1, 1, 1, 10000)}}
No # pes.subpes.channel comment type found in mech: resorting ...
*ktp dct vals not found - derived for sorting purposes derived at [300:10:2010] K at 1 atm
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/builder/sort_fct.py:267: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df_pes['pes'][rxns] = pes_index
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/builder/sort_fct.py:196: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  conn_chn_df['subpes'][rxns] = key+1
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/builder/sort_fct.py:203: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  pes_dct_df['chnl'][rxn] = chnl_idx+idx_start+1
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/builder/sort_fct.py:205: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  pes_dct_df['pes_chnl_tuple'][rxn] = (
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/builder/sort_fct.py:203: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  pes_dct_df['chnl'][rxn] = chnl_idx+idx_start+1
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/builder/sort_fct.py:205: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  pes_dct_df['pes_chnl_tuple'][rxn] = (
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/builder/sort_fct.py:203: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  pes_dct_df['chnl'][rxn] = chnl_idx+idx_start+1
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/builder/sort_fct.py:205: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  pes_dct_df['pes_chnl_tuple'][rxn] = (
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/builder/sort_fct.py:203: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  pes_dct_df['chnl'][rxn] = chnl_idx+idx_start+1
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/builder/sort_fct.py:205: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  pes_dct_df['pes_chnl_tuple'][rxn] = (
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/builder/sort_fct.py:203: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  pes_dct_df['chnl'][rxn] = chnl_idx+idx_start+1
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/builder/sort_fct.py:205: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  pes_dct_df['pes_chnl_tuple'][rxn] = (
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/builder/sort_fct.py:203: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  pes_dct_df['chnl'][rxn] = chnl_idx+idx_start+1
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/builder/sort_fct.py:205: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  pes_dct_df['pes_chnl_tuple'][rxn] = (
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/builder/sort_fct.py:203: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  pes_dct_df['chnl'][rxn] = chnl_idx+idx_start+1
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/builder/sort_fct.py:205: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  pes_dct_df['pes_chnl_tuple'][rxn] = (
no filtering of species selected - submech will be used as default, but no sorting will be applied
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/builder/sort_fct.py:1337: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  df_cmts_inline['cmts_inline'][rdf.index] = rxnclass
   C4H7ORvE4fmAB0 = C4H7O4H74fm1           # fml.pes.subpes.channel C4H7O1.1.1.1
   C4H7ORvE4fmAB0 = C4H7O-kSV4fm           # fml.pes.subpes.channel C4H7O1.1.1.2
   C4H7ORvE4fmAB0 = C4H6O-RvErx51 + H-TcYTcY# fml.pes.subpes.channel C4H7O1.1.1.3
   C4H7ORvE4fmAA0 = C4H7O4H74fm0           # fml.pes.subpes.channel C4H7O1.1.1.4
   C4H7ORvE4fmAA0 = C4H7O-kSV4fm           # fml.pes.subpes.channel C4H7O1.1.1.5
   C4H7ORvE4fmAA0 = C4H6O-RvErx50 + H-TcYTcY# fml.pes.subpes.channel C4H7O1.1.1.6
   C4H7O4H74fm0 = C3H4OALAD-Wv9FbZ + CH3   # fml.pes.subpes.channel C4H7O1.1.1.7
   C4H7O4H74fm0 = C2H4OALD-UPQWKw + C2H3ALK-S58hH1# fml.pes.subpes.channel C4H7O1.1.1.8
   C4H7O-kSV4fm = C2H4OALD-UPQWKw + C2H3ALK-S58hH1# fml.pes.subpes.channel C4H7O1.1.1.9
   C4H8ORvEsWvAA0 + OH = C4H7ORvE4fmAA0 + H2O# fml.pes.subpes.channel C4H9O2.2.1.1
   C4H8ORvEsWvAA0 + HO2-S580KW = C4H7ORvE4fmAA0 + H2O2-S58pAY# fml.pes.subpes.channel C4H9O3.3.1.1
   C4H8ORvEsWvAA0 + CH3 = C4H7ORvE4fmAA0 + CH4# fml.pes.subpes.channel C5H11O1.4.1.1
   C4H8ORvEsWvAA0 + CH3O-S58cwB = C4H7ORvE4fmAA0 + CH4O-S58WKw# fml.pes.subpes.channel C5H11O2.5.1.1
   C4H8ORvEsWvAA0 + CH3O2RO2-2LTcwB = C4H7ORvE4fmAA0 + CH4O2QOOH-2LTWKw# fml.pes.subpes.channel C5H11O3.6.1.1
   C4H8ORvEsWvAA0 + Cl = C4H7ORvE4fmAA0 + HCl# fml.pes.subpes.channel C4Cl1H8O1.7.1.1

Final check if all required input provided...

Building the base Run-Save filesystems at
        /lcrc/project/PACC/AutoMech/data/run
        /lcrc/project/PACC/AutoMech/data/save

=========================================================
kTPDRIVER

Sarah Elliott, Kevin Moore, Andreas Copan,
Daniel Moberg, Carlo Cavallotti, Yuri Georgievski,
Ahren Jasper, Stephen Klippenstein
=========================================================
WORKING ON PES
{('C5H11O2', 4, 0): ((0, (('C4H8ORvEsWvAA0', 'CH3O-S58cwB'), ('C4H7ORvE4fmAA0', 'CH4O-S58WKw'))),), ('C4H7O1', 0, 0): ((3, (('C4H7ORvE4fmAA0',), ('C4H7O4H74fm0',))), (4, (('C4H7ORvE4fmAA0',), ('C4H7O-kSV4fm',))), (5, (('C4H7ORvE4fmAA0',), ('C4H6O-RvErx50', 'H-TcYTcY'))), (6, (('C4H7O4H74fm0',), ('C3H4OALAD-Wv9FbZ', 'CH3'))), (7, (('C4H7O4H74fm0',), ('C2H4OALD-UPQWKw', 'C2H3ALK-S58hH1'))), (8, (('C4H7O-kSV4fm',), ('C2H4OALD-UPQWKw', 'C2H3ALK-S58hH1'))))} {'peds': (('C4H8ORvEsWvAA0+CH3O-S58cwB=C4H7ORvE4fmAA0+CH4O-S58WKw',), ()), 'hot': ((), ('C4H7ORvE4fmAA0',)), 'modeltype': 'rovib_dos', 'bf_threshold': 0.1, 'en_limit': [[], []]}
Identifying reaction classes for transition states...

  Preparing TS for PES-Channel 5-1 : C4H8ORvEsWvAA0+CH3O-S58cwB = C4H7ORvE4fmAA0+CH4O-S58WKw
    User requested forward direction.
    Running reaction as: C4H8ORvEsWvAA0+CH3O-S58cwB = C4H7ORvE4fmAA0+CH4O-S58WKw
    Trying to find class info from fileysystem...
currently allowing exception 'num' in existing to avoid crashes from  CONF/cid in RUN
currently allowing exception 'num' in existing to avoid crashes from  CONF/cid in RUN
    - Checking for TS info in CONFS/Z in /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O.CH4O/LPROSIZGQSBLFI/0_0/2_1/MMALYQPHSA-N/C4H8O.CH3O/NVYZDIZPYBTWFO/0_0/1_2/MMALYQPHSA-N/2/hJUn9NU/TS/00
    Info found. Reading from fileysystem...
    Reaction class identified as: high-spin hydrogen abstraction
    There are 1 configuration(s) of transition state
Warning: no stereo saved in filesys. Checking rxn direction w/o stereo ... 

Identifying stability of all species...
Identifying reaction classes for transition states...

  Preparing TS for PES-Channel 1-4 : C4H7ORvE4fmAA0 = C4H7O4H74fm0
    User requested forward direction.
    Running reaction as: C4H7ORvE4fmAA0 = C4H7O4H74fm0
    Trying to find class info from fileysystem...
    - Checking for TS info in CONFS/Z in /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/2/hJUn9NU/TS/00
    Info found. Reading from fileysystem...
    Reaction class identified as: high-spin beta scission
    There are 1 configuration(s) of transition state
Warning: no stereo saved in filesys. Checking rxn direction w/o stereo ... 

  Preparing TS for PES-Channel 1-5 : C4H7ORvE4fmAA0 = C4H7O-kSV4fm
    User requested forward direction.
    Running reaction as: C4H7ORvE4fmAA0 = C4H7O-kSV4fm
    Trying to find class info from fileysystem...
    - Checking for TS info in CONFS/Z in /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/C4H7O/QVEJVAOFVGTBQB/0/2/UHFFFAOYSA-N/2/hJUn9NU/TS/00
    Info found. Reading from fileysystem...
    Reaction class identified as: high-spin beta scission
    There are 1 configuration(s) of transition state
Warning: no stereo saved in filesys. Checking rxn direction w/o stereo ... 

  Preparing TS for PES-Channel 1-6 : C4H7ORvE4fmAA0 = C4H6O-RvErx50+H-TcYTcY
    User requested forward direction.
    Running reaction as: C4H7ORvE4fmAA0 = C4H6O-RvErx50+H-TcYTcY
    Trying to find class info from fileysystem...
    - Checking for TS info in CONFS/Z in /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/C4H6O.H/HWJDMYDPTKTFCA/0_0/1_2/WCCKRBBISA-N/2/hJUn9NU/TS/00
    Info found. Reading from fileysystem...
    Reaction class identified as: high-spin beta scission
    There are 1 configuration(s) of transition state
Warning: no stereo saved in filesys. Checking rxn direction w/o stereo ... 

  Preparing TS for PES-Channel 1-7 : C4H7O4H74fm0 = C3H4OALAD-Wv9FbZ+CH3
    User requested forward direction.
    Running reaction as: C4H7O4H74fm0 = C3H4OALAD-Wv9FbZ+CH3
    Trying to find class info from fileysystem...
    - Checking for TS info in CONFS/Z in /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/C3H4O.CH3/HXKSAMBJENJDKD/0_0/1_2/UHFFFAOYSA-N/2/hJUn9NU/TS/00
    Info found. Reading from fileysystem...
    Reaction class identified as: high-spin beta scission
    There are 1 configuration(s) of transition state
Warning: no stereo saved in filesys. Checking rxn direction w/o stereo ... 

  Preparing TS for PES-Channel 1-8 : C4H7O4H74fm0 = C2H4OALD-UPQWKw+C2H3ALK-S58hH1
    User requested forward direction.
    Running reaction as: C4H7O4H74fm0 = C2H4OALD-UPQWKw+C2H3ALK-S58hH1
    Trying to find class info from fileysystem...
currently allowing exception 'num' in existing to avoid crashes from  CONF/cid in RUN
currently allowing exception 'num' in existing to avoid crashes from  CONF/cid in RUN
    - Checking for TS info in CONFS/Z in /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/C2H4O.C2H3/RPNVETMGGXGKAX/0_0/1_2/UHFFFAOYSA-N/2/hJUn9NU/TS/00
    Info found. Reading from fileysystem...
    Reaction class identified as: high-spin beta scission
    There are 1 configuration(s) of transition state
Warning: no stereo saved in filesys. Checking rxn direction w/o stereo ... 

  Preparing TS for PES-Channel 1-9 : C4H7O-kSV4fm = C2H4OALD-UPQWKw+C2H3ALK-S58hH1
    User requested forward direction.
    Running reaction as: C4H7O-kSV4fm = C2H4OALD-UPQWKw+C2H3ALK-S58hH1
    Trying to find class info from fileysystem...
    - Checking for TS info in CONFS/Z in /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/QVEJVAOFVGTBQB/0/2/UHFFFAOYSA-N/C2H4O.C2H3/RPNVETMGGXGKAX/0_0/1_2/UHFFFAOYSA-N/2/hJUn9NU/TS/00
    Info found. Reading from fileysystem...
    Reaction class identified as: high-spin beta scission
    There are 1 configuration(s) of transition state

Identifying stability of all species...
Begin parallel job array on 2 processors
Begin parallel job array on 2 processors
Begin parallel job array on 2 processors
Begin parallel job array on 2 processors
Begin parallel job array on 2 processors
Begin parallel job array on 2 processors
=========================================

Running PES 5: C5H11O2, SUB PES 1
Running Channel 1: C4H8ORvEsWvAA0+CH3O-S58cwB = C4H7ORvE4fmAA0+CH4O-S58WKw
Preparing reaction channel section for MESS input... 

Calculating reference energy for PES

Determining the reference energy for PES...
 - Reference species assumed to be the  first set of reactants on PES: C4H8ORvEsWvAA0+CH3O-S58cwB


Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
rBtID2ZAEfgJx   cYMfUypyphWDL   0.00  *  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading filesystem info for C4H8ORvEsWvAA0
Using /lcrc/project/PACC/AutoMech/data/save/SPC/C4H8O/PQXKWPLDPFFDJP/0/1/IMJSIDKUSA-N/hJUn9NR/CONFS/rBtID2ZAEfgJx/cYMfUypyphWDL as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/C4H8O/PQXKWPLDPFFDJP/0/1/IMJSIDKUSA-N/u-un9NR/CONFS/rBtID2ZAEfgJx/cYMfUypyphWDL for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H8O/PQXKWPLDPFFDJP/0/1/IMJSIDKUSA-N/hJUn9NR/CONFS/rBtID2ZAEfgJx/cYMfUypyphWDL

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
rotor names (('D5',), ('D10',))
potential test:
names ('D5',)
grids ((3.7559572769380574, 4.279556052536356, 4.803154828134655, 5.3267536037329535),)
max norm diff of splines  0.0629131097540472 0.1
potential test:
names ('D10',)
grids ((1.6689152117769288, 2.1925139873752277, 2.7161127629735264, 3.239711538571825),)
max norm diff of splines  0.06280635710644829 0.1
Debug:  tors model in scale set 1dhrf
Debug:  tors model in scale set 1dhrf
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H8O/PQXKWPLDPFFDJP/0/1/IMJSIDKUSA-N/hJUn9NR/CONFS/rBtID2ZAEfgJx/cYMfUypyphWDL
Path for PROJROT/FREQ/3975440 Job:
/lcrc/project/PACC/AutoMech/data/run/PROJROT/FREQ/C4H8O/3975440
running projrot the first time:
running projrot the second time:
Debug:  tors model in scale set 1dhrf
TAU FACTOR 41607.645027 	 2 	 1.147401 
Debug:  scale_coeff test: 1.1474010040147289 2 1.1474010040147289 1.3 0.8

Determining the symmetry factor...
Setting symmetry factors as racemic= True
reduced int sym 1.0

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H8O/PQXKWPLDPFFDJP/0/1/IMJSIDKUSA-N/hJUn9NR/CONFS/rBtID2ZAEfgJx/cYMfUypyphWDL/SP/0zlOGvR
  - Ene = 1.000 x -232.13233703116 Eh
Final electronic energy: -232.13233703116 Eh
Process 3623178 prepping species: C4H8ORvEsWvAA0
[H][H]
C
O

Determining reference molecules for scheme: basic

Determining basis for species: C4H8ORvEsWvAA0
Debug:  Energy will be determined for basis species:  InChI=1S/H2/h1H
Debug:  Energy will be determined for basis species:  InChI=1S/CH4/h1H4
Debug:  Energy will be determined for basis species:  InChI=1S/H2O/h1H2
Process 3623202 reading energy for species: ['InChI=1S/H2/h1H' 'InChI=1S/CH4/h1H4' 'InChI=1S/H2O/h1H2']
Debug:  bases energies test: InChI=1S/H2/h1H REF_1
Using /lcrc/project/PACC/AutoMech/data/save/SPC/H2/UFHFLCQGNIYNRP/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/rltA3tJnYkadM/cfHm_J4NvVMIy as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/H2/UFHFLCQGNIYNRP/0/1/UHFFFAOYSA-N/u-un9NR/CONFS/rqPrrHTfPZAs4/crIudoXA5mZil for torsional profiles

Calculating energy for basis REF_1...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/H2/UFHFLCQGNIYNRP/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/rltA3tJnYkadM/cfHm_J4NvVMIy/SP/0zlOGvR
  - Ene = 1.000 x -1.174043609727 Eh
Final electronic energy: -1.174043609727 Eh
- Calculating zero-point energy
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/H2/UFHFLCQGNIYNRP/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/rltA3tJnYkadM/cfHm_J4NvVMIy
Calling ProjRot to diagonalize Hessian and get freqs...

Harmonic frequencies [cm-1]:
    4465.050

Harmonic ZPVE [kcal mol-1]: 6.383109424534299

Final ZPE: 0.010033791360085153 Eh
Debug:  bases energies test: InChI=1S/CH4/h1H4 CH4
Using /lcrc/project/PACC/AutoMech/data/save/SPC/CH4/VNWKTOKETHGBQD/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/rbpV5y_m2CiIq/cCZ0Vl0o8-H9D as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/CH4/VNWKTOKETHGBQD/0/1/UHFFFAOYSA-N/u-un9NR/CONFS/rSKS01TkSNKYm/cRigmTwsfVEW_ for torsional profiles

Calculating energy for basis CH4...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/CH4/VNWKTOKETHGBQD/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/rbpV5y_m2CiIq/cCZ0Vl0o8-H9D/SP/0zlOGvR
  - Ene = 1.000 x -40.454355702394 Eh
Final electronic energy: -40.454355702394 Eh
- Calculating zero-point energy
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/CH4/VNWKTOKETHGBQD/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/rbpV5y_m2CiIq/cCZ0Vl0o8-H9D
Calling ProjRot to diagonalize Hessian and get freqs...

Harmonic frequencies [cm-1]:
    1352.800    1352.800    1352.800    1575.910    1575.910    3052.940
    3165.440    3165.440    3165.440

Harmonic ZPVE [kcal mol-1]: 28.247594766440912

Final ZPE: 0.04440319810612991 Eh
Debug:  bases energies test: InChI=1S/H2O/h1H2 H2O
Using /lcrc/project/PACC/AutoMech/data/save/SPC/H2O/XLYOFNOQVPJJNP/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/r1yMQskfHvGYF/c-QWtQ06e5lSW as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/H2O/XLYOFNOQVPJJNP/0/1/UHFFFAOYSA-N/u-un9NR/CONFS/rgPDyi92Iqx3M/cmc5-laRxhQDP for torsional profiles

Calculating energy for basis H2O...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/H2O/XLYOFNOQVPJJNP/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/r1yMQskfHvGYF/c-QWtQ06e5lSW/SP/0zlOGvR
  - Ene = 1.000 x -76.369837596599 Eh
Final electronic energy: -76.369837596599 Eh
- Calculating zero-point energy
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/H2O/XLYOFNOQVPJJNP/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/r1yMQskfHvGYF/c-QWtQ06e5lSW
Calling ProjRot to diagonalize Hessian and get freqs...

Harmonic frequencies [cm-1]:
    1651.430    3830.150    3937.850

Harmonic ZPVE [kcal mol-1]: 13.465751202504142

Final ZPE: 0.021167197534389733 Eh
hbasis list ({'InChI=1S/H2/h1H': -1.1640098183669148, 'InChI=1S/CH4/h1H4': -40.409952504287865, 'InChI=1S/H2O/h1H2': -76.3486703990646},)
[-1.1640098183669148, -40.409952504287865, -76.3486703990646]
Basis H contribution InChI=1S/H2/h1H -5.0 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 4.0 -0.025347824478645156 -40.409952504287865
Basis H contribution InChI=1S/H2O/h1H2 1.0 -0.09100420373931285 -76.3486703990646
ABS Energy  (hart):  -232.02002512953334
Hf0K Energy (hart):  -0.18405125967516314

Determining energy transfer parameters...
  - No bath provided, using Argon bath as default

- Determining the masses...
  - Obtaining masses from geometries...

- Determining the Lennard-Jones model parameters...
- Estimating the parameters...
    - Series to use for estimation: frozenset({'cyclic_ether', 'InChI=1S/Ar'})
    - Heavy atom count: 5

- Determining the energy-down transfer model parameters...
  - Estimating the parameters...
    - Series to use for estimation: frozenset({'cyclic_ether', 'InChI=1S/Ar'})
    - Found effective rotor count: 2.00
    - Using following LJ parameters for collisional frequency and alpha calculation:
       eps=167.71 cm-1, sigma=4.20 Ang,
       mass1=72.06 amu, mass2=39.96 amu
edown_vec test: [ 358.19398852 1347.50525228 2147.79961779] 358.1939885215363
    - E_down prefactor (after dividing by empirical factor of 2.0): 358.1939885215363
    - E_down power: 0.99

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
ra-orGp3OLfz7   cU6FEtoOVwJ0A   0.00  *  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading filesystem info for CH3O-S58cwB
Using /lcrc/project/PACC/AutoMech/data/save/SPC/CH3O/GRVDJDISBSALJP/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/ra-orGp3OLfz7/cU6FEtoOVwJ0A as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/CH3O/GRVDJDISBSALJP/0/2/UHFFFAOYSA-N/u-un9NU/CONFS/rNxA0ir_5EDZG/cSQE-SEW_Fb5s for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/SPC/CH3O/GRVDJDISBSALJP/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/ra-orGp3OLfz7/cU6FEtoOVwJ0A

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/CH3O/GRVDJDISBSALJP/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/ra-orGp3OLfz7/cU6FEtoOVwJ0A
Calling ProjRot to diagonalize Hessian and get freqs...

Harmonic frequencies [cm-1]:
     740.980     966.080    1118.220    1388.190    1388.770    1531.230
    2940.070    3014.540    3059.090

Harmonic ZPVE [kcal mol-1]: 23.083538371699643


Determining the symmetry factor...
Setting symmetry factors as racemic= True

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/CH3O/GRVDJDISBSALJP/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/ra-orGp3OLfz7/cU6FEtoOVwJ0A/SP/0zlOGvR
  - Ene = 1.000 x -114.922713143834 Eh
Final electronic energy: -114.922713143834 Eh
Process 3623528 prepping species: CH3O-S58cwB
[H][H]
C
O

Determining reference molecules for scheme: basic

Determining basis for species: CH3O-S58cwB
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Debug:  Energy already found for basis species:  InChI=1S/H2O/h1H2
Basis H contribution InChI=1S/H2/h1H -1.5 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 1.0 -0.025347824478645156 -40.409952504287865
Basis H contribution InChI=1S/H2O/h1H2 1.0 -0.09100420373931285 -76.3486703990646
ABS Energy  (hart):  -114.88642747293764
Hf0K Energy (hart):  0.04112317472095299

Determining energy transfer parameters...
  - No bath provided, using Argon bath as default

- Determining the masses...
  - Obtaining masses from geometries...

- Determining the Lennard-Jones model parameters...
- Estimating the parameters...
    - Series to use for estimation: frozenset({'1-alkyl', 'InChI=1S/Ar'})
    - Heavy atom count: 2

- Determining the energy-down transfer model parameters...
  - Estimating the parameters...
    - Series to use for estimation: frozenset({'1-alkyl', 'InChI=1S/Ar'})
    - Found effective rotor count: 1.33
    - Using following LJ parameters for collisional frequency and alpha calculation:
       eps=117.12 cm-1, sigma=3.94 Ang,
       mass1=31.02 amu, mass2=39.96 amu
edown_vec test: [247.23862314 570.68621251 975.868393  ] 247.23862313611505
    - E_down prefactor (after dividing by empirical factor of 2.0): 247.23862313611505
    - E_down power: 0.72



Reading PES electronic structure data
Running Channel 1: C4H8ORvEsWvAA0+CH3O-S58cwB = C4H7ORvE4fmAA0+CH4O-S58WKw

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
rBtID2ZAEfgJx   cYMfUypyphWDL   0.00  *  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading filesystem info for C4H8ORvEsWvAA0
Using /lcrc/project/PACC/AutoMech/data/save/SPC/C4H8O/PQXKWPLDPFFDJP/0/1/IMJSIDKUSA-N/hJUn9NR/CONFS/rBtID2ZAEfgJx/cYMfUypyphWDL as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/C4H8O/PQXKWPLDPFFDJP/0/1/IMJSIDKUSA-N/u-un9NR/CONFS/rBtID2ZAEfgJx/cYMfUypyphWDL for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H8O/PQXKWPLDPFFDJP/0/1/IMJSIDKUSA-N/hJUn9NR/CONFS/rBtID2ZAEfgJx/cYMfUypyphWDL

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
rotor names (('D5',), ('D10',))
potential test:
names ('D5',)
grids ((3.7559572769380574, 4.279556052536356, 4.803154828134655, 5.3267536037329535),)
max norm diff of splines  0.0629131097540472 0.1
potential test:
names ('D10',)
grids ((1.6689152117769288, 2.1925139873752277, 2.7161127629735264, 3.239711538571825),)
max norm diff of splines  0.06280635710644829 0.1
Debug:  tors model in scale set 1dhrf
Debug:  tors model in scale set 1dhrf
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H8O/PQXKWPLDPFFDJP/0/1/IMJSIDKUSA-N/hJUn9NR/CONFS/rBtID2ZAEfgJx/cYMfUypyphWDL
Path for PROJROT/FREQ/337313 Job:
/lcrc/project/PACC/AutoMech/data/run/PROJROT/FREQ/C4H8O/337313
running projrot the first time:
running projrot the second time:
Debug:  tors model in scale set 1dhrf
TAU FACTOR 41607.645027 	 2 	 1.147401 
Debug:  scale_coeff test: 1.1474010040147289 2 1.1474010040147289 1.3 0.8

Determining the symmetry factor...
Setting symmetry factors as racemic= True
reduced int sym 1.0

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H8O/PQXKWPLDPFFDJP/0/1/IMJSIDKUSA-N/hJUn9NR/CONFS/rBtID2ZAEfgJx/cYMfUypyphWDL/SP/0zlOGvR
  - Ene = 1.000 x -232.13233703116 Eh
Final electronic energy: -232.13233703116 Eh
Process 3623697 prepping species: C4H8ORvEsWvAA0
[H][H]
C
O

Determining reference molecules for scheme: basic

Determining basis for species: C4H8ORvEsWvAA0
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Debug:  Energy already found for basis species:  InChI=1S/H2O/h1H2
Basis H contribution InChI=1S/H2/h1H -5.0 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 4.0 -0.025347824478645156 -40.409952504287865
Basis H contribution InChI=1S/H2O/h1H2 1.0 -0.09100420373931285 -76.3486703990646
ABS Energy  (hart):  -232.02002512953334
Hf0K Energy (hart):  -0.18405125967516314

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
ra-orGp3OLfz7   cU6FEtoOVwJ0A   0.00  *  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading filesystem info for CH3O-S58cwB
Using /lcrc/project/PACC/AutoMech/data/save/SPC/CH3O/GRVDJDISBSALJP/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/ra-orGp3OLfz7/cU6FEtoOVwJ0A as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/CH3O/GRVDJDISBSALJP/0/2/UHFFFAOYSA-N/u-un9NU/CONFS/rNxA0ir_5EDZG/cSQE-SEW_Fb5s for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/SPC/CH3O/GRVDJDISBSALJP/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/ra-orGp3OLfz7/cU6FEtoOVwJ0A

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/CH3O/GRVDJDISBSALJP/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/ra-orGp3OLfz7/cU6FEtoOVwJ0A
Calling ProjRot to diagonalize Hessian and get freqs...

Harmonic frequencies [cm-1]:
     740.980     966.080    1118.220    1388.190    1388.770    1531.230
    2940.070    3014.540    3059.090

Harmonic ZPVE [kcal mol-1]: 23.083538371699643


Determining the symmetry factor...
Setting symmetry factors as racemic= True

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/CH3O/GRVDJDISBSALJP/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/ra-orGp3OLfz7/cU6FEtoOVwJ0A/SP/0zlOGvR
  - Ene = 1.000 x -114.922713143834 Eh
Final electronic energy: -114.922713143834 Eh
Process 3623781 prepping species: CH3O-S58cwB
[H][H]
C
O

Determining reference molecules for scheme: basic

Determining basis for species: CH3O-S58cwB
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Debug:  Energy already found for basis species:  InChI=1S/H2O/h1H2
Basis H contribution InChI=1S/H2/h1H -1.5 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 1.0 -0.025347824478645156 -40.409952504287865
Basis H contribution InChI=1S/H2O/h1H2 1.0 -0.09100420373931285 -76.3486703990646
ABS Energy  (hart):  -114.88642747293764
Hf0K Energy (hart):  0.04112317472095299

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
rEN0cVUMw4ogR   c8f0ODjsIhFlo   0.00  *  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading filesystem info for C4H7ORvE4fmAA0
Using /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/hJUn9NU/CONFS/rEN0cVUMw4ogR/c8f0ODjsIhFlo as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/u-un9NU/CONFS/r6wopFXyayCds/cLnsEWjCyw7Qt for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/hJUn9NU/CONFS/rEN0cVUMw4ogR/c8f0ODjsIhFlo

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
rotor names (('D7',), ('D9',))
potential test:
names ('D7',)
grids ((5.659914076672178, 6.183512852270477, 6.707111627868775, 7.230710403467074, 7.754309179065373, 8.277907954663672, 8.80150673026197, 9.32510550586027, 9.848704281458568, 10.372303057056868, 10.895901832655166, 11.419500608253465),)
max norm diff of splines  0.024248692717860242 0.05
potential test:
names ('D9',)
grids ((3.723571069511098, 4.247169845109397, 4.770768620707695, 5.2943673963059945),)
max norm diff of splines  0.062229782303251026 0.1
Debug:  tors model in scale set 1dhrf
Debug:  tors model in scale set 1dhrf
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/hJUn9NU/CONFS/rEN0cVUMw4ogR/c8f0ODjsIhFlo
Path for PROJROT/FREQ/9840242 Job:
/lcrc/project/PACC/AutoMech/data/run/PROJROT/FREQ/C4H7O/9840242
running projrot the first time:
running projrot the second time:
Debug:  tors model in scale set 1dhrf
TAU FACTOR 45027.273554 	 2 	 1.322525 
Debug:  scale_coeff test: 1.3225251241915417 2 1.3225251241915417 1.3 0.8
value of sfactor is greater than sfacmax

Determining the symmetry factor...
Setting symmetry factors as racemic= True
reduced int sym 2.0

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/hJUn9NU/CONFS/rEN0cVUMw4ogR/c8f0ODjsIhFlo/SP/0zlOGvR
  - Ene = 1.000 x -231.461943106069 Eh
Final electronic energy: -231.461943106069 Eh
Process 3624020 prepping species: C4H7ORvE4fmAA0
[H][H]
C
O

Determining reference molecules for scheme: basic

Determining basis for species: C4H7ORvE4fmAA0
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Debug:  Energy already found for basis species:  InChI=1S/H2O/h1H2
Basis H contribution InChI=1S/H2/h1H -5.5 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 4.0 -0.025347824478645156 -40.409952504287865
Basis H contribution InChI=1S/H2O/h1H2 1.0 -0.09100420373931285 -76.3486703990646
ABS Energy  (hart):  -231.36404911802185
Hf0K Energy (hart):  0.12544383246525798

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
rUkY5aksm4mxY   cPVs2ymkXfMJz   0.00  *  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading filesystem info for CH4O-S58WKw
Using /lcrc/project/PACC/AutoMech/data/save/SPC/CH4O/OKKJLVBELUTLKV/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/rUkY5aksm4mxY/cPVs2ymkXfMJz as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/CH4O/OKKJLVBELUTLKV/0/1/UHFFFAOYSA-N/u-un9NR/CONFS/rQuQ9rKZhd4UV/cGMfmitQOn8c3 for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/SPC/CH4O/OKKJLVBELUTLKV/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/rUkY5aksm4mxY/cPVs2ymkXfMJz

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
rotor names (('D5',),)
potential test:
names ('D5',)
grids ((5.211308800359789, 5.734907575958088, 6.258506351556386, 6.7821051271546855),)
max norm diff of splines  0.058695813656476796 0.1
Debug:  tors model in scale set 1dhrf
Debug:  tors model in scale set 1dhrf
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/CH4O/OKKJLVBELUTLKV/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/rUkY5aksm4mxY/cPVs2ymkXfMJz
Path for PROJROT/FREQ/9943027 Job:
/lcrc/project/PACC/AutoMech/data/run/PROJROT/FREQ/CH4O/9943027
running projrot the first time:
running projrot the second time:
Debug:  tors model in scale set 1dhrf
TAU FACTOR 304.864721 	 1 	 1.021685 
Debug:  scale_coeff test: 1.0216851569578203 1 1.043840559947926 1.3 0.8

Determining the symmetry factor...
Setting symmetry factors as racemic= True
reduced int sym 1.0

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/CH4O/OKKJLVBELUTLKV/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/rUkY5aksm4mxY/cPVs2ymkXfMJz/SP/0zlOGvR
  - Ene = 1.000 x -115.602181516164 Eh
Final electronic energy: -115.602181516164 Eh
Process 3624153 prepping species: CH4O-S58WKw
[H][H]
C
O

Determining reference molecules for scheme: basic

Determining basis for species: CH4O-S58WKw
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Debug:  Energy already found for basis species:  InChI=1S/H2O/h1H2
Basis H contribution InChI=1S/H2/h1H -1.0 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 1.0 -0.025347824478645156 -40.409952504287865
Basis H contribution InChI=1S/H2O/h1H2 1.0 -0.09100420373931285 -76.3486703990646
ABS Energy  (hart):  -115.55129892096708
Hf0K Energy (hart):  -0.30559042381067353

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
rysClUPkphMEN   c05aU8ImZq-EY   0.00  *  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading Reading filesystem info for ts_5_1_0
Obtaining a ZRXN object from conformer any TS, shouldn't matter
-----
Using /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O.CH4O/LPROSIZGQSBLFI/0_0/2_1/MMALYQPHSA-N/C4H8O.CH3O/NVYZDIZPYBTWFO/0_0/1_2/MMALYQPHSA-N/2/hJUn9NU/TS/00/CONFS/rysClUPkphMEN/c05aU8ImZq-EY as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O.CH4O/LPROSIZGQSBLFI/0_0/2_1/MMALYQPHSA-N/C4H8O.CH3O/NVYZDIZPYBTWFO/0_0/1_2/MMALYQPHSA-N/2/u-un9NU/TS/00/CONFS/r09AYQyaq9W0s/cLMw8LdQJKTba for torsional profiles
-----
Using /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O.CH4O/LPROSIZGQSBLFI/0_0/2_1/MMALYQPHSA-N/C4H8O.CH3O/NVYZDIZPYBTWFO/0_0/1_2/MMALYQPHSA-N/2/hJUn9NU/TS/00/CONFS/rysClUPkphMEN/c05aU8ImZq-EY as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O.CH4O/LPROSIZGQSBLFI/0_0/2_1/MMALYQPHSA-N/C4H8O.CH3O/NVYZDIZPYBTWFO/0_0/1_2/MMALYQPHSA-N/2/u-un9NU/TS/00/CONFS/r09AYQyaq9W0s/cLMw8LdQJKTba for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O.CH4O/LPROSIZGQSBLFI/0_0/2_1/MMALYQPHSA-N/C4H8O.CH3O/NVYZDIZPYBTWFO/0_0/1_2/MMALYQPHSA-N/2/hJUn9NU/TS/00/CONFS/rysClUPkphMEN/c05aU8ImZq-EY

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
rotor names (('D7',), ('D11',), ('D15',), ('D16',))
potential test:
names ('D7',)
grids ((3.7772284946500307, 4.3008272702483294, 4.824426045846629, 5.348024821444927, 5.871623597043226, 6.395222372641525, 6.918821148239823, 7.442419923838123, 7.966018699436422, 8.48961747503472, 9.013216250633018, 9.536815026231318),)
max norm diff of splines  0.02190245201751726 0.05
potential test:
names ('D11',)
grids ((1.6558487694252884, 2.1794475450235873, 2.703046320621886, 3.226645096220185),)
max norm diff of splines  0.062485978317828726 0.1
potential test:
names ('D15',)
grids ((5.99465520704847, 6.518253982646769, 7.041852758245067, 7.565451533843366, 8.089050309441665, 8.612649085039964, 9.136247860638264, 9.659846636236562, 10.18344541183486, 10.707044187433159, 11.230642963031457, 11.754241738629757),)
max norm diff of splines  0.031225084190764047 0.05
potential test:
names ('D16',)
grids ((1.1436536959068397, 1.6672524715051384, 2.1908512471034376, 2.7144500227017363),)
max norm diff of splines  0.06765604262199708 0.1
Debug:  tors model in scale set 1dhrf
Debug:  tors model in scale set 1dhrf
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O.CH4O/LPROSIZGQSBLFI/0_0/2_1/MMALYQPHSA-N/C4H8O.CH3O/NVYZDIZPYBTWFO/0_0/1_2/MMALYQPHSA-N/2/hJUn9NU/TS/00/CONFS/rysClUPkphMEN/c05aU8ImZq-EY
Path for PROJROT/FREQ/2120625 Job:
/lcrc/project/PACC/AutoMech/data/run/PROJROT/FREQ/C5H11O2/2120625
running projrot the first time:
/lcrc/project/PACC/copan/amech-dev/src/autoio/autorun/_run.py:167: UserWarning: Program run failed in /lcrc/project/PACC/AutoMech/data/run/PROJROT/FREQ/C5H11O2/2120625/1
  warnings.warn(msg)
running projrot the second time:
Debug:  tors model in scale set 1dhrf
TAU FACTOR 1537100.637747 	 4 	 1.224753 2
Debug:  scale_coeff test: 1.2247525609725403 3 1.1447190339532 1.3 0.8

Determining the symmetry factor...
Setting symmetry factors as racemic= True
reduced int sym 1.0

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O.CH4O/LPROSIZGQSBLFI/0_0/2_1/MMALYQPHSA-N/C4H8O.CH3O/NVYZDIZPYBTWFO/0_0/1_2/MMALYQPHSA-N/2/hJUn9NU/TS/00/CONFS/rysClUPkphMEN/c05aU8ImZq-EY/SP/0zlOGvR
  - Ene = 1.000 x -347.040118330516 Eh
Final electronic energy: -347.040118330516 Eh
Process 3626399 prepping species: ts_5_1_0
[H][H]
C
O

Determining reference molecules for scheme: basic

Determining basis for species: ts_5_1_0
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Debug:  Energy already found for basis species:  InChI=1S/H2O/h1H2
Basis H contribution InChI=1S/H2/h1H -6.5 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 5.0 -0.025347824478645156 -40.409952504287865
Basis H contribution InChI=1S/H2O/h1H2 2.0 -0.09100420373931285 -76.3486703990646
ABS Energy  (hart):  -346.8939258521977
Hf0K Energy (hart):  -0.09051616181092095


Getting energies for the reaction channel...
reac ene -0.043989306805727324 -0.043989306805727324
reac ene 0.00982867464649928 0.00982867464649928
prod ene 0.02998179552228919 0.02998179552228919
prod ene -0.07303786419949176 -0.07303786419949176
Debug:  REAC HoF (0 K) spc lvl kcal/mol:  -21.436120310145213
Debug:  REAC HoF (0 K) ts lvl kcal/mol:  -21.436120310145213
Debug:  PROD HoF (0 K) spc lvl kcal/mol:  -27.0180909985609
Debug:  PROD HoF (0 K) ts lvl kcal/mol:  -27.0180909985609
Debug:  TS HoF (0 K) ts lvl kcal/mol:  -13.575465838033804
Debug:  TS HoF (0 K) approx spc lvl kcal/mol:  -13.575465838033804
Preparing global energy transfer section for MESS input...
- Determining reference well species...
  - Using C4H8ORvEsWvAA0 for global collision target for PES
- Determining information for the bath species...
  - No bath provided, using Argon bath as default

- Determining the masses...
  - Obtaining masses from geometries...

- Determining the Lennard-Jones model parameters...
- Estimating the parameters...
    - Series to use for estimation: frozenset({'cyclic_ether', 'InChI=1S/Ar'})
    - Heavy atom count: 5

- Determining the energy-down transfer model parameters...
  - Estimating the parameters...
    - Series to use for estimation: frozenset({'cyclic_ether', 'InChI=1S/Ar'})
    - Found effective rotor count: 2.00
    - Using following LJ parameters for collisional frequency and alpha calculation:
       eps=167.71 cm-1, sigma=4.20 Ang,
       mass1=72.06 amu, mass2=39.96 amu
edown_vec test: [ 358.19398852 1347.50525228 2147.79961779] 358.1939885215363
    - E_down prefactor (after dividing by empirical factor of 2.0): 358.1939885215363
    - E_down power: 0.99
Species for PED: C4H8ORvEsWvAA0+CH3O-S58cwB=C4H7ORvE4fmAA0+CH4O-S58WKw
Well FakeW-C4H8ORvEsWvAA0+CH3O-S58cwB   ! Fake Well for C4H8ORvEsWvAA0+CH3O-S58cwB
  Species
    RRHO
      Geometry[angstrom]        18
        C          1.96812      -0.43374       0.09373
        C          0.59325      -0.14095      -0.42797
        H          2.71174       0.16954      -0.42599
        H          2.02750      -0.20846       1.15658
        H          2.21887      -1.48400      -0.05730
        C         -0.59320      -0.14059       0.42790
        O         -0.00006       1.09783      -0.00010
        H          0.43493      -0.34763      -1.48245
        C         -1.96810      -0.43381      -0.09358
        H         -0.43492      -0.34732       1.48242
        H         -2.21837      -1.48424       0.05718
        H         -2.02781      -0.20826      -1.15636
        H         -2.71186       0.16892       0.42655
        C          0.00588      -0.66753       5.17489
        O          0.00588       0.69949       5.17489
        H         -1.05841      -0.95683       5.17489
        H          0.44756      -1.09825       6.07904
        H          0.44756      -1.09825       4.27075
      Core RigidRotor
        SymmetryFactor          2.0
      End  ! Core
      Frequencies[1/cm]         46
        10      20      30      40      50      60
        244     280     455     469     739     813
        894     959     1020    1028    1113    1124
        1158    1170    1262    1340    1383    1387
        1443    1454    1464    1468    1488    2918
        2919    2976    2979    2980    2980    3000
        3003    730     948     1094    1352    1353
        1489    2814    2884    2925
      ElectronicLevels[1/cm]    2
        0.0  3
        69.1  1
      Rotor  Hindered   # D5
        Geometry[angstrom]     13
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.49979
              H          0.00000       1.02114      -0.38239
              H          0.88339      -0.50931      -0.38346
              H         -0.88888      -0.50440      -0.38146
              C          0.70748      -1.00290       2.29122
              O          1.23186       0.31033       2.13914
              H         -0.86037       0.47502       1.96655
              C          0.27674      -1.40108       3.67154
              H          1.26578      -1.75714       1.74063
              H         -0.34736      -2.29500       3.63351
              H         -0.28948      -0.59854       4.14287
              H          1.14436      -1.62002       4.29465
        Group                        3   4   5
        Axis                         1   2
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.1943  2.5713  1.1856
      End  ! HindRot
      Rotor  Hindered   # D10
        Geometry[angstrom]     13
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.49979
              H          0.00000       1.02114      -0.38239
              H          0.88339      -0.50931      -0.38346
              H         -0.88888      -0.50440      -0.38146
              C          0.70748      -1.00290       2.29122
              O          1.23186       0.31033       2.13914
              H         -0.86037       0.47502       1.96655
              C          0.27674      -1.40108       3.67154
              H          1.26578      -1.75714       1.74063
              H         -0.34736      -2.29500       3.63351
              H         -0.28948      -0.59854       4.14287
              H          1.14436      -1.62002       4.29465
        Group                        1   2   3   4   5   7   8   10
        Axis                         6   9
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.1701  2.5711  1.1575
      End  ! HindRot
      ZeroEnergy[kcal/mol]      -3.00
  End  ! Species
End  ! Well
Well FakeW-C4H7ORvE4fmAA0+CH4O-S58WKw   ! Fake Well for C4H7ORvE4fmAA0+CH4O-S58WKw
  Species
    RRHO
      Geometry[angstrom]        18
        C          0.64285      -0.21677      -0.39979
        C          1.95987      -0.43960       0.15071
        C         -0.56245      -0.06418       0.44832
        H          0.46836      -0.56764      -1.41016
        O          0.03097       1.08837      -0.13703
        C         -1.92629      -0.44816      -0.04423
        H         -0.40954      -0.13501       1.52158
        H          2.22412      -0.00291       1.10038
        H          2.69112      -1.02269      -0.38342
        H         -2.68268       0.20926       0.38393
        H         -2.16357      -1.47188       0.24491
        H         -1.97645      -0.36662      -1.12805
        C          0.72589      -0.04626       4.98620
        O         -0.68636       0.09526       4.98620
        H          1.09068      -0.56779       5.87435
        H          1.09063      -0.56814       4.09824
        H          1.14307       0.95692       4.98604
        H         -1.07438      -0.78198       4.98626
      Core RigidRotor
        SymmetryFactor          1.0
      End  ! Core
      Frequencies[1/cm]         45
        10      20      30      40      50      60
        247     287     451     464     549     699
        812     882     964     1025    1057    1133
        1144    1164    1232    1337    1380    1414
        1446    1455    1467    2919    2976    2982
        3001    3010    3042    3145    1036    1069
        1155    1351    1453    1471    1485    2887
        2935    2999    3665
      ElectronicLevels[1/cm]    1
        0.0  2
      Rotor  Hindered   # D7
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.44559
              C          0.00000       1.24745      -0.79839
              H         -0.42947      -0.87132      -0.48562
              O          1.18318       0.49653      -0.65920
              C         -0.61408       1.31351      -2.16545
              H          0.00362       2.18059      -0.23902
              H          0.54715       0.76113       1.98232
              H         -0.53462      -0.75686       1.99812
              H         -0.05864       2.00835      -2.79651
              H         -1.64590       1.66091      -2.10385
              H         -0.59969       0.33346      -2.64082
        Group                        3   4   5   6   7   10  11  12
        Axis                         1   2
        Symmetry                     1
        PotentialSpline[kcal/mol]    12   11
          0.00    30.00   60.00   90.00   120.00  150.00
          180.00  210.00  240.00  270.00  300.00  330.00
          0.0000  1.1975  3.9796  5.4028  3.5627  0.8968
          0.0002  0.7866  3.2526  5.3325  3.4394  1.1154
      End  ! HindRot
      Rotor  Hindered   # D9
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.44559
              C          0.00000       1.24745      -0.79839
              H         -0.42947      -0.87132      -0.48562
              O          1.18318       0.49653      -0.65920
              C         -0.61408       1.31351      -2.16545
              H          0.00362       2.18059      -0.23902
              H          0.54715       0.76113       1.98232
              H         -0.53462      -0.75686       1.99812
              H         -0.05864       2.00835      -2.79651
              H         -1.64590       1.66091      -2.10385
              H         -0.59969       0.33346      -2.64082
        Group                        1   2   4   5   7   8   9
        Axis                         3   6
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.3355  2.9126  1.3504
      End  ! HindRot
      Rotor  Hindered   # D5
        Geometry[angstrom]     6
              C          0.00000       0.00000       0.00000
              O          0.00000       0.00000       1.41013
              H          0.00000       1.01233      -0.41725
              H          0.84975      -0.55023      -0.41722
              H         -0.91402      -0.49710      -0.31927
              H          0.79629       0.43390       1.71285
        Group                        3   4   5
        Axis                         1   2
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  0.5390  1.1107  0.6196
      End  ! HindRot
      ZeroEnergy[kcal/mol]      -8.58
  End  ! Species
End  ! Well
Bimolecular C4H8ORvEsWvAA0+CH3O-S58cwB   ! [C[C@H]1[C@H](C)O1 + C[O]]
!---------------------------------------------------
  Fragment C4H8ORvEsWvAA0   ! C[C@H]1[C@H](C)O1
    RRHO
      Geometry[angstrom]        13
        C          1.96812      -0.38740       0.09372
        C          0.59325      -0.09461      -0.42797
        H          2.71174       0.21587      -0.42599
        H          2.02749      -0.16212       1.15658
        H          2.21886      -1.43767      -0.05731
        C         -0.59320      -0.09426       0.42789
        O         -0.00006       1.14417      -0.00010
        H          0.43493      -0.30130      -1.48246
        C         -1.96810      -0.38748      -0.09359
        H         -0.43492      -0.30099       1.48241
        H         -2.21838      -1.43791       0.05717
        H         -2.02781      -0.16193      -1.15637
        H         -2.71186       0.21525       0.42655
      Core RigidRotor
        SymmetryFactor          2.0
      End  ! Core
      Frequencies[1/cm]         31
        244     280     455     469     739     813
        894     959     1020    1028    1113    1124
        1158    1170    1262    1340    1383    1387
        1443    1454    1464    1468    1488    2918
        2919    2976    2979    2980    2980    3000
        3003
      ElectronicLevels[1/cm]    1
        0.0  1
      Rotor  Hindered   # D5
        Geometry[angstrom]     13
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.49979
              H          0.00000       1.02114      -0.38239
              H          0.88339      -0.50931      -0.38346
              H         -0.88888      -0.50440      -0.38146
              C          0.70748      -1.00290       2.29122
              O          1.23186       0.31033       2.13914
              H         -0.86037       0.47502       1.96655
              C          0.27674      -1.40108       3.67154
              H          1.26578      -1.75714       1.74063
              H         -0.34736      -2.29500       3.63351
              H         -0.28948      -0.59854       4.14287
              H          1.14436      -1.62002       4.29465
        Group                        3   4   5
        Axis                         1   2
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.1943  2.5713  1.1856
      End  ! HindRot
      Rotor  Hindered   # D10
        Geometry[angstrom]     13
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.49979
              H          0.00000       1.02114      -0.38239
              H          0.88339      -0.50931      -0.38346
              H         -0.88888      -0.50440      -0.38146
              C          0.70748      -1.00290       2.29122
              O          1.23186       0.31033       2.13914
              H         -0.86037       0.47502       1.96655
              C          0.27674      -1.40108       3.67154
              H          1.26578      -1.75714       1.74063
              H         -0.34736      -2.29500       3.63351
              H         -0.28948      -0.59854       4.14287
              H          1.14436      -1.62002       4.29465
        Group                        1   2   3   4   5   7   8   10
        Axis                         6   9
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.1701  2.5711  1.1575
      End  ! HindRot
      ZeroEnergy[kcal/mol]    0.0
  End  ! Frag1
!---------------------------------------------------
  Fragment CH3O-S58cwB   ! C[O]
    RRHO
      Geometry[angstrom]        5
        C          0.01064      -0.57561      -0.00000
        O          0.01064       0.79141       0.00000
        H         -1.05365      -0.86491      -0.00000
        H          0.45233      -1.00634       0.90414
        H          0.45233      -1.00634      -0.90414
      Core RigidRotor
        SymmetryFactor          1.0
      End  ! Core
      Frequencies[1/cm]         9
        730     948     1094    1352    1353    1489
        2814    2884    2925
      ElectronicLevels[1/cm]    2
        0.0  3
        69.1  1
      ZeroEnergy[kcal/mol]    0.0
  End  ! Frag2
!---------------------------------------------------
  GroundEnergy[kcal/mol]    0.00
End  ! Bimol
Bimolecular C4H7ORvE4fmAA0+CH4O-S58WKw   ! [[CH2][C@H]1[C@H](C)O1 + CO]
!---------------------------------------------------
  Fragment C4H7ORvE4fmAA0 density   ! [CH2][C@H]1[C@H](C)O1
    RRHO
      Geometry[angstrom]        12
        C          0.66636      -0.17413      -0.40397
        C          1.98338      -0.39696       0.14653
        C         -0.53894      -0.02155       0.44414
        H          0.49187      -0.52500      -1.41434
        O          0.05448       1.13100      -0.14121
        C         -1.90277      -0.40553      -0.04841
        H         -0.38603      -0.09237       1.51741
        H          2.24763       0.03973       1.09620
        H          2.71463      -0.98005      -0.38760
        H         -2.65917       0.25189       0.37975
        H         -2.14006      -1.42924       0.24073
        H         -1.95294      -0.32398      -1.13223
      Core RigidRotor
        SymmetryFactor          1.0
      End  ! Core
      Frequencies[1/cm]         28
        247     287     451     464     549     699
        812     882     964     1025    1057    1133
        1144    1164    1232    1337    1380    1414
        1446    1455    1467    2919    2976    2982
        3001    3010    3042    3145
      ElectronicLevels[1/cm]    1
        0.0  2
      Rotor  Hindered   # D7
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.44559
              C          0.00000       1.24745      -0.79839
              H         -0.42947      -0.87132      -0.48562
              O          1.18318       0.49653      -0.65920
              C         -0.61408       1.31351      -2.16545
              H          0.00362       2.18059      -0.23902
              H          0.54715       0.76113       1.98232
              H         -0.53462      -0.75686       1.99812
              H         -0.05864       2.00835      -2.79651
              H         -1.64590       1.66091      -2.10385
              H         -0.59969       0.33346      -2.64082
        Group                        3   4   5   6   7   10  11  12
        Axis                         1   2
        Symmetry                     1
        PotentialSpline[kcal/mol]    12   11
          0.00    30.00   60.00   90.00   120.00  150.00
          180.00  210.00  240.00  270.00  300.00  330.00
          0.0000  1.1975  3.9796  5.4028  3.5627  0.8968
          0.0002  0.7866  3.2526  5.3325  3.4394  1.1154
      End  ! HindRot
      Rotor  Hindered   # D9
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.44559
              C          0.00000       1.24745      -0.79839
              H         -0.42947      -0.87132      -0.48562
              O          1.18318       0.49653      -0.65920
              C         -0.61408       1.31351      -2.16545
              H          0.00362       2.18059      -0.23902
              H          0.54715       0.76113       1.98232
              H         -0.53462      -0.75686       1.99812
              H         -0.05864       2.00835      -2.79651
              H         -1.64590       1.66091      -2.10385
              H         -0.59969       0.33346      -2.64082
        Group                        1   2   4   5   7   8   9
        Axis                         3   6
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.3355  2.9126  1.3504
      End  ! HindRot
      ZeroEnergy[kcal/mol]    0.0
  End  ! Frag1
!---------------------------------------------------
  Fragment CH4O-S58WKw density   ! CO
    RRHO
      Geometry[angstrom]        6
        C          0.66397      -0.01979      -0.00001
        O         -0.74827       0.12173      -0.00000
        H          1.02877      -0.54132       0.88815
        H          1.02871      -0.54167      -0.88797
        H          1.08116       0.98339      -0.00017
        H         -1.13629      -0.75551       0.00006
      Core RigidRotor
        SymmetryFactor          1.0
      End  ! Core
      Frequencies[1/cm]         11
        1036    1069    1155    1351    1453    1471
        1485    2887    2935    2999    3665
      ElectronicLevels[1/cm]    1
        0.0  1
      Rotor  Hindered   # D5
        Geometry[angstrom]     6
              C          0.00000       0.00000       0.00000
              O          0.00000       0.00000       1.41013
              H          0.00000       1.01233      -0.41725
              H          0.84975      -0.55023      -0.41722
              H         -0.91402      -0.49710      -0.31927
              H          0.79629       0.43390       1.71285
        Group                        3   4   5
        Axis                         1   2
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  0.5390  1.1107  0.6196
      End  ! HindRot
      ZeroEnergy[kcal/mol]    0.0
  End  ! Frag2
!---------------------------------------------------
  GroundEnergy[kcal/mol]    -5.58
End  ! Bimol
Barrier FakeB-C4H8ORvEsWvAA0+CH3O-S58cwB C4H8ORvEsWvAA0+CH3O-S58cwB FakeW-C4H8ORvEsWvAA0+CH3O-S58cwB
  RRHO
    Stoichiometry  C5H11O2
    Core PhaseSpaceTheory
      FragmentGeometry[angstrom]    13
        C          1.96812      -0.38740       0.09372
        C          0.59325      -0.09461      -0.42797
        H          2.71174       0.21587      -0.42599
        H          2.02749      -0.16212       1.15658
        H          2.21886      -1.43767      -0.05731
        C         -0.59320      -0.09426       0.42789
        O         -0.00006       1.14417      -0.00010
        H          0.43493      -0.30130      -1.48246
        C         -1.96810      -0.38748      -0.09359
        H         -0.43492      -0.30099       1.48241
        H         -2.21838      -1.43791       0.05717
        H         -2.02781      -0.16193      -1.15637
        H         -2.71186       0.21525       0.42655
      FragmentGeometry[angstrom]    5
        C          0.01064      -0.57561      -0.00000
        O          0.01064       0.79141       0.00000
        H         -1.05365      -0.86491      -0.00000
        H          0.45233      -1.00634       0.90414
        H          0.45233      -1.00634      -0.90414
      SymmetryFactor                  2.0
      PotentialPrefactor[au]          10.0
      PotentialPowerExponent          6.0
      TSTLevel EJ
    End  ! Core
    Frequencies[1/cm]         40
      244     280     455     469     739     813
      894     959     1020    1028    1113    1124
      1158    1170    1262    1340    1383    1387
      1443    1454    1464    1468    1488    2918
      2919    2976    2979    2980    2980    3000
      3003    730     948     1094    1352    1353
      1489    2814    2884    2925
    ElectronicLevels[1/cm]    2
      0.0  3
      69.1  1
    Rotor  Hindered   # D5
      Geometry[angstrom]     13
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.49979
            H          0.00000       1.02114      -0.38239
            H          0.88339      -0.50931      -0.38346
            H         -0.88888      -0.50440      -0.38146
            C          0.70748      -1.00290       2.29122
            O          1.23186       0.31033       2.13914
            H         -0.86037       0.47502       1.96655
            C          0.27674      -1.40108       3.67154
            H          1.26578      -1.75714       1.74063
            H         -0.34736      -2.29500       3.63351
            H         -0.28948      -0.59854       4.14287
            H          1.14436      -1.62002       4.29465
      Group                        3   4   5
      Axis                         1   2
      Symmetry                     3
      PotentialSpline[kcal/mol]    4   3
        0.00    30.00   60.00   90.00
        0.0000  1.1943  2.5713  1.1856
    End  ! HindRot
    Rotor  Hindered   # D10
      Geometry[angstrom]     13
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.49979
            H          0.00000       1.02114      -0.38239
            H          0.88339      -0.50931      -0.38346
            H         -0.88888      -0.50440      -0.38146
            C          0.70748      -1.00290       2.29122
            O          1.23186       0.31033       2.13914
            H         -0.86037       0.47502       1.96655
            C          0.27674      -1.40108       3.67154
            H          1.26578      -1.75714       1.74063
            H         -0.34736      -2.29500       3.63351
            H         -0.28948      -0.59854       4.14287
            H          1.14436      -1.62002       4.29465
      Group                        1   2   3   4   5   7   8   10
      Axis                         6   9
      Symmetry                     3
      PotentialSpline[kcal/mol]    4   3
        0.00    30.00   60.00   90.00
        0.0000  1.1701  2.5711  1.1575
    End  ! HindRot
    ZeroEnergy[kcal/mol]      0.00
End  ! Barrier
Barrier FakeB-C4H7ORvE4fmAA0+CH4O-S58WKw C4H7ORvE4fmAA0+CH4O-S58WKw FakeW-C4H7ORvE4fmAA0+CH4O-S58WKw
  RRHO
    Stoichiometry  C5H11O2
    Core PhaseSpaceTheory
      FragmentGeometry[angstrom]    12
        C          0.66636      -0.17413      -0.40397
        C          1.98338      -0.39696       0.14653
        C         -0.53894      -0.02155       0.44414
        H          0.49187      -0.52500      -1.41434
        O          0.05448       1.13100      -0.14121
        C         -1.90277      -0.40553      -0.04841
        H         -0.38603      -0.09237       1.51741
        H          2.24763       0.03973       1.09620
        H          2.71463      -0.98005      -0.38760
        H         -2.65917       0.25189       0.37975
        H         -2.14006      -1.42924       0.24073
        H         -1.95294      -0.32398      -1.13223
      FragmentGeometry[angstrom]    6
        C          0.66397      -0.01979      -0.00001
        O         -0.74827       0.12173      -0.00000
        H          1.02877      -0.54132       0.88815
        H          1.02871      -0.54167      -0.88797
        H          1.08116       0.98339      -0.00017
        H         -1.13629      -0.75551       0.00006
      SymmetryFactor                  1.0
      PotentialPrefactor[au]          10.0
      PotentialPowerExponent          6.0
      TSTLevel EJ
    End  ! Core
    Frequencies[1/cm]         39
      247     287     451     464     549     699
      812     882     964     1025    1057    1133
      1144    1164    1232    1337    1380    1414
      1446    1455    1467    2919    2976    2982
      3001    3010    3042    3145    1036    1069
      1155    1351    1453    1471    1485    2887
      2935    2999    3665
    ElectronicLevels[1/cm]    1
      0.0  2
    Rotor  Hindered   # D7
      Geometry[angstrom]     12
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.44559
            C          0.00000       1.24745      -0.79839
            H         -0.42947      -0.87132      -0.48562
            O          1.18318       0.49653      -0.65920
            C         -0.61408       1.31351      -2.16545
            H          0.00362       2.18059      -0.23902
            H          0.54715       0.76113       1.98232
            H         -0.53462      -0.75686       1.99812
            H         -0.05864       2.00835      -2.79651
            H         -1.64590       1.66091      -2.10385
            H         -0.59969       0.33346      -2.64082
      Group                        3   4   5   6   7   10  11  12
      Axis                         1   2
      Symmetry                     1
      PotentialSpline[kcal/mol]    12   11
        0.00    30.00   60.00   90.00   120.00  150.00
        180.00  210.00  240.00  270.00  300.00  330.00
        0.0000  1.1975  3.9796  5.4028  3.5627  0.8968
        0.0002  0.7866  3.2526  5.3325  3.4394  1.1154
    End  ! HindRot
    Rotor  Hindered   # D9
      Geometry[angstrom]     12
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.44559
            C          0.00000       1.24745      -0.79839
            H         -0.42947      -0.87132      -0.48562
            O          1.18318       0.49653      -0.65920
            C         -0.61408       1.31351      -2.16545
            H          0.00362       2.18059      -0.23902
            H          0.54715       0.76113       1.98232
            H         -0.53462      -0.75686       1.99812
            H         -0.05864       2.00835      -2.79651
            H         -1.64590       1.66091      -2.10385
            H         -0.59969       0.33346      -2.64082
      Group                        1   2   4   5   7   8   9
      Axis                         3   6
      Symmetry                     3
      PotentialSpline[kcal/mol]    4   3
        0.00    30.00   60.00   90.00
        0.0000  1.3355  2.9126  1.3504
    End  ! HindRot
    Rotor  Hindered   # D5
      Geometry[angstrom]     6
            C          0.00000       0.00000       0.00000
            O          0.00000       0.00000       1.41013
            H          0.00000       1.01233      -0.41725
            H          0.84975      -0.55023      -0.41722
            H         -0.91402      -0.49710      -0.31927
            H          0.79629       0.43390       1.71285
      Group                        3   4   5
      Axis                         1   2
      Symmetry                     3
      PotentialSpline[kcal/mol]    4   3
        0.00    30.00   60.00   90.00
        0.0000  0.5390  1.1107  0.6196
    End  ! HindRot
    ZeroEnergy[kcal/mol]      -5.58
End  ! Barrier
Barrier ts_5_1 FakeW-C4H8ORvEsWvAA0+CH3O-S58cwB FakeW-C4H7ORvE4fmAA0+CH4O-S58WKw
  RRHO
    Geometry[angstrom]        18
      C          0.57037       0.45144      -0.30789
      C         -0.46010       1.30839       0.31784
      C          1.79510       0.04154       0.39920
      H          0.61925       0.48152      -1.39132
      O          0.70810      -0.87781       0.23412
      C          3.06476      -0.28469      -0.32790
      H          1.90863       0.39165       1.42060
      H         -1.57223       0.90085      -0.07844
      H         -0.49956       1.23133       1.40063
      H         -0.45141       2.33840      -0.03087
      H          3.71573       0.58855      -0.36996
      H          2.84915      -0.61231      -1.34262
      H          3.60155      -1.08285       0.18398
      O         -2.63968       0.36068      -0.47056
      C         -2.70918      -0.90591       0.13098
      H         -2.80974      -0.85293       1.21840
      H         -1.85918      -1.54120      -0.12411
      H         -3.61525      -1.37065      -0.26819
    Core RigidRotor
      SymmetryFactor          0.5
    End  ! Core
    Frequencies[1/cm]         43
      94      170     257     288     428     463
      587     621     739     818     891     951
      1019    1021    1033    1091    1119    1128
      1151    1155    1168    1225    1250    1342
      1371    1383    1411    1413    1424    1443
      1459    1471    1485    2874    2920    2932
      2952    2958    2982    2983    2996    3005
      3036
    ElectronicLevels[1/cm]    1
      0.0  2
    Rotor  Hindered   # D7
      Geometry[angstrom]     18
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.47947
            C          0.00000       1.23969      -0.78908
            H         -0.42778      -0.88107      -0.47066
            O          1.18258       0.47290      -0.63902
            C         -0.59187       1.31372      -2.16463
            H          0.01541       2.17377      -0.23245
            H          0.71462      -0.96861       1.85477
            H          0.46465       0.87734       1.92315
            H         -0.96483      -0.23669       1.92282
            H         -1.62087       1.67181      -2.11728
            H         -0.58194       0.33392      -2.64022
            H         -0.02089       2.00355      -2.78680
            O          1.51071      -1.88124       2.13322
            C          2.78645      -1.44340       1.77483
            H          3.12642      -0.59190       2.37423
            H          2.86420      -1.19213       0.71334
            H          3.45882      -2.28377       1.97477
      Group                        3   4   5   6   7   11  12  13
      Axis                         1   2
      Symmetry                     1
      PotentialSpline[kcal/mol]    12   11
        0.00    30.00   60.00   90.00   120.00  150.00
        180.00  210.00  240.00  270.00  300.00  330.00
        0.0000  1.4481  3.7047  4.4212  3.3630  1.4903
        1.3862  1.0998  1.5791  3.2727  3.8057  1.4221
    End  ! HindRot
    Rotor  Hindered   # D11
      Geometry[angstrom]     18
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.47947
            C          0.00000       1.23969      -0.78908
            H         -0.42778      -0.88107      -0.47066
            O          1.18258       0.47290      -0.63902
            C         -0.59187       1.31372      -2.16463
            H          0.01541       2.17377      -0.23245
            H          0.71462      -0.96861       1.85477
            H          0.46465       0.87734       1.92315
            H         -0.96483      -0.23669       1.92282
            H         -1.62087       1.67181      -2.11728
            H         -0.58194       0.33392      -2.64022
            H         -0.02089       2.00355      -2.78680
            O          1.51071      -1.88124       2.13322
            C          2.78645      -1.44340       1.77483
            H          3.12642      -0.59190       2.37423
            H          2.86420      -1.19213       0.71334
            H          3.45882      -2.28377       1.97477
      Group                        1   2   4   5   7   8   9   10  14  15  16  17  18
      Axis                         3   6
      Symmetry                     3
      PotentialSpline[kcal/mol]    4   3
        0.00    30.00   60.00   90.00
        0.0000  1.1572  2.5615  1.1578
    End  ! HindRot
    Rotor  Hindered   # D15
      Geometry[angstrom]     18
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.47947
            C          0.00000       1.23969      -0.78908
            H         -0.42778      -0.88107      -0.47066
            O          1.18258       0.47290      -0.63902
            C         -0.59187       1.31372      -2.16463
            H          0.01541       2.17377      -0.23245
            H          0.71462      -0.96861       1.85477
            H          0.46465       0.87734       1.92315
            H         -0.96483      -0.23669       1.92282
            H         -1.62087       1.67181      -2.11728
            H         -0.58194       0.33392      -2.64022
            H         -0.02089       2.00355      -2.78680
            O          1.51071      -1.88124       2.13322
            C          2.78645      -1.44340       1.77483
            H          3.12642      -0.59190       2.37423
            H          2.86420      -1.19213       0.71334
            H          3.45882      -2.28377       1.97477
      Group                        1   2   3   4   5   6   7   9   10  11  12  13
      Axis                         8   14
      Symmetry                     1
      PotentialSpline[kcal/mol]    12   11
        0.00    30.00   60.00   90.00   120.00  150.00
        180.00  210.00  240.00  270.00  300.00  330.00
        0.0000  0.3015  0.9813  1.2824  1.3488  1.3533
        1.3214  1.2012  0.9296  0.4805  0.2808  0.0778
    End  ! HindRot
    Rotor  Hindered   # D16
      Geometry[angstrom]     18
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.47947
            C          0.00000       1.23969      -0.78908
            H         -0.42778      -0.88107      -0.47066
            O          1.18258       0.47290      -0.63902
            C         -0.59187       1.31372      -2.16463
            H          0.01541       2.17377      -0.23245
            H          0.71462      -0.96861       1.85477
            H          0.46465       0.87734       1.92315
            H         -0.96483      -0.23669       1.92282
            H         -1.62087       1.67181      -2.11728
            H         -0.58194       0.33392      -2.64022
            H         -0.02089       2.00355      -2.78680
            O          1.51071      -1.88124       2.13322
            C          2.78645      -1.44340       1.77483
            H          3.12642      -0.59190       2.37423
            H          2.86420      -1.19213       0.71334
            H          3.45882      -2.28377       1.97477
      Group                        1   2   3   4   5   6   7   8   9   10  11  12  13
      Axis                         14  15
      Symmetry                     3
      PotentialSpline[kcal/mol]    4   3
        0.00    30.00   60.00   90.00
        0.0000  0.5464  1.1225  0.4722
    End  ! HindRot
    ZeroEnergy[kcal/mol]      7.86
    Tunneling  Eckart
      ImaginaryFrequency[1/cm]  1689
      WellDepth[kcal/mol]       10.86
      WellDepth[kcal/mol]       16.44
  End
End  ! Barrier
peds ('C4H8ORvEsWvAA0+CH3O-S58cwB=C4H7ORvE4fmAA0+CH4O-S58WKw',)
ene dct test
{'C4H8ORvEsWvAA0+CH3O-S58cwB': 0.0, 'C4H7ORvE4fmAA0+CH4O-S58WKw': -5.58, 'ts_5_1': 7.86}
debug ene_util line 30 energies: ref -5.58, boltz 240.9485163602006, barrier 5.58, sigma 10.731140654408025 

debug ene_util line 30 energies: ref 0, boltz 240.9485163602006, barrier 5.58, sigma 10.731140654408025 

Ranges for k(E) calculations: (0.1, 283.87307897783273, 0.1)
Preparing global keywords section for MESS input...
 - Using temperatures and pressures defined by user
 - Using internal AutoMech defaults for other MESS keywords:
Debug:  EnergyStepOverTemperature, ExcessEnergyOverTemperature, ModelEnergyLimit
Debug:  CalculationMethod, WellCutoff, ReductionMethod, AtomDistanceMin
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Writing MESS input file at /lcrc/project/PACC/AutoMech/data/run/MESS/RATE/C5H11O2_5_1/basev1
Debug:  MESS Input:

!===================================================
!  GLOBAL KEYWORDS
!===================================================
TemperatureList[K]                     300.0  350.0  400.0  450.0  500.0  550.0  600.0  650.0  700.0  750.0  800.0  850.0  900.0  950.0  1000.0
PressureList[atm]                      0.01  0.03  0.1  0.3  1.0  3.0  10.0  30.0  100.0
!
ModelEnergyLimit[kcal/mol]             800.00
EnergyStepOverTemperature              0.20
!
CalculationMethod                      direct
!
WellCutoff                             10
!
ChemicalEigenvalueMax                  0.20
!
ReductionMethod                        diagonalization
!
PEDOutput                              ped.out
PEDSpecies                             C4H8ORvEsWvAA0+CH3O-S58cwB=C4H7ORvE4fmAA0+CH4O-S58WKw
!
MicroRateOutput                        ke.out
MicroEnerMin[kcal/mol]                 0.1
MicroEnerMax[kcal/mol]                 283.87307897783273
MicroEnerStep[kcal/mol]                0.1
!
AtomDistanceMin[angstrom]              0.68793
!
RateOutput                             rate.out
!
!
!===================================================
!  BEGIN MASTER EQUATION MODEL
!===================================================
!
Model
!
GroundEnergyShiftMax[kcal/mol]  10
!
UseShortNames
!
!---------------------------------------------------
!  ENERGY TRANSFER SECTION
!---------------------------------------------------
  EnergyRelaxation
    Exponential
       Factor[1/cm]                     358.194
       Power                            0.989
       ExponentCutoff                   15.000
  End  ! EneRelax
  CollisionFrequency
    LennardJones
       Epsilons[1/cm]                   167.705    167.705
       Sigmas[angstrom]                 4.199      4.199
       Masses[amu]                      72.058     39.962
  End  ! CollidFreq
!---------------------------------------------------
!  REACTION CHANNELS SECTION
!---------------------------------------------------
Well FakeW-C4H8ORvEsWvAA0+CH3O-S58cwB   ! Fake Well for C4H8ORvEsWvAA0+CH3O-S58cwB
  Species
    RRHO
      Geometry[angstrom]        18
        C          1.96812      -0.43374       0.09373
        C          0.59325      -0.14095      -0.42797
        H          2.71174       0.16954      -0.42599
        H          2.02750      -0.20846       1.15658
        H          2.21887      -1.48400      -0.05730
        C         -0.59320      -0.14059       0.42790
        O         -0.00006       1.09783      -0.00010
        H          0.43493      -0.34763      -1.48245
        C         -1.96810      -0.43381      -0.09358
        H         -0.43492      -0.34732       1.48242
        H         -2.21837      -1.48424       0.05718
        H         -2.02781      -0.20826      -1.15636
        H         -2.71186       0.16892       0.42655
        C          0.00588      -0.66753       5.17489
        O          0.00588       0.69949       5.17489
        H         -1.05841      -0.95683       5.17489
        H          0.44756      -1.09825       6.07904
        H          0.44756      -1.09825       4.27075
      Core RigidRotor
        SymmetryFactor          2.0
      End  ! Core
      Frequencies[1/cm]         46
        10      20      30      40      50      60
        244     280     455     469     739     813
        894     959     1020    1028    1113    1124
        1158    1170    1262    1340    1383    1387
        1443    1454    1464    1468    1488    2918
        2919    2976    2979    2980    2980    3000
        3003    730     948     1094    1352    1353
        1489    2814    2884    2925
      ElectronicLevels[1/cm]    2
        0.0  3
        69.1  1
      Rotor  Hindered   # D5
        Geometry[angstrom]     13
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.49979
              H          0.00000       1.02114      -0.38239
              H          0.88339      -0.50931      -0.38346
              H         -0.88888      -0.50440      -0.38146
              C          0.70748      -1.00290       2.29122
              O          1.23186       0.31033       2.13914
              H         -0.86037       0.47502       1.96655
              C          0.27674      -1.40108       3.67154
              H          1.26578      -1.75714       1.74063
              H         -0.34736      -2.29500       3.63351
              H         -0.28948      -0.59854       4.14287
              H          1.14436      -1.62002       4.29465
        Group                        3   4   5
        Axis                         1   2
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.1943  2.5713  1.1856
      End  ! HindRot
      Rotor  Hindered   # D10
        Geometry[angstrom]     13
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.49979
              H          0.00000       1.02114      -0.38239
              H          0.88339      -0.50931      -0.38346
              H         -0.88888      -0.50440      -0.38146
              C          0.70748      -1.00290       2.29122
              O          1.23186       0.31033       2.13914
              H         -0.86037       0.47502       1.96655
              C          0.27674      -1.40108       3.67154
              H          1.26578      -1.75714       1.74063
              H         -0.34736      -2.29500       3.63351
              H         -0.28948      -0.59854       4.14287
              H          1.14436      -1.62002       4.29465
        Group                        1   2   3   4   5   7   8   10
        Axis                         6   9
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.1701  2.5711  1.1575
      End  ! HindRot
      ZeroEnergy[kcal/mol]      -3.00
  End  ! Species
End  ! Well
Well FakeW-C4H7ORvE4fmAA0+CH4O-S58WKw   ! Fake Well for C4H7ORvE4fmAA0+CH4O-S58WKw
  Species
    RRHO
      Geometry[angstrom]        18
        C          0.64285      -0.21677      -0.39979
        C          1.95987      -0.43960       0.15071
        C         -0.56245      -0.06418       0.44832
        H          0.46836      -0.56764      -1.41016
        O          0.03097       1.08837      -0.13703
        C         -1.92629      -0.44816      -0.04423
        H         -0.40954      -0.13501       1.52158
        H          2.22412      -0.00291       1.10038
        H          2.69112      -1.02269      -0.38342
        H         -2.68268       0.20926       0.38393
        H         -2.16357      -1.47188       0.24491
        H         -1.97645      -0.36662      -1.12805
        C          0.72589      -0.04626       4.98620
        O         -0.68636       0.09526       4.98620
        H          1.09068      -0.56779       5.87435
        H          1.09063      -0.56814       4.09824
        H          1.14307       0.95692       4.98604
        H         -1.07438      -0.78198       4.98626
      Core RigidRotor
        SymmetryFactor          1.0
      End  ! Core
      Frequencies[1/cm]         45
        10      20      30      40      50      60
        247     287     451     464     549     699
        812     882     964     1025    1057    1133
        1144    1164    1232    1337    1380    1414
        1446    1455    1467    2919    2976    2982
        3001    3010    3042    3145    1036    1069
        1155    1351    1453    1471    1485    2887
        2935    2999    3665
      ElectronicLevels[1/cm]    1
        0.0  2
      Rotor  Hindered   # D7
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.44559
              C          0.00000       1.24745      -0.79839
              H         -0.42947      -0.87132      -0.48562
              O          1.18318       0.49653      -0.65920
              C         -0.61408       1.31351      -2.16545
              H          0.00362       2.18059      -0.23902
              H          0.54715       0.76113       1.98232
              H         -0.53462      -0.75686       1.99812
              H         -0.05864       2.00835      -2.79651
              H         -1.64590       1.66091      -2.10385
              H         -0.59969       0.33346      -2.64082
        Group                        3   4   5   6   7   10  11  12
        Axis                         1   2
        Symmetry                     1
        PotentialSpline[kcal/mol]    12   11
          0.00    30.00   60.00   90.00   120.00  150.00
          180.00  210.00  240.00  270.00  300.00  330.00
          0.0000  1.1975  3.9796  5.4028  3.5627  0.8968
          0.0002  0.7866  3.2526  5.3325  3.4394  1.1154
      End  ! HindRot
      Rotor  Hindered   # D9
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.44559
              C          0.00000       1.24745      -0.79839
              H         -0.42947      -0.87132      -0.48562
              O          1.18318       0.49653      -0.65920
              C         -0.61408       1.31351      -2.16545
              H          0.00362       2.18059      -0.23902
              H          0.54715       0.76113       1.98232
              H         -0.53462      -0.75686       1.99812
              H         -0.05864       2.00835      -2.79651
              H         -1.64590       1.66091      -2.10385
              H         -0.59969       0.33346      -2.64082
        Group                        1   2   4   5   7   8   9
        Axis                         3   6
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.3355  2.9126  1.3504
      End  ! HindRot
      Rotor  Hindered   # D5
        Geometry[angstrom]     6
              C          0.00000       0.00000       0.00000
              O          0.00000       0.00000       1.41013
              H          0.00000       1.01233      -0.41725
              H          0.84975      -0.55023      -0.41722
              H         -0.91402      -0.49710      -0.31927
              H          0.79629       0.43390       1.71285
        Group                        3   4   5
        Axis                         1   2
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  0.5390  1.1107  0.6196
      End  ! HindRot
      ZeroEnergy[kcal/mol]      -8.58
  End  ! Species
End  ! Well
Bimolecular C4H8ORvEsWvAA0+CH3O-S58cwB   ! [C[C@H]1[C@H](C)O1 + C[O]]
!---------------------------------------------------
  Fragment C4H8ORvEsWvAA0   ! C[C@H]1[C@H](C)O1
    RRHO
      Geometry[angstrom]        13
        C          1.96812      -0.38740       0.09372
        C          0.59325      -0.09461      -0.42797
        H          2.71174       0.21587      -0.42599
        H          2.02749      -0.16212       1.15658
        H          2.21886      -1.43767      -0.05731
        C         -0.59320      -0.09426       0.42789
        O         -0.00006       1.14417      -0.00010
        H          0.43493      -0.30130      -1.48246
        C         -1.96810      -0.38748      -0.09359
        H         -0.43492      -0.30099       1.48241
        H         -2.21838      -1.43791       0.05717
        H         -2.02781      -0.16193      -1.15637
        H         -2.71186       0.21525       0.42655
      Core RigidRotor
        SymmetryFactor          2.0
      End  ! Core
      Frequencies[1/cm]         31
        244     280     455     469     739     813
        894     959     1020    1028    1113    1124
        1158    1170    1262    1340    1383    1387
        1443    1454    1464    1468    1488    2918
        2919    2976    2979    2980    2980    3000
        3003
      ElectronicLevels[1/cm]    1
        0.0  1
      Rotor  Hindered   # D5
        Geometry[angstrom]     13
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.49979
              H          0.00000       1.02114      -0.38239
              H          0.88339      -0.50931      -0.38346
              H         -0.88888      -0.50440      -0.38146
              C          0.70748      -1.00290       2.29122
              O          1.23186       0.31033       2.13914
              H         -0.86037       0.47502       1.96655
              C          0.27674      -1.40108       3.67154
              H          1.26578      -1.75714       1.74063
              H         -0.34736      -2.29500       3.63351
              H         -0.28948      -0.59854       4.14287
              H          1.14436      -1.62002       4.29465
        Group                        3   4   5
        Axis                         1   2
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.1943  2.5713  1.1856
      End  ! HindRot
      Rotor  Hindered   # D10
        Geometry[angstrom]     13
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.49979
              H          0.00000       1.02114      -0.38239
              H          0.88339      -0.50931      -0.38346
              H         -0.88888      -0.50440      -0.38146
              C          0.70748      -1.00290       2.29122
              O          1.23186       0.31033       2.13914
              H         -0.86037       0.47502       1.96655
              C          0.27674      -1.40108       3.67154
              H          1.26578      -1.75714       1.74063
              H         -0.34736      -2.29500       3.63351
              H         -0.28948      -0.59854       4.14287
              H          1.14436      -1.62002       4.29465
        Group                        1   2   3   4   5   7   8   10
        Axis                         6   9
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.1701  2.5711  1.1575
      End  ! HindRot
      ZeroEnergy[kcal/mol]    0.0
  End  ! Frag1
!---------------------------------------------------
  Fragment CH3O-S58cwB   ! C[O]
    RRHO
      Geometry[angstrom]        5
        C          0.01064      -0.57561      -0.00000
        O          0.01064       0.79141       0.00000
        H         -1.05365      -0.86491      -0.00000
        H          0.45233      -1.00634       0.90414
        H          0.45233      -1.00634      -0.90414
      Core RigidRotor
        SymmetryFactor          1.0
      End  ! Core
      Frequencies[1/cm]         9
        730     948     1094    1352    1353    1489
        2814    2884    2925
      ElectronicLevels[1/cm]    2
        0.0  3
        69.1  1
      ZeroEnergy[kcal/mol]    0.0
  End  ! Frag2
!---------------------------------------------------
  GroundEnergy[kcal/mol]    0.00
End  ! Bimol
Bimolecular C4H7ORvE4fmAA0+CH4O-S58WKw   ! [[CH2][C@H]1[C@H](C)O1 + CO]
!---------------------------------------------------
  Fragment C4H7ORvE4fmAA0 density   ! [CH2][C@H]1[C@H](C)O1
    RRHO
      Geometry[angstrom]        12
        C          0.66636      -0.17413      -0.40397
        C          1.98338      -0.39696       0.14653
        C         -0.53894      -0.02155       0.44414
        H          0.49187      -0.52500      -1.41434
        O          0.05448       1.13100      -0.14121
        C         -1.90277      -0.40553      -0.04841
        H         -0.38603      -0.09237       1.51741
        H          2.24763       0.03973       1.09620
        H          2.71463      -0.98005      -0.38760
        H         -2.65917       0.25189       0.37975
        H         -2.14006      -1.42924       0.24073
        H         -1.95294      -0.32398      -1.13223
      Core RigidRotor
        SymmetryFactor          1.0
      End  ! Core
      Frequencies[1/cm]         28
        247     287     451     464     549     699
        812     882     964     1025    1057    1133
        1144    1164    1232    1337    1380    1414
        1446    1455    1467    2919    2976    2982
        3001    3010    3042    3145
      ElectronicLevels[1/cm]    1
        0.0  2
      Rotor  Hindered   # D7
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.44559
              C          0.00000       1.24745      -0.79839
              H         -0.42947      -0.87132      -0.48562
              O          1.18318       0.49653      -0.65920
              C         -0.61408       1.31351      -2.16545
              H          0.00362       2.18059      -0.23902
              H          0.54715       0.76113       1.98232
              H         -0.53462      -0.75686       1.99812
              H         -0.05864       2.00835      -2.79651
              H         -1.64590       1.66091      -2.10385
              H         -0.59969       0.33346      -2.64082
        Group                        3   4   5   6   7   10  11  12
        Axis                         1   2
        Symmetry                     1
        PotentialSpline[kcal/mol]    12   11
          0.00    30.00   60.00   90.00   120.00  150.00
          180.00  210.00  240.00  270.00  300.00  330.00
          0.0000  1.1975  3.9796  5.4028  3.5627  0.8968
          0.0002  0.7866  3.2526  5.3325  3.4394  1.1154
      End  ! HindRot
      Rotor  Hindered   # D9
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.44559
              C          0.00000       1.24745      -0.79839
              H         -0.42947      -0.87132      -0.48562
              O          1.18318       0.49653      -0.65920
              C         -0.61408       1.31351      -2.16545
              H          0.00362       2.18059      -0.23902
              H          0.54715       0.76113       1.98232
              H         -0.53462      -0.75686       1.99812
              H         -0.05864       2.00835      -2.79651
              H         -1.64590       1.66091      -2.10385
              H         -0.59969       0.33346      -2.64082
        Group                        1   2   4   5   7   8   9
        Axis                         3   6
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.3355  2.9126  1.3504
      End  ! HindRot
      ZeroEnergy[kcal/mol]    0.0
  End  ! Frag1
!---------------------------------------------------
  Fragment CH4O-S58WKw density   ! CO
    RRHO
      Geometry[angstrom]        6
        C          0.66397      -0.01979      -0.00001
        O         -0.74827       0.12173      -0.00000
        H          1.02877      -0.54132       0.88815
        H          1.02871      -0.54167      -0.88797
        H          1.08116       0.98339      -0.00017
        H         -1.13629      -0.75551       0.00006
      Core RigidRotor
        SymmetryFactor          1.0
      End  ! Core
      Frequencies[1/cm]         11
        1036    1069    1155    1351    1453    1471
        1485    2887    2935    2999    3665
      ElectronicLevels[1/cm]    1
        0.0  1
      Rotor  Hindered   # D5
        Geometry[angstrom]     6
              C          0.00000       0.00000       0.00000
              O          0.00000       0.00000       1.41013
              H          0.00000       1.01233      -0.41725
              H          0.84975      -0.55023      -0.41722
              H         -0.91402      -0.49710      -0.31927
              H          0.79629       0.43390       1.71285
        Group                        3   4   5
        Axis                         1   2
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  0.5390  1.1107  0.6196
      End  ! HindRot
      ZeroEnergy[kcal/mol]    0.0
  End  ! Frag2
!---------------------------------------------------
  GroundEnergy[kcal/mol]    -5.58
End  ! Bimol
Barrier FakeB-C4H8ORvEsWvAA0+CH3O-S58cwB C4H8ORvEsWvAA0+CH3O-S58cwB FakeW-C4H8ORvEsWvAA0+CH3O-S58cwB
  RRHO
    Stoichiometry  C5H11O2
    Core PhaseSpaceTheory
      FragmentGeometry[angstrom]    13
        C          1.96812      -0.38740       0.09372
        C          0.59325      -0.09461      -0.42797
        H          2.71174       0.21587      -0.42599
        H          2.02749      -0.16212       1.15658
        H          2.21886      -1.43767      -0.05731
        C         -0.59320      -0.09426       0.42789
        O         -0.00006       1.14417      -0.00010
        H          0.43493      -0.30130      -1.48246
        C         -1.96810      -0.38748      -0.09359
        H         -0.43492      -0.30099       1.48241
        H         -2.21838      -1.43791       0.05717
        H         -2.02781      -0.16193      -1.15637
        H         -2.71186       0.21525       0.42655
      FragmentGeometry[angstrom]    5
        C          0.01064      -0.57561      -0.00000
        O          0.01064       0.79141       0.00000
        H         -1.05365      -0.86491      -0.00000
        H          0.45233      -1.00634       0.90414
        H          0.45233      -1.00634      -0.90414
      SymmetryFactor                  2.0
      PotentialPrefactor[au]          10.0
      PotentialPowerExponent          6.0
      TSTLevel EJ
    End  ! Core
    Frequencies[1/cm]         40
      244     280     455     469     739     813
      894     959     1020    1028    1113    1124
      1158    1170    1262    1340    1383    1387
      1443    1454    1464    1468    1488    2918
      2919    2976    2979    2980    2980    3000
      3003    730     948     1094    1352    1353
      1489    2814    2884    2925
    ElectronicLevels[1/cm]    2
      0.0  3
      69.1  1
    Rotor  Hindered   # D5
      Geometry[angstrom]     13
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.49979
            H          0.00000       1.02114      -0.38239
            H          0.88339      -0.50931      -0.38346
            H         -0.88888      -0.50440      -0.38146
            C          0.70748      -1.00290       2.29122
            O          1.23186       0.31033       2.13914
            H         -0.86037       0.47502       1.96655
            C          0.27674      -1.40108       3.67154
            H          1.26578      -1.75714       1.74063
            H         -0.34736      -2.29500       3.63351
            H         -0.28948      -0.59854       4.14287
            H          1.14436      -1.62002       4.29465
      Group                        3   4   5
      Axis                         1   2
      Symmetry                     3
      PotentialSpline[kcal/mol]    4   3
        0.00    30.00   60.00   90.00
        0.0000  1.1943  2.5713  1.1856
    End  ! HindRot
    Rotor  Hindered   # D10
      Geometry[angstrom]     13
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.49979
            H          0.00000       1.02114      -0.38239
            H          0.88339      -0.50931      -0.38346
            H         -0.88888      -0.50440      -0.38146
            C          0.70748      -1.00290       2.29122
            O          1.23186       0.31033       2.13914
            H         -0.86037       0.47502       1.96655
            C          0.27674      -1.40108       3.67154
            H          1.26578      -1.75714       1.74063
            H         -0.34736      -2.29500       3.63351
            H         -0.28948      -0.59854       4.14287
            H          1.14436      -1.62002       4.29465
      Group                        1   2   3   4   5   7   8   10
      Axis                         6   9
      Symmetry                     3
      PotentialSpline[kcal/mol]    4   3
        0.00    30.00   60.00   90.00
        0.0000  1.1701  2.5711  1.1575
    End  ! HindRot
    ZeroEnergy[kcal/mol]      0.00
End  ! Barrier
Barrier FakeB-C4H7ORvE4fmAA0+CH4O-S58WKw C4H7ORvE4fmAA0+CH4O-S58WKw FakeW-C4H7ORvE4fmAA0+CH4O-S58WKw
  RRHO
    Stoichiometry  C5H11O2
    Core PhaseSpaceTheory
      FragmentGeometry[angstrom]    12
        C          0.66636      -0.17413      -0.40397
        C          1.98338      -0.39696       0.14653
        C         -0.53894      -0.02155       0.44414
        H          0.49187      -0.52500      -1.41434
        O          0.05448       1.13100      -0.14121
        C         -1.90277      -0.40553      -0.04841
        H         -0.38603      -0.09237       1.51741
        H          2.24763       0.03973       1.09620
        H          2.71463      -0.98005      -0.38760
        H         -2.65917       0.25189       0.37975
        H         -2.14006      -1.42924       0.24073
        H         -1.95294      -0.32398      -1.13223
      FragmentGeometry[angstrom]    6
        C          0.66397      -0.01979      -0.00001
        O         -0.74827       0.12173      -0.00000
        H          1.02877      -0.54132       0.88815
        H          1.02871      -0.54167      -0.88797
        H          1.08116       0.98339      -0.00017
        H         -1.13629      -0.75551       0.00006
      SymmetryFactor                  1.0
      PotentialPrefactor[au]          10.0
      PotentialPowerExponent          6.0
      TSTLevel EJ
    End  ! Core
    Frequencies[1/cm]         39
      247     287     451     464     549     699
      812     882     964     1025    1057    1133
      1144    1164    1232    1337    1380    1414
      1446    1455    1467    2919    2976    2982
      3001    3010    3042    3145    1036    1069
      1155    1351    1453    1471    1485    2887
      2935    2999    3665
    ElectronicLevels[1/cm]    1
      0.0  2
    Rotor  Hindered   # D7
      Geometry[angstrom]     12
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.44559
            C          0.00000       1.24745      -0.79839
            H         -0.42947      -0.87132      -0.48562
            O          1.18318       0.49653      -0.65920
            C         -0.61408       1.31351      -2.16545
            H          0.00362       2.18059      -0.23902
            H          0.54715       0.76113       1.98232
            H         -0.53462      -0.75686       1.99812
            H         -0.05864       2.00835      -2.79651
            H         -1.64590       1.66091      -2.10385
            H         -0.59969       0.33346      -2.64082
      Group                        3   4   5   6   7   10  11  12
      Axis                         1   2
      Symmetry                     1
      PotentialSpline[kcal/mol]    12   11
        0.00    30.00   60.00   90.00   120.00  150.00
        180.00  210.00  240.00  270.00  300.00  330.00
        0.0000  1.1975  3.9796  5.4028  3.5627  0.8968
        0.0002  0.7866  3.2526  5.3325  3.4394  1.1154
    End  ! HindRot
    Rotor  Hindered   # D9
      Geometry[angstrom]     12
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.44559
            C          0.00000       1.24745      -0.79839
            H         -0.42947      -0.87132      -0.48562
            O          1.18318       0.49653      -0.65920
            C         -0.61408       1.31351      -2.16545
            H          0.00362       2.18059      -0.23902
            H          0.54715       0.76113       1.98232
            H         -0.53462      -0.75686       1.99812
            H         -0.05864       2.00835      -2.79651
            H         -1.64590       1.66091      -2.10385
            H         -0.59969       0.33346      -2.64082
      Group                        1   2   4   5   7   8   9
      Axis                         3   6
      Symmetry                     3
      PotentialSpline[kcal/mol]    4   3
        0.00    30.00   60.00   90.00
        0.0000  1.3355  2.9126  1.3504
    End  ! HindRot
    Rotor  Hindered   # D5
      Geometry[angstrom]     6
            C          0.00000       0.00000       0.00000
            O          0.00000       0.00000       1.41013
            H          0.00000       1.01233      -0.41725
            H          0.84975      -0.55023      -0.41722
            H         -0.91402      -0.49710      -0.31927
            H          0.79629       0.43390       1.71285
      Group                        3   4   5
      Axis                         1   2
      Symmetry                     3
      PotentialSpline[kcal/mol]    4   3
        0.00    30.00   60.00   90.00
        0.0000  0.5390  1.1107  0.6196
    End  ! HindRot
    ZeroEnergy[kcal/mol]      -5.58
End  ! Barrier
Barrier ts_5_1 FakeW-C4H8ORvEsWvAA0+CH3O-S58cwB FakeW-C4H7ORvE4fmAA0+CH4O-S58WKw
  RRHO
    Geometry[angstrom]        18
      C          0.57037       0.45144      -0.30789
      C         -0.46010       1.30839       0.31784
      C          1.79510       0.04154       0.39920
      H          0.61925       0.48152      -1.39132
      O          0.70810      -0.87781       0.23412
      C          3.06476      -0.28469      -0.32790
      H          1.90863       0.39165       1.42060
      H         -1.57223       0.90085      -0.07844
      H         -0.49956       1.23133       1.40063
      H         -0.45141       2.33840      -0.03087
      H          3.71573       0.58855      -0.36996
      H          2.84915      -0.61231      -1.34262
      H          3.60155      -1.08285       0.18398
      O         -2.63968       0.36068      -0.47056
      C         -2.70918      -0.90591       0.13098
      H         -2.80974      -0.85293       1.21840
      H         -1.85918      -1.54120      -0.12411
      H         -3.61525      -1.37065      -0.26819
    Core RigidRotor
      SymmetryFactor          0.5
    End  ! Core
    Frequencies[1/cm]         43
      94      170     257     288     428     463
      587     621     739     818     891     951
      1019    1021    1033    1091    1119    1128
      1151    1155    1168    1225    1250    1342
      1371    1383    1411    1413    1424    1443
      1459    1471    1485    2874    2920    2932
      2952    2958    2982    2983    2996    3005
      3036
    ElectronicLevels[1/cm]    1
      0.0  2
    Rotor  Hindered   # D7
      Geometry[angstrom]     18
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.47947
            C          0.00000       1.23969      -0.78908
            H         -0.42778      -0.88107      -0.47066
            O          1.18258       0.47290      -0.63902
            C         -0.59187       1.31372      -2.16463
            H          0.01541       2.17377      -0.23245
            H          0.71462      -0.96861       1.85477
            H          0.46465       0.87734       1.92315
            H         -0.96483      -0.23669       1.92282
            H         -1.62087       1.67181      -2.11728
            H         -0.58194       0.33392      -2.64022
            H         -0.02089       2.00355      -2.78680
            O          1.51071      -1.88124       2.13322
            C          2.78645      -1.44340       1.77483
            H          3.12642      -0.59190       2.37423
            H          2.86420      -1.19213       0.71334
            H          3.45882      -2.28377       1.97477
      Group                        3   4   5   6   7   11  12  13
      Axis                         1   2
      Symmetry                     1
      PotentialSpline[kcal/mol]    12   11
        0.00    30.00   60.00   90.00   120.00  150.00
        180.00  210.00  240.00  270.00  300.00  330.00
        0.0000  1.4481  3.7047  4.4212  3.3630  1.4903
        1.3862  1.0998  1.5791  3.2727  3.8057  1.4221
    End  ! HindRot
    Rotor  Hindered   # D11
      Geometry[angstrom]     18
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.47947
            C          0.00000       1.23969      -0.78908
            H         -0.42778      -0.88107      -0.47066
            O          1.18258       0.47290      -0.63902
            C         -0.59187       1.31372      -2.16463
            H          0.01541       2.17377      -0.23245
            H          0.71462      -0.96861       1.85477
            H          0.46465       0.87734       1.92315
            H         -0.96483      -0.23669       1.92282
            H         -1.62087       1.67181      -2.11728
            H         -0.58194       0.33392      -2.64022
            H         -0.02089       2.00355      -2.78680
            O          1.51071      -1.88124       2.13322
            C          2.78645      -1.44340       1.77483
            H          3.12642      -0.59190       2.37423
            H          2.86420      -1.19213       0.71334
            H          3.45882      -2.28377       1.97477
      Group                        1   2   4   5   7   8   9   10  14  15  16  17  18
      Axis                         3   6
      Symmetry                     3
      PotentialSpline[kcal/mol]    4   3
        0.00    30.00   60.00   90.00
        0.0000  1.1572  2.5615  1.1578
    End  ! HindRot
    Rotor  Hindered   # D15
      Geometry[angstrom]     18
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.47947
            C          0.00000       1.23969      -0.78908
            H         -0.42778      -0.88107      -0.47066
            O          1.18258       0.47290      -0.63902
            C         -0.59187       1.31372      -2.16463
            H          0.01541       2.17377      -0.23245
            H          0.71462      -0.96861       1.85477
            H          0.46465       0.87734       1.92315
            H         -0.96483      -0.23669       1.92282
            H         -1.62087       1.67181      -2.11728
            H         -0.58194       0.33392      -2.64022
            H         -0.02089       2.00355      -2.78680
            O          1.51071      -1.88124       2.13322
            C          2.78645      -1.44340       1.77483
            H          3.12642      -0.59190       2.37423
            H          2.86420      -1.19213       0.71334
            H          3.45882      -2.28377       1.97477
      Group                        1   2   3   4   5   6   7   9   10  11  12  13
      Axis                         8   14
      Symmetry                     1
      PotentialSpline[kcal/mol]    12   11
        0.00    30.00   60.00   90.00   120.00  150.00
        180.00  210.00  240.00  270.00  300.00  330.00
        0.0000  0.3015  0.9813  1.2824  1.3488  1.3533
        1.3214  1.2012  0.9296  0.4805  0.2808  0.0778
    End  ! HindRot
    Rotor  Hindered   # D16
      Geometry[angstrom]     18
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.47947
            C          0.00000       1.23969      -0.78908
            H         -0.42778      -0.88107      -0.47066
            O          1.18258       0.47290      -0.63902
            C         -0.59187       1.31372      -2.16463
            H          0.01541       2.17377      -0.23245
            H          0.71462      -0.96861       1.85477
            H          0.46465       0.87734       1.92315
            H         -0.96483      -0.23669       1.92282
            H         -1.62087       1.67181      -2.11728
            H         -0.58194       0.33392      -2.64022
            H         -0.02089       2.00355      -2.78680
            O          1.51071      -1.88124       2.13322
            C          2.78645      -1.44340       1.77483
            H          3.12642      -0.59190       2.37423
            H          2.86420      -1.19213       0.71334
            H          3.45882      -2.28377       1.97477
      Group                        1   2   3   4   5   6   7   8   9   10  11  12  13
      Axis                         14  15
      Symmetry                     3
      PotentialSpline[kcal/mol]    4   3
        0.00    30.00   60.00   90.00
        0.0000  0.5464  1.1225  0.4722
    End  ! HindRot
    ZeroEnergy[kcal/mol]      7.86
    Tunneling  Eckart
      ImaginaryFrequency[1/cm]  1689
      WellDepth[kcal/mol]       10.86
      WellDepth[kcal/mol]       16.44
  End
End  ! Barrier
End  ! Model
!
!===================================================
!  END MASTER EQUATION MODEL
!===================================================




--------------------------------------------------------------------------------------
Running MESS base input with version v1 at /lcrc/project/PACC/AutoMech/data/run/MESS/RATE/C5H11O2_5_1/basev1
=========================================

Running PES 1: C4H7O1, SUB PES 1
Running Channel 4: C4H7ORvE4fmAA0 = C4H7O4H74fm0
Running Channel 5: C4H7ORvE4fmAA0 = C4H7O-kSV4fm
Running Channel 6: C4H7ORvE4fmAA0 = C4H6O-RvErx50+H-TcYTcY
Running Channel 7: C4H7O4H74fm0 = C3H4OALAD-Wv9FbZ+CH3
Running Channel 8: C4H7O4H74fm0 = C2H4OALD-UPQWKw+C2H3ALK-S58hH1
Running Channel 9: C4H7O-kSV4fm = C2H4OALD-UPQWKw+C2H3ALK-S58hH1
Preparing reaction channel section for MESS input... 

Calculating reference energy for PES

Determining the reference energy for PES...
 - Reference species assumed to be the  first set of reactants on PES: C4H7ORvE4fmAA0


Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
rEN0cVUMw4ogR   c8f0ODjsIhFlo   0.00  *  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading filesystem info for C4H7ORvE4fmAA0
Using /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/hJUn9NU/CONFS/rEN0cVUMw4ogR/c8f0ODjsIhFlo as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/u-un9NU/CONFS/r6wopFXyayCds/cLnsEWjCyw7Qt for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/hJUn9NU/CONFS/rEN0cVUMw4ogR/c8f0ODjsIhFlo

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
rotor names (('D7',), ('D9',))
potential test:
names ('D7',)
grids ((5.659914076672178, 6.183512852270477, 6.707111627868775, 7.230710403467074, 7.754309179065373, 8.277907954663672, 8.80150673026197, 9.32510550586027, 9.848704281458568, 10.372303057056868, 10.895901832655166, 11.419500608253465),)
max norm diff of splines  0.024248692717860242 0.05
potential test:
names ('D9',)
grids ((3.723571069511098, 4.247169845109397, 4.770768620707695, 5.2943673963059945),)
max norm diff of splines  0.062229782303251026 0.1
Debug:  tors model in scale set 1dhrf
Debug:  tors model in scale set 1dhrf
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/hJUn9NU/CONFS/rEN0cVUMw4ogR/c8f0ODjsIhFlo
Path for PROJROT/FREQ/3882706 Job:
/lcrc/project/PACC/AutoMech/data/run/PROJROT/FREQ/C4H7O/3882706
running projrot the first time:
running projrot the second time:
Debug:  tors model in scale set 1dhrf
TAU FACTOR 45027.273554 	 2 	 1.322525 
Debug:  scale_coeff test: 1.3225251241915417 2 1.3225251241915417 1.3 0.8
value of sfactor is greater than sfacmax

Determining the symmetry factor...
Setting symmetry factors as racemic= True
reduced int sym 2.0

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/hJUn9NU/CONFS/rEN0cVUMw4ogR/c8f0ODjsIhFlo/SP/0zlOGvR
  - Ene = 1.000 x -231.461943106069 Eh
Final electronic energy: -231.461943106069 Eh
Process 3626820 prepping species: C4H7ORvE4fmAA0
[H][H]
C
O

Determining reference molecules for scheme: basic

Determining basis for species: C4H7ORvE4fmAA0
Debug:  Energy will be determined for basis species:  InChI=1S/H2/h1H
Debug:  Energy will be determined for basis species:  InChI=1S/CH4/h1H4
Debug:  Energy will be determined for basis species:  InChI=1S/H2O/h1H2
Process 3626832 reading energy for species: ['InChI=1S/H2/h1H' 'InChI=1S/CH4/h1H4' 'InChI=1S/H2O/h1H2']
Debug:  bases energies test: InChI=1S/H2/h1H REF_1
Using /lcrc/project/PACC/AutoMech/data/save/SPC/H2/UFHFLCQGNIYNRP/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/rltA3tJnYkadM/cfHm_J4NvVMIy as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/H2/UFHFLCQGNIYNRP/0/1/UHFFFAOYSA-N/u-un9NR/CONFS/rqPrrHTfPZAs4/crIudoXA5mZil for torsional profiles

Calculating energy for basis REF_1...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/H2/UFHFLCQGNIYNRP/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/rltA3tJnYkadM/cfHm_J4NvVMIy/SP/0zlOGvR
  - Ene = 1.000 x -1.174043609727 Eh
Final electronic energy: -1.174043609727 Eh
- Calculating zero-point energy
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/H2/UFHFLCQGNIYNRP/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/rltA3tJnYkadM/cfHm_J4NvVMIy
Calling ProjRot to diagonalize Hessian and get freqs...

Harmonic frequencies [cm-1]:
    4465.050

Harmonic ZPVE [kcal mol-1]: 6.383109424534299

Final ZPE: 0.010033791360085153 Eh
Debug:  bases energies test: InChI=1S/CH4/h1H4 CH4
Using /lcrc/project/PACC/AutoMech/data/save/SPC/CH4/VNWKTOKETHGBQD/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/rbpV5y_m2CiIq/cCZ0Vl0o8-H9D as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/CH4/VNWKTOKETHGBQD/0/1/UHFFFAOYSA-N/u-un9NR/CONFS/rSKS01TkSNKYm/cRigmTwsfVEW_ for torsional profiles

Calculating energy for basis CH4...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/CH4/VNWKTOKETHGBQD/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/rbpV5y_m2CiIq/cCZ0Vl0o8-H9D/SP/0zlOGvR
  - Ene = 1.000 x -40.454355702394 Eh
Final electronic energy: -40.454355702394 Eh
- Calculating zero-point energy
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/CH4/VNWKTOKETHGBQD/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/rbpV5y_m2CiIq/cCZ0Vl0o8-H9D
Calling ProjRot to diagonalize Hessian and get freqs...

Harmonic frequencies [cm-1]:
    1352.800    1352.800    1352.800    1575.910    1575.910    3052.940
    3165.440    3165.440    3165.440

Harmonic ZPVE [kcal mol-1]: 28.247594766440912

Final ZPE: 0.04440319810612991 Eh
Debug:  bases energies test: InChI=1S/H2O/h1H2 H2O
Using /lcrc/project/PACC/AutoMech/data/save/SPC/H2O/XLYOFNOQVPJJNP/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/r1yMQskfHvGYF/c-QWtQ06e5lSW as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/H2O/XLYOFNOQVPJJNP/0/1/UHFFFAOYSA-N/u-un9NR/CONFS/rgPDyi92Iqx3M/cmc5-laRxhQDP for torsional profiles

Calculating energy for basis H2O...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/H2O/XLYOFNOQVPJJNP/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/r1yMQskfHvGYF/c-QWtQ06e5lSW/SP/0zlOGvR
  - Ene = 1.000 x -76.369837596599 Eh
Final electronic energy: -76.369837596599 Eh
- Calculating zero-point energy
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/H2O/XLYOFNOQVPJJNP/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/r1yMQskfHvGYF/c-QWtQ06e5lSW
Calling ProjRot to diagonalize Hessian and get freqs...

Harmonic frequencies [cm-1]:
    1651.430    3830.150    3937.850

Harmonic ZPVE [kcal mol-1]: 13.465751202504142

Final ZPE: 0.021167197534389733 Eh
hbasis list ({'InChI=1S/H2/h1H': -1.1640098183669148, 'InChI=1S/CH4/h1H4': -40.409952504287865, 'InChI=1S/H2O/h1H2': -76.3486703990646},)
[-1.1640098183669148, -40.409952504287865, -76.3486703990646]
Basis H contribution InChI=1S/H2/h1H -5.5 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 4.0 -0.025347824478645156 -40.409952504287865
Basis H contribution InChI=1S/H2O/h1H2 1.0 -0.09100420373931285 -76.3486703990646
ABS Energy  (hart):  -231.36404911802185
Hf0K Energy (hart):  0.12544383246525798

Determining energy transfer parameters...
  - No bath provided, using Argon bath as default

- Determining the masses...
  - Obtaining masses from geometries...

- Determining the Lennard-Jones model parameters...
- Estimating the parameters...
    - Series to use for estimation: frozenset({'1-alkyl', 'InChI=1S/Ar'})
    - Heavy atom count: 5

- Determining the energy-down transfer model parameters...
  - Estimating the parameters...
    - Series to use for estimation: frozenset({'1-alkyl', 'InChI=1S/Ar'})
    - Found effective rotor count: 2.00
    - Using following LJ parameters for collisional frequency and alpha calculation:
       eps=165.90 cm-1, sigma=4.60 Ang,
       mass1=71.05 amu, mass2=39.96 amu
edown_vec test: [267.6721487  588.79654867 979.47461383] 267.67214869983155
    - E_down prefactor (after dividing by empirical factor of 2.0): 267.67214869983155
    - E_down power: 0.68



Reading PES electronic structure data
Running Channel 4: C4H7ORvE4fmAA0 = C4H7O4H74fm0

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
rEN0cVUMw4ogR   c8f0ODjsIhFlo   0.00  *  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading filesystem info for C4H7ORvE4fmAA0
Using /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/hJUn9NU/CONFS/rEN0cVUMw4ogR/c8f0ODjsIhFlo as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/u-un9NU/CONFS/r6wopFXyayCds/cLnsEWjCyw7Qt for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/hJUn9NU/CONFS/rEN0cVUMw4ogR/c8f0ODjsIhFlo

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
rotor names (('D7',), ('D9',))
potential test:
names ('D7',)
grids ((5.659914076672178, 6.183512852270477, 6.707111627868775, 7.230710403467074, 7.754309179065373, 8.277907954663672, 8.80150673026197, 9.32510550586027, 9.848704281458568, 10.372303057056868, 10.895901832655166, 11.419500608253465),)
max norm diff of splines  0.024248692717860242 0.05
potential test:
names ('D9',)
grids ((3.723571069511098, 4.247169845109397, 4.770768620707695, 5.2943673963059945),)
max norm diff of splines  0.062229782303251026 0.1
Debug:  tors model in scale set 1dhrf
Debug:  tors model in scale set 1dhrf
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/hJUn9NU/CONFS/rEN0cVUMw4ogR/c8f0ODjsIhFlo
Path for PROJROT/FREQ/3428772 Job:
/lcrc/project/PACC/AutoMech/data/run/PROJROT/FREQ/C4H7O/3428772
running projrot the first time:
running projrot the second time:
Debug:  tors model in scale set 1dhrf
TAU FACTOR 45027.273554 	 2 	 1.322525 
Debug:  scale_coeff test: 1.3225251241915417 2 1.3225251241915417 1.3 0.8
value of sfactor is greater than sfacmax

Determining the symmetry factor...
Setting symmetry factors as racemic= True
reduced int sym 2.0

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/hJUn9NU/CONFS/rEN0cVUMw4ogR/c8f0ODjsIhFlo/SP/0zlOGvR
  - Ene = 1.000 x -231.461943106069 Eh
Final electronic energy: -231.461943106069 Eh
Process 3627221 prepping species: C4H7ORvE4fmAA0
[H][H]
C
O

Determining reference molecules for scheme: basic

Determining basis for species: C4H7ORvE4fmAA0
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Debug:  Energy already found for basis species:  InChI=1S/H2O/h1H2
Basis H contribution InChI=1S/H2/h1H -5.5 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 4.0 -0.025347824478645156 -40.409952504287865
Basis H contribution InChI=1S/H2O/h1H2 1.0 -0.09100420373931285 -76.3486703990646
ABS Energy  (hart):  -231.36404911802185
Hf0K Energy (hart):  0.12544383246525798

Determining energy transfer parameters...
  - No bath provided, using Argon bath as default

- Determining the masses...
  - Obtaining masses from geometries...

- Determining the Lennard-Jones model parameters...
- Estimating the parameters...
    - Series to use for estimation: frozenset({'1-alkyl', 'InChI=1S/Ar'})
    - Heavy atom count: 5

- Determining the energy-down transfer model parameters...
  - Estimating the parameters...
    - Series to use for estimation: frozenset({'1-alkyl', 'InChI=1S/Ar'})
    - Found effective rotor count: 2.00
    - Using following LJ parameters for collisional frequency and alpha calculation:
       eps=165.90 cm-1, sigma=4.60 Ang,
       mass1=71.05 amu, mass2=39.96 amu
edown_vec test: [267.6721487  588.79654867 979.47461383] 267.67214869983155
    - E_down prefactor (after dividing by empirical factor of 2.0): 267.67214869983155
    - E_down power: 0.68
Begin parallel job array on 2 processors

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
rKfEmOBtanXsi   cY4hZsJvgwtyp   0.00  *  
rKfEmOBtanXsi   cxeuERJebYplM   0.14     

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading filesystem info for C4H7O4H74fm0
Using /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/hJUn9NU/CONFS/rKfEmOBtanXsi/cY4hZsJvgwtyp as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/u-un9NU/CONFS/rBPyqEPcXezfu/cS6UQ_qtHitU9 for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/hJUn9NU/CONFS/rKfEmOBtanXsi/cY4hZsJvgwtyp

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
rotor names (('D6',), ('D9',))
potential test:
names ('D6',)
grids ((2.017769807523133, 2.541368583121432, 3.0649673587197306, 3.5885661343180297, 4.112164909916329, 4.635763685514627, 5.159362461112926, 5.682961236711225, 6.206560012309524, 6.730158787907823, 7.253757563506121, 7.77735633910442),)
max norm diff of splines  0.06225998209434073 0.05
Removing bad angle at 415.60969399999993 degrees
potential test:
names ('D9',)
grids ((3.062114792590272, 3.5857135681885706, 4.109312343786869, 4.632911119385168),)
max norm diff of splines  0.06144846645806796 0.1
Debug:  tors model in scale set 1dhrf
Debug:  tors model in scale set 1dhrf
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/hJUn9NU/CONFS/rKfEmOBtanXsi/cY4hZsJvgwtyp
Path for PROJROT/FREQ/3152703 Job:
/lcrc/project/PACC/AutoMech/data/run/PROJROT/FREQ/C4H7O/3152703
running projrot the first time:
running projrot the second time:
Debug:  tors model in scale set 1dhrf
TAU FACTOR 24595.912123 	 2 	 0.977878 
Debug:  scale_coeff test: 0.9778780167211941 2 0.9778780167211941 1.3 0.8

Determining the symmetry factor...
Setting symmetry factors as racemic= True
reduced int sym 1.0

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/hJUn9NU/CONFS/rKfEmOBtanXsi/cY4hZsJvgwtyp/SP/0zlOGvR
  - Ene = 1.000 x -231.461611024044 Eh
Final electronic energy: -231.461611024044 Eh
Process 3627494 prepping species: C4H7O4H74fm0
[H][H]
C
O

Determining reference molecules for scheme: basic

Determining basis for species: C4H7O4H74fm0
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Debug:  Energy already found for basis species:  InChI=1S/H2O/h1H2
Basis H contribution InChI=1S/H2/h1H -5.5 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 4.0 -0.025347824478645156 -40.409952504287865
Basis H contribution InChI=1S/H2O/h1H2 1.0 -0.09100420373931285 -76.3486703990646
ABS Energy  (hart):  -231.36294634158475
Hf0K Energy (hart):  0.13005784907811732

Determining energy transfer parameters...
  - No bath provided, using Argon bath as default

- Determining the masses...
  - Obtaining masses from geometries...

- Determining the Lennard-Jones model parameters...
- Estimating the parameters...
    - Series to use for estimation: frozenset({'1-alkyl', 'InChI=1S/Ar'})
    - Heavy atom count: 5

- Determining the energy-down transfer model parameters...
  - Estimating the parameters...
    - Series to use for estimation: frozenset({'1-alkyl', 'InChI=1S/Ar'})
    - Found effective rotor count: 3.67
    - Using following LJ parameters for collisional frequency and alpha calculation:
       eps=165.90 cm-1, sigma=4.60 Ang,
       mass1=71.05 amu, mass2=39.96 amu
edown_vec test: [ 402.81471776  803.84812758 1289.83282782] 402.81471776444926
    - E_down prefactor (after dividing by empirical factor of 2.0): 402.81471776444926
    - E_down power: 0.60

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
rn6iGq4rwAZyj   c9sL9JB2Hznoc   0.00  *  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading Reading filesystem info for ts_1_4_0
Obtaining a ZRXN object from conformer any TS, shouldn't matter
-----
Using /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/2/hJUn9NU/TS/00/CONFS/rn6iGq4rwAZyj/c9sL9JB2Hznoc as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/2/u-un9NU/TS/00/CONFS/rvtFmnq1qX5Ou/cA5yBN5nocqBZ for torsional profiles
-----
Using /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/2/hJUn9NU/TS/00/CONFS/rn6iGq4rwAZyj/c9sL9JB2Hznoc as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/2/u-un9NU/TS/00/CONFS/rvtFmnq1qX5Ou/cA5yBN5nocqBZ for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/2/hJUn9NU/TS/00/CONFS/rn6iGq4rwAZyj/c9sL9JB2Hznoc

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
rotor names (('D7',), ('D9',))
potential test:
names ('D7',)
grids ((6.265130155320385, 6.788728930918684, 7.3123277065169825, 7.835926482115282, 8.35952525771358, 8.88312403331188, 9.406722808910178, 9.930321584508476, 10.453920360106775, 10.977519135705075, 11.501117911303373, 12.024716686901673),)
potential test:
names ('D9',)
grids ((3.464666973501497, 3.9882657490997957, 4.511864524698095, 5.035463300296394),)
Debug:  tors model in scale set 1dhrf
Debug:  tors model in scale set 1dhrf
WARNING: empty potential will crash MESS so using rigid model instead
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/2/hJUn9NU/TS/00/CONFS/rn6iGq4rwAZyj/c9sL9JB2Hznoc
Calling ProjRot to diagonalize Hessian and get freqs...

Harmonic frequencies [cm-1]:
     209.790     228.800     282.710     398.570     496.170     525.440
     839.160     846.090     897.140     973.230    1020.040    1108.740
    1134.500    1224.320    1251.520    1284.730    1365.180    1411.970
    1447.600    1496.440    1508.420    1529.270    3028.130    3054.350
    3127.650    3138.630    3175.450    3222.500    3277.130

Harmonic ZPVE [kcal mol-1]: 62.19161845417857


Determining the symmetry factor...
Setting symmetry factors as racemic= True
reduced int sym 1.0

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/2/hJUn9NU/TS/00/CONFS/rn6iGq4rwAZyj/c9sL9JB2Hznoc/SP/0zlOGvR
  - Ene = 1.000 x -231.453486275742 Eh
Final electronic energy: -231.453486275742 Eh
Process 3628789 prepping species: ts_1_4_0
[H][H]
C
O

Determining reference molecules for scheme: basic

Determining basis for species: ts_1_4_0
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Debug:  Energy already found for basis species:  InChI=1S/H2O/h1H2
Basis H contribution InChI=1S/H2/h1H -5.5 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 4.0 -0.025347824478645156 -40.409952504287865
Basis H contribution InChI=1S/H2O/h1H2 1.0 -0.09100420373931285 -76.3486703990646
ABS Energy  (hart):  -231.3557255007948
Hf0K Energy (hart):  0.16026984694328997


Getting energies for the reaction channel...
reac ene 0.02998179552228919 0.02998179552228919
prod ene 0.031084571959397067 0.031084571959397067
Debug:  REAC HoF (0 K) spc lvl kcal/mol:  18.813860731097417
Debug:  REAC HoF (0 K) ts lvl kcal/mol:  18.813860731097417
Debug:  PROD HoF (0 K) spc lvl kcal/mol:  19.50586339284125
Debug:  PROD HoF (0 K) ts lvl kcal/mol:  19.50586339284125
Debug:  TS HoF (0 K) ts lvl kcal/mol:  24.037009397177425
Debug:  TS HoF (0 K) approx spc lvl kcal/mol:  24.037009397177425
Setting 289.5 as max hoten val for C4H7ORvE4fmAA0 




Reading PES electronic structure data
Running Channel 5: C4H7ORvE4fmAA0 = C4H7O-kSV4fm

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
rEN0cVUMw4ogR   c8f0ODjsIhFlo   0.00  *  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading filesystem info for C4H7ORvE4fmAA0
Using /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/hJUn9NU/CONFS/rEN0cVUMw4ogR/c8f0ODjsIhFlo as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/u-un9NU/CONFS/r6wopFXyayCds/cLnsEWjCyw7Qt for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/hJUn9NU/CONFS/rEN0cVUMw4ogR/c8f0ODjsIhFlo

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
rotor names (('D7',), ('D9',))
potential test:
names ('D7',)
grids ((5.659914076672178, 6.183512852270477, 6.707111627868775, 7.230710403467074, 7.754309179065373, 8.277907954663672, 8.80150673026197, 9.32510550586027, 9.848704281458568, 10.372303057056868, 10.895901832655166, 11.419500608253465),)
max norm diff of splines  0.024248692717860242 0.05
potential test:
names ('D9',)
grids ((3.723571069511098, 4.247169845109397, 4.770768620707695, 5.2943673963059945),)
max norm diff of splines  0.062229782303251026 0.1
Debug:  tors model in scale set 1dhrf
Debug:  tors model in scale set 1dhrf
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/hJUn9NU/CONFS/rEN0cVUMw4ogR/c8f0ODjsIhFlo
Path for PROJROT/FREQ/5561995 Job:
/lcrc/project/PACC/AutoMech/data/run/PROJROT/FREQ/C4H7O/5561995
running projrot the first time:
running projrot the second time:
Debug:  tors model in scale set 1dhrf
TAU FACTOR 45027.273554 	 2 	 1.322525 
Debug:  scale_coeff test: 1.3225251241915417 2 1.3225251241915417 1.3 0.8
value of sfactor is greater than sfacmax

Determining the symmetry factor...
Setting symmetry factors as racemic= True
reduced int sym 2.0

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/hJUn9NU/CONFS/rEN0cVUMw4ogR/c8f0ODjsIhFlo/SP/0zlOGvR
  - Ene = 1.000 x -231.461943106069 Eh
Final electronic energy: -231.461943106069 Eh
Process 3628965 prepping species: C4H7ORvE4fmAA0
[H][H]
C
O

Determining reference molecules for scheme: basic

Determining basis for species: C4H7ORvE4fmAA0
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Debug:  Energy already found for basis species:  InChI=1S/H2O/h1H2
Basis H contribution InChI=1S/H2/h1H -5.5 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 4.0 -0.025347824478645156 -40.409952504287865
Basis H contribution InChI=1S/H2O/h1H2 1.0 -0.09100420373931285 -76.3486703990646
ABS Energy  (hart):  -231.36404911802185
Hf0K Energy (hart):  0.12544383246525798

Determining energy transfer parameters...
  - No bath provided, using Argon bath as default

- Determining the masses...
  - Obtaining masses from geometries...

- Determining the Lennard-Jones model parameters...
- Estimating the parameters...
    - Series to use for estimation: frozenset({'1-alkyl', 'InChI=1S/Ar'})
    - Heavy atom count: 5

- Determining the energy-down transfer model parameters...
  - Estimating the parameters...
    - Series to use for estimation: frozenset({'1-alkyl', 'InChI=1S/Ar'})
    - Found effective rotor count: 2.00
    - Using following LJ parameters for collisional frequency and alpha calculation:
       eps=165.90 cm-1, sigma=4.60 Ang,
       mass1=71.05 amu, mass2=39.96 amu
edown_vec test: [267.6721487  588.79654867 979.47461383] 267.67214869983155
    - E_down prefactor (after dividing by empirical factor of 2.0): 267.67214869983155
    - E_down power: 0.68
Begin parallel job array on 2 processors

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
rPf7Y7grdiEFT   crdv-3qzacBnq   0.00  *  
rPf7Y7grdiEFT   chCboitlm-bVQ   0.65     

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading filesystem info for C4H7O-kSV4fm
Using /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/QVEJVAOFVGTBQB/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/rPf7Y7grdiEFT/crdv-3qzacBnq as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/QVEJVAOFVGTBQB/0/2/UHFFFAOYSA-N/u-un9NU/CONFS/rvtbNWkLVd4vr/cInx8hxaVqKxb for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/QVEJVAOFVGTBQB/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/rPf7Y7grdiEFT/crdv-3qzacBnq

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
rotor names (('D6',), ('D7',), ('D9',))
potential test:
names ('D6',)
grids ((3.1201899078653894, 3.643788683463688, 4.167387459061987, 4.690986234660286, 5.214585010258585, 5.738183785856883, 6.261782561455183, 6.785381337053481, 7.3089801126517795, 7.8325788882500795, 8.356177663848378, 8.879776439446676),)
max norm diff of splines  0.02064323906207646 0.05
potential test:
names ('D7',)
grids ((0.32325309398698554, 0.8468518695852844, 1.3704506451835832, 1.894049420781882, 2.417648196380181, 2.9412469719784795, 3.4648457475767787, 3.9884445231750774, 4.512043298773376, 5.035642074371675, 5.5592408499699735, 6.082839625568273),)
max norm diff of splines  0.09160190160292288 0.05
Removing bad angle at 258.521038 degrees
potential test:
names ('D9',)
grids ((3.000860298283258, 3.5244590738815567, 4.048057849479855, 4.5716566250781545),)
max norm diff of splines  0.06252005552394407 0.1
Debug:  tors model in scale set 1dhrf
Debug:  tors model in scale set 1dhrf
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/QVEJVAOFVGTBQB/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/rPf7Y7grdiEFT/crdv-3qzacBnq
Path for PROJROT/FREQ/3429363 Job:
/lcrc/project/PACC/AutoMech/data/run/PROJROT/FREQ/C4H7O/3429363
running projrot the first time:
running projrot the second time:
Debug:  tors model in scale set 1dhrf
TAU FACTOR 1569036.394191 	 3 	 0.806278 
Debug:  scale_coeff test: 0.8062780433230428 3 0.8662765444181255 1.3 0.8

Determining the symmetry factor...
Setting symmetry factors as racemic= True
reduced int sym 1.0

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/QVEJVAOFVGTBQB/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/rPf7Y7grdiEFT/crdv-3qzacBnq/SP/0zlOGvR
  - Ene = 1.000 x -231.463893723195 Eh
Final electronic energy: -231.463893723195 Eh
Process 3629263 prepping species: C4H7O-kSV4fm
[H][H]
C
O

Determining reference molecules for scheme: basic

Determining basis for species: C4H7O-kSV4fm
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Debug:  Energy already found for basis species:  InChI=1S/H2O/h1H2
Basis H contribution InChI=1S/H2/h1H -5.5 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 4.0 -0.025347824478645156 -40.409952504287865
Basis H contribution InChI=1S/H2O/h1H2 1.0 -0.09100420373931285 -76.3486703990646
ABS Energy  (hart):  -231.36590636462998
Hf0K Energy (hart):  0.11767311265686192

Determining energy transfer parameters...
  - No bath provided, using Argon bath as default

- Determining the masses...
  - Obtaining masses from geometries...

- Determining the Lennard-Jones model parameters...
- Estimating the parameters...
    - Series to use for estimation: frozenset({'1-alkyl', 'InChI=1S/Ar'})
    - Heavy atom count: 5

- Determining the energy-down transfer model parameters...
  - Estimating the parameters...
    - Series to use for estimation: frozenset({'1-alkyl', 'InChI=1S/Ar'})
    - Found effective rotor count: 3.67
    - Using following LJ parameters for collisional frequency and alpha calculation:
       eps=165.90 cm-1, sigma=4.60 Ang,
       mass1=71.05 amu, mass2=39.96 amu
edown_vec test: [ 402.81471776  803.84812758 1289.83282782] 402.81471776444926
    - E_down prefactor (after dividing by empirical factor of 2.0): 402.81471776444926
    - E_down power: 0.60

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
rmgHSpo_5UqyO   cB1hWEPmLFP7V   0.00  *  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading Reading filesystem info for ts_1_5_0
Obtaining a ZRXN object from conformer any TS, shouldn't matter
-----
Using /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/C4H7O/QVEJVAOFVGTBQB/0/2/UHFFFAOYSA-N/2/hJUn9NU/TS/00/CONFS/rmgHSpo_5UqyO/cB1hWEPmLFP7V as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/C4H7O/QVEJVAOFVGTBQB/0/2/UHFFFAOYSA-N/2/u-un9NU/TS/00/CONFS/rSVPUzPUjJOEz/cT1PM7stunjCi for torsional profiles
-----
Using /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/C4H7O/QVEJVAOFVGTBQB/0/2/UHFFFAOYSA-N/2/hJUn9NU/TS/00/CONFS/rmgHSpo_5UqyO/cB1hWEPmLFP7V as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/C4H7O/QVEJVAOFVGTBQB/0/2/UHFFFAOYSA-N/2/u-un9NU/TS/00/CONFS/rSVPUzPUjJOEz/cT1PM7stunjCi for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/C4H7O/QVEJVAOFVGTBQB/0/2/UHFFFAOYSA-N/2/hJUn9NU/TS/00/CONFS/rmgHSpo_5UqyO/cB1hWEPmLFP7V

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
rotor names (('D7',), ('D9',))
potential test:
names ('D7',)
grids ((5.38326493890487, 5.906863714503169, 6.430462490101467, 6.9540612656997665, 7.477660041298066, 8.001258816896364, 8.524857592494662, 9.048456368092962, 9.57205514369126, 10.09565391928956, 10.619252694887859, 11.142851470486157),)
potential test:
names ('D9',)
grids ((4.093968072228451, 4.61756684782675, 5.1411656234250485, 5.664764399023348),)
Debug:  tors model in scale set 1dhrf
Debug:  tors model in scale set 1dhrf
WARNING: empty potential will crash MESS so using rigid model instead
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/C4H7O/QVEJVAOFVGTBQB/0/2/UHFFFAOYSA-N/2/hJUn9NU/TS/00/CONFS/rmgHSpo_5UqyO/cB1hWEPmLFP7V
Calling ProjRot to diagonalize Hessian and get freqs...

Harmonic frequencies [cm-1]:
     165.940     184.020     230.290     415.110     508.290     573.960
     710.770     788.030     897.860     903.110     954.940    1039.290
    1117.480    1131.940    1198.710    1303.750    1372.640    1413.710
    1422.920    1481.780    1494.520    1542.840    3010.710    3085.120
    3132.920    3168.340    3178.820    3184.960    3285.040

Harmonic ZPVE [kcal mol-1]: 61.32549810257035


Determining the symmetry factor...
Setting symmetry factors as racemic= True
reduced int sym 1.0

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/C4H7O/QVEJVAOFVGTBQB/0/2/UHFFFAOYSA-N/2/hJUn9NU/TS/00/CONFS/rmgHSpo_5UqyO/cB1hWEPmLFP7V/SP/0zlOGvR
  - Ene = 1.000 x -231.440014716694 Eh
Final electronic energy: -231.440014716694 Eh
Process 3630452 prepping species: ts_1_5_0
[H][H]
C
O

Determining reference molecules for scheme: basic

Determining basis for species: ts_1_5_0
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Debug:  Energy already found for basis species:  InChI=1S/H2O/h1H2
Basis H contribution InChI=1S/H2/h1H -5.5 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 4.0 -0.025347824478645156 -40.409952504287865
Basis H contribution InChI=1S/H2O/h1H2 1.0 -0.09100420373931285 -76.3486703990646
ABS Energy  (hart):  -231.34361542097625
Hf0K Energy (hart):  0.2109384209040653


Getting energies for the reaction channel...
reac ene 0.02998179552228919 0.02998179552228919
prod ene 0.028124548914163938 0.028124548914163938
Debug:  REAC HoF (0 K) spc lvl kcal/mol:  18.813860731097417
Debug:  REAC HoF (0 K) ts lvl kcal/mol:  18.813860731097417
Debug:  PROD HoF (0 K) spc lvl kcal/mol:  17.648420889357624
Debug:  PROD HoF (0 K) ts lvl kcal/mol:  17.648420889357624
Debug:  TS HoF (0 K) ts lvl kcal/mol:  31.636199211514036
Debug:  TS HoF (0 K) approx spc lvl kcal/mol:  31.636199211514036
Setting 289.5 as max hoten val for C4H7ORvE4fmAA0 




Reading PES electronic structure data
Running Channel 6: C4H7ORvE4fmAA0 = C4H6O-RvErx50+H-TcYTcY

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
rEN0cVUMw4ogR   c8f0ODjsIhFlo   0.00  *  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading filesystem info for C4H7ORvE4fmAA0
Using /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/hJUn9NU/CONFS/rEN0cVUMw4ogR/c8f0ODjsIhFlo as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/u-un9NU/CONFS/r6wopFXyayCds/cLnsEWjCyw7Qt for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/hJUn9NU/CONFS/rEN0cVUMw4ogR/c8f0ODjsIhFlo

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
rotor names (('D7',), ('D9',))
potential test:
names ('D7',)
grids ((5.659914076672178, 6.183512852270477, 6.707111627868775, 7.230710403467074, 7.754309179065373, 8.277907954663672, 8.80150673026197, 9.32510550586027, 9.848704281458568, 10.372303057056868, 10.895901832655166, 11.419500608253465),)
max norm diff of splines  0.024248692717860242 0.05
potential test:
names ('D9',)
grids ((3.723571069511098, 4.247169845109397, 4.770768620707695, 5.2943673963059945),)
max norm diff of splines  0.062229782303251026 0.1
Debug:  tors model in scale set 1dhrf
Debug:  tors model in scale set 1dhrf
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/hJUn9NU/CONFS/rEN0cVUMw4ogR/c8f0ODjsIhFlo
Path for PROJROT/FREQ/8983640 Job:
/lcrc/project/PACC/AutoMech/data/run/PROJROT/FREQ/C4H7O/8983640
running projrot the first time:
running projrot the second time:
Debug:  tors model in scale set 1dhrf
TAU FACTOR 45027.273554 	 2 	 1.322525 
Debug:  scale_coeff test: 1.3225251241915417 2 1.3225251241915417 1.3 0.8
value of sfactor is greater than sfacmax

Determining the symmetry factor...
Setting symmetry factors as racemic= True
reduced int sym 2.0

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/hJUn9NU/CONFS/rEN0cVUMw4ogR/c8f0ODjsIhFlo/SP/0zlOGvR
  - Ene = 1.000 x -231.461943106069 Eh
Final electronic energy: -231.461943106069 Eh
Process 3630635 prepping species: C4H7ORvE4fmAA0
[H][H]
C
O

Determining reference molecules for scheme: basic

Determining basis for species: C4H7ORvE4fmAA0
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Debug:  Energy already found for basis species:  InChI=1S/H2O/h1H2
Basis H contribution InChI=1S/H2/h1H -5.5 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 4.0 -0.025347824478645156 -40.409952504287865
Basis H contribution InChI=1S/H2O/h1H2 1.0 -0.09100420373931285 -76.3486703990646
ABS Energy  (hart):  -231.36404911802185
Hf0K Energy (hart):  0.12544383246525798

Determining energy transfer parameters...
  - No bath provided, using Argon bath as default

- Determining the masses...
  - Obtaining masses from geometries...

- Determining the Lennard-Jones model parameters...
- Estimating the parameters...
    - Series to use for estimation: frozenset({'1-alkyl', 'InChI=1S/Ar'})
    - Heavy atom count: 5

- Determining the energy-down transfer model parameters...
  - Estimating the parameters...
    - Series to use for estimation: frozenset({'1-alkyl', 'InChI=1S/Ar'})
    - Found effective rotor count: 2.00
    - Using following LJ parameters for collisional frequency and alpha calculation:
       eps=165.90 cm-1, sigma=4.60 Ang,
       mass1=71.05 amu, mass2=39.96 amu
edown_vec test: [267.6721487  588.79654867 979.47461383] 267.67214869983155
    - E_down prefactor (after dividing by empirical factor of 2.0): 267.67214869983155
    - E_down power: 0.68

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
rv4b-hgrvX58W   c0FUzAXPwzc2c   0.00  *  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading filesystem info for C4H6O-RvErx50
Using /lcrc/project/PACC/AutoMech/data/save/SPC/C4H6O/DASBTGKSWSOVLW/0/1/BYPYZUCNSA-N/hJUn9NR/CONFS/rv4b-hgrvX58W/c0FUzAXPwzc2c as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/C4H6O/DASBTGKSWSOVLW/0/1/BYPYZUCNSA-N/u-un9NR/CONFS/rYcT7kL119cWO/cWTRL5niiBbrt for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H6O/DASBTGKSWSOVLW/0/1/BYPYZUCNSA-N/hJUn9NR/CONFS/rv4b-hgrvX58W/c0FUzAXPwzc2c

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
rotor names (('D8',),)
potential test:
names ('D8',)
grids ((5.916474439842445, 6.440073215440744, 6.9636719910390426, 7.487270766637342),)
max norm diff of splines  0.06480177853833795 0.1
Debug:  tors model in scale set 1dhrf
Debug:  tors model in scale set 1dhrf
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H6O/DASBTGKSWSOVLW/0/1/BYPYZUCNSA-N/hJUn9NR/CONFS/rv4b-hgrvX58W/c0FUzAXPwzc2c
Path for PROJROT/FREQ/7291470 Job:
/lcrc/project/PACC/AutoMech/data/run/PROJROT/FREQ/C4H6O/7291470
running projrot the first time:
running projrot the second time:
Debug:  tors model in scale set 1dhrf
TAU FACTOR 193.031891 	 1 	 1.061105 
Debug:  scale_coeff test: 1.0611045243559567 1 1.1259428116086811 1.3 0.8

Determining the symmetry factor...
Setting symmetry factors as racemic= True
reduced int sym 1.0

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H6O/DASBTGKSWSOVLW/0/1/BYPYZUCNSA-N/hJUn9NR/CONFS/rv4b-hgrvX58W/c0FUzAXPwzc2c/SP/0zlOGvR
  - Ene = 1.000 x -230.887911050975 Eh
Final electronic energy: -230.887911050975 Eh
Process 3630911 prepping species: C4H6O-RvErx50
[H][H]
C
O

Determining reference molecules for scheme: basic

Determining basis for species: C4H6O-RvErx50
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Debug:  Energy already found for basis species:  InChI=1S/H2O/h1H2
Basis H contribution InChI=1S/H2/h1H -6.0 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 4.0 -0.025347824478645156 -40.409952504287865
Basis H contribution InChI=1S/H2O/h1H2 1.0 -0.09100420373931285 -76.3486703990646
ABS Energy  (hart):  -230.79925195770977
Hf0K Energy (hart):  0.053446611187381796

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
rpJYtZA39dboM   cHN4HXRAotrnH   0.00  *  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading filesystem info for H-TcYTcY
Using /lcrc/project/PACC/AutoMech/data/save/SPC/H/YZCKVEUIGOORGS/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/rpJYtZA39dboM/cHN4HXRAotrnH as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/H/YZCKVEUIGOORGS/0/2/UHFFFAOYSA-N/u-un9NU/CONFS/rq4rArSxXK-AV/cJod5TW7liMwM for torsional profiles

Obtaining the geometry...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/SPC/H/YZCKVEUIGOORGS/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/rpJYtZA39dboM/cHN4HXRAotrnH

Obtaining the electronic energy...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/H/YZCKVEUIGOORGS/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/rpJYtZA39dboM/cHN4HXRAotrnH/SP/0zlOGvR
  - Ene = 1.000 x -0.499946213253 Eh
Final electronic energy: -0.499946213253 Eh
Process 3630986 prepping species: H-TcYTcY
[H][H]

Determining reference molecules for scheme: basic

Determining basis for species: H-TcYTcY
Debug:  Energy will be determined for basis species:  InChI=1S/H2/h1H
Process 3630995 reading energy for species: ['InChI=1S/H2/h1H']
Debug:  bases energies test: InChI=1S/H2/h1H REF_1
Using /lcrc/project/PACC/AutoMech/data/save/SPC/H2/UFHFLCQGNIYNRP/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/rltA3tJnYkadM/cfHm_J4NvVMIy as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/H2/UFHFLCQGNIYNRP/0/1/UHFFFAOYSA-N/u-un9NR/CONFS/rqPrrHTfPZAs4/crIudoXA5mZil for torsional profiles

Calculating energy for basis REF_1...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/H2/UFHFLCQGNIYNRP/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/rltA3tJnYkadM/cfHm_J4NvVMIy/SP/0zlOGvR
  - Ene = 1.000 x -1.174043609727 Eh
Final electronic energy: -1.174043609727 Eh
- Calculating zero-point energy
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/H2/UFHFLCQGNIYNRP/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/rltA3tJnYkadM/cfHm_J4NvVMIy
Calling ProjRot to diagonalize Hessian and get freqs...

Harmonic frequencies [cm-1]:
    4465.050

Harmonic ZPVE [kcal mol-1]: 6.383109424534299

Final ZPE: 0.010033791360085153 Eh
hbasis list ({'InChI=1S/H2/h1H': -1.1640098183669148},)
[-1.1640098183669148]
Basis H contribution InChI=1S/H2/h1H 0.5 0.0 -1.1640098183669148
ABS Energy  (hart):  -0.499946213253
Hf0K Energy (hart):  0.34333358377303375

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
rDxiJ0g4ioSkV   cHy27vVeqR_pJ   0.00  *  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading Reading filesystem info for ts_1_6_0
Obtaining a ZRXN object from conformer any TS, shouldn't matter
-----
Using /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/C4H6O.H/HWJDMYDPTKTFCA/0_0/1_2/WCCKRBBISA-N/2/hJUn9NU/TS/00/CONFS/rDxiJ0g4ioSkV/cHy27vVeqR_pJ as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/C4H6O.H/HWJDMYDPTKTFCA/0_0/1_2/WCCKRBBISA-N/2/u-un9NU/TS/00/CONFS/rBAZK0SjX91FZ/caSZUwwGjFw3p for torsional profiles
-----
Using /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/C4H6O.H/HWJDMYDPTKTFCA/0_0/1_2/WCCKRBBISA-N/2/hJUn9NU/TS/00/CONFS/rDxiJ0g4ioSkV/cHy27vVeqR_pJ as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/C4H6O.H/HWJDMYDPTKTFCA/0_0/1_2/WCCKRBBISA-N/2/u-un9NU/TS/00/CONFS/rBAZK0SjX91FZ/caSZUwwGjFw3p for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/C4H6O.H/HWJDMYDPTKTFCA/0_0/1_2/WCCKRBBISA-N/2/hJUn9NU/TS/00/CONFS/rDxiJ0g4ioSkV/cHy27vVeqR_pJ

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
rotor names (('D7',), ('D9',))
potential test:
names ('D7',)
grids ((0.670769912314829, 1.1943686879131277, 1.7179674635114266, 2.2415662391097255, 2.7651650147080242, 3.288763790306323, 3.812362565904622, 4.335961341502921, 4.8595601171012195, 5.383158892699519, 5.906757668297817, 6.430356443896116),)
potential test:
names ('D9',)
grids ((3.75070879262463, 4.274307568222929, 4.797906343821228, 5.321505119419527),)
Debug:  tors model in scale set 1dhrf
Debug:  tors model in scale set 1dhrf
WARNING: empty potential will crash MESS so using rigid model instead
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/C4H6O.H/HWJDMYDPTKTFCA/0_0/1_2/WCCKRBBISA-N/2/hJUn9NU/TS/00/CONFS/rDxiJ0g4ioSkV/cHy27vVeqR_pJ
Calling ProjRot to diagonalize Hessian and get freqs...

Harmonic frequencies [cm-1]:
     182.170     229.020     307.610     401.310     424.440     552.110
     629.820     667.120     692.530     810.780     834.850     949.860
    1031.370    1091.250    1131.690    1149.910    1237.850    1383.040
    1423.570    1462.810    1494.750    1500.060    1772.570    3059.130
    3124.700    3141.510    3163.280    3186.230    3288.770

Harmonic ZPVE [kcal mol-1]: 57.64620924221628


Determining the symmetry factor...
Setting symmetry factors as racemic= True
reduced int sym 1.0

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/NKJCNSIBJYISAQ/0/2/IMJSIDKUSA-N/C4H6O.H/HWJDMYDPTKTFCA/0_0/1_2/WCCKRBBISA-N/2/hJUn9NU/TS/00/CONFS/rDxiJ0g4ioSkV/cHy27vVeqR_pJ/SP/0zlOGvR
  - Ene = 1.000 x -231.379832673715 Eh
Final electronic energy: -231.379832673715 Eh
Process 3632640 prepping species: ts_1_6_0
[H][H]
C
O

Determining reference molecules for scheme: basic

Determining basis for species: ts_1_6_0
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Debug:  Energy already found for basis species:  InChI=1S/H2O/h1H2
Basis H contribution InChI=1S/H2/h1H -5.5 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 4.0 -0.025347824478645156 -40.409952504287865
Basis H contribution InChI=1S/H2O/h1H2 1.0 -0.09100420373931285 -76.3486703990646
ABS Energy  (hart):  -231.28921695686498
Hf0K Energy (hart):  0.4385415947456312


Getting energies for the reaction channel...
reac ene 0.02998179552228919 0.02998179552228919
prod ene 0.01277404665090387 0.01277404665090387
prod ene 0.08205869593045739 0.08205869593045739
Debug:  REAC HoF (0 K) spc lvl kcal/mol:  18.813860731097417
Debug:  REAC HoF (0 K) ts lvl kcal/mol:  18.813860731097417
Debug:  PROD HoF (0 K) spc lvl kcal/mol:  59.508444394110676
Debug:  PROD HoF (0 K) ts lvl kcal/mol:  59.508444394110676
Debug:  TS HoF (0 K) ts lvl kcal/mol:  65.77175080028516
Debug:  TS HoF (0 K) approx spc lvl kcal/mol:  65.77175080028516
Setting 289.5 as max hoten val for C4H7ORvE4fmAA0 




Reading PES electronic structure data
Running Channel 7: C4H7O4H74fm0 = C3H4OALAD-Wv9FbZ+CH3
Begin parallel job array on 2 processors

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
rKfEmOBtanXsi   cY4hZsJvgwtyp   0.00  *  
rKfEmOBtanXsi   cxeuERJebYplM   0.14     

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading filesystem info for C4H7O4H74fm0
Using /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/hJUn9NU/CONFS/rKfEmOBtanXsi/cY4hZsJvgwtyp as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/u-un9NU/CONFS/rBPyqEPcXezfu/cS6UQ_qtHitU9 for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/hJUn9NU/CONFS/rKfEmOBtanXsi/cY4hZsJvgwtyp

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
rotor names (('D6',), ('D9',))
potential test:
names ('D6',)
grids ((2.017769807523133, 2.541368583121432, 3.0649673587197306, 3.5885661343180297, 4.112164909916329, 4.635763685514627, 5.159362461112926, 5.682961236711225, 6.206560012309524, 6.730158787907823, 7.253757563506121, 7.77735633910442),)
max norm diff of splines  0.06225998209434073 0.05
Removing bad angle at 415.60969399999993 degrees
potential test:
names ('D9',)
grids ((3.062114792590272, 3.5857135681885706, 4.109312343786869, 4.632911119385168),)
max norm diff of splines  0.06144846645806796 0.1
Debug:  tors model in scale set 1dhrf
Debug:  tors model in scale set 1dhrf
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/hJUn9NU/CONFS/rKfEmOBtanXsi/cY4hZsJvgwtyp
Path for PROJROT/FREQ/2680436 Job:
/lcrc/project/PACC/AutoMech/data/run/PROJROT/FREQ/C4H7O/2680436
running projrot the first time:
running projrot the second time:
Debug:  tors model in scale set 1dhrf
TAU FACTOR 24595.912123 	 2 	 0.977878 
Debug:  scale_coeff test: 0.9778780167211941 2 0.9778780167211941 1.3 0.8

Determining the symmetry factor...
Setting symmetry factors as racemic= True
reduced int sym 1.0

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/hJUn9NU/CONFS/rKfEmOBtanXsi/cY4hZsJvgwtyp/SP/0zlOGvR
  - Ene = 1.000 x -231.461611024044 Eh
Final electronic energy: -231.461611024044 Eh
Process 3632864 prepping species: C4H7O4H74fm0
[H][H]
C
O

Determining reference molecules for scheme: basic

Determining basis for species: C4H7O4H74fm0
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Debug:  Energy already found for basis species:  InChI=1S/H2O/h1H2
Basis H contribution InChI=1S/H2/h1H -5.5 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 4.0 -0.025347824478645156 -40.409952504287865
Basis H contribution InChI=1S/H2O/h1H2 1.0 -0.09100420373931285 -76.3486703990646
ABS Energy  (hart):  -231.36294634158475
Hf0K Energy (hart):  0.13005784907811732

Determining energy transfer parameters...
  - No bath provided, using Argon bath as default

- Determining the masses...
  - Obtaining masses from geometries...

- Determining the Lennard-Jones model parameters...
- Estimating the parameters...
    - Series to use for estimation: frozenset({'1-alkyl', 'InChI=1S/Ar'})
    - Heavy atom count: 5

- Determining the energy-down transfer model parameters...
  - Estimating the parameters...
    - Series to use for estimation: frozenset({'1-alkyl', 'InChI=1S/Ar'})
    - Found effective rotor count: 3.67
    - Using following LJ parameters for collisional frequency and alpha calculation:
       eps=165.90 cm-1, sigma=4.60 Ang,
       mass1=71.05 amu, mass2=39.96 amu
edown_vec test: [ 402.81471776  803.84812758 1289.83282782] 402.81471776444926
    - E_down prefactor (after dividing by empirical factor of 2.0): 402.81471776444926
    - E_down power: 0.60
Begin parallel job array on 2 processors

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
rzwl8KQbVUdnV   c1YrbcKpMrQOw   0.00  *  
rzwl8KQbVUdnV   cJ7lbihlRoq5j   1.27     

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading filesystem info for C3H4OALAD-Wv9FbZ
Using /lcrc/project/PACC/AutoMech/data/save/SPC/C3H4O/HGINCPLSRVDWNT/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/rzwl8KQbVUdnV/c1YrbcKpMrQOw as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/C3H4O/HGINCPLSRVDWNT/0/1/UHFFFAOYSA-N/u-un9NR/CONFS/rnK0IaFasjzQ3/cLAHTMlKDTQWT for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/SPC/C3H4O/HGINCPLSRVDWNT/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/rzwl8KQbVUdnV/c1YrbcKpMrQOw

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
rotor names (('D6',),)
potential test:
names ('D6',)
grids ((3.141595166863916, 3.665193942462215, 4.188792718060514, 4.712391493658813, 5.235990269257112, 5.75958904485541, 6.283187820453709, 6.806786596052008, 7.330385371650307, 7.853984147248606, 8.377582922846905, 8.901181698445203),)
max norm diff of splines  0.037947877650830415 0.05
Debug:  tors model in scale set 1dhrf
Debug:  tors model in scale set 1dhrf
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/C3H4O/HGINCPLSRVDWNT/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/rzwl8KQbVUdnV/c1YrbcKpMrQOw
Path for PROJROT/FREQ/7558502 Job:
/lcrc/project/PACC/AutoMech/data/run/PROJROT/FREQ/C3H4O/7558502
running projrot the first time:
running projrot the second time:
Debug:  tors model in scale set 1dhrf
TAU FACTOR 171.136463 	 1 	 1.125950 
Debug:  scale_coeff test: 1.1259496376193683 1 1.2677625864551867 1.3 0.8

Determining the symmetry factor...
Setting symmetry factors as racemic= True
reduced int sym 1.0

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/C3H4O/HGINCPLSRVDWNT/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/rzwl8KQbVUdnV/c1YrbcKpMrQOw/SP/0zlOGvR
  - Ene = 1.000 x -191.673994312373 Eh
Final electronic energy: -191.673994312373 Eh
Process 3633084 prepping species: C3H4OALAD-Wv9FbZ
[H][H]
C
O

Determining reference molecules for scheme: basic

Determining basis for species: C3H4OALAD-Wv9FbZ
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Debug:  Energy already found for basis species:  InChI=1S/H2O/h1H2
Basis H contribution InChI=1S/H2/h1H -5.0 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 3.0 -0.025347824478645156 -40.409952504287865
Basis H contribution InChI=1S/H2O/h1H2 1.0 -0.09100420373931285 -76.3486703990646
ABS Energy  (hart):  -191.6133215430927
Hf0K Energy (hart):  -0.09158943432933017

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
rlmpvU5gVz095   cntE6oW5AAL7q   0.00  *  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading filesystem info for CH3
Using /lcrc/project/PACC/AutoMech/data/save/SPC/CH3/WCYWZMWISLQXQU/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/rlmpvU5gVz095/cntE6oW5AAL7q as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/CH3/WCYWZMWISLQXQU/0/2/UHFFFAOYSA-N/u-un9NU/CONFS/rzxerJKxmIhB_/cnATyxZg5400H for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/SPC/CH3/WCYWZMWISLQXQU/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/rlmpvU5gVz095/cntE6oW5AAL7q

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/CH3/WCYWZMWISLQXQU/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/rlmpvU5gVz095/cntE6oW5AAL7q
Calling ProjRot to diagonalize Hessian and get freqs...

Harmonic frequencies [cm-1]:
     513.810    1427.590    1427.600    3140.260    3321.570    3321.570

Harmonic ZPVE [kcal mol-1]: 18.80229972682163


Determining the symmetry factor...
Setting symmetry factors as racemic= True

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/CH3/WCYWZMWISLQXQU/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/rlmpvU5gVz095/cntE6oW5AAL7q/SP/0zlOGvR
  - Ene = 1.000 x -39.775626646647 Eh
Final electronic energy: -39.775626646647 Eh
Process 3633224 prepping species: CH3
[H][H]
C

Determining reference molecules for scheme: basic

Determining basis for species: CH3
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Basis H contribution InChI=1S/H2/h1H -0.5 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 1.0 -0.025347824478645156 -40.409952504287865
ABS Energy  (hart):  -39.74607077661545
Hf0K Energy (hart):  0.2365173109391546

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
rrh-ibZTIPKv4   cGMDAkeOkJAgr   0.00  *  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading Reading filesystem info for ts_1_7_0
Obtaining a ZRXN object from conformer any TS, shouldn't matter
-----
Using /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/C3H4O.CH3/HXKSAMBJENJDKD/0_0/1_2/UHFFFAOYSA-N/2/hJUn9NU/TS/00/CONFS/rrh-ibZTIPKv4/cGMDAkeOkJAgr as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/C3H4O.CH3/HXKSAMBJENJDKD/0_0/1_2/UHFFFAOYSA-N/2/u-un9NU/TS/00/CONFS/rNIpFpqem76Ab/cHTJxtnMK46ib for torsional profiles
-----
Using /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/C3H4O.CH3/HXKSAMBJENJDKD/0_0/1_2/UHFFFAOYSA-N/2/hJUn9NU/TS/00/CONFS/rrh-ibZTIPKv4/cGMDAkeOkJAgr as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/C3H4O.CH3/HXKSAMBJENJDKD/0_0/1_2/UHFFFAOYSA-N/2/u-un9NU/TS/00/CONFS/rNIpFpqem76Ab/cHTJxtnMK46ib for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/C3H4O.CH3/HXKSAMBJENJDKD/0_0/1_2/UHFFFAOYSA-N/2/hJUn9NU/TS/00/CONFS/rrh-ibZTIPKv4/cGMDAkeOkJAgr

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
rotor names (('D6',), ('D9',))
potential test:
names ('D6',)
grids ((4.654546988737761, 5.17814576433606, 5.701744539934358, 6.225343315532657, 6.7489420911309566, 7.272540866729255, 7.796139642327554, 8.319738417925853, 8.843337193524151, 9.366935969122451, 9.89053474472075, 10.414133520319048),)
max norm diff of splines  0.035407250202507755 0.05
potential test:
names ('D9',)
grids ((3.156707170005479, 3.6803059456037777, 4.203904721202076, 4.7275034968003755),)
max norm diff of splines  0.06295426395120117 0.1
Debug:  tors model in scale set 1dhrf
Debug:  tors model in scale set 1dhrf
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/C3H4O.CH3/HXKSAMBJENJDKD/0_0/1_2/UHFFFAOYSA-N/2/hJUn9NU/TS/00/CONFS/rrh-ibZTIPKv4/cGMDAkeOkJAgr
Path for PROJROT/FREQ/9799760 Job:
/lcrc/project/PACC/AutoMech/data/run/PROJROT/FREQ/C4H7O/9799760
running projrot the first time:
running projrot the second time:
Debug:  tors model in scale set 1dhrf
TAU FACTOR 17930.393736 	 2 	 1.162046 
Debug:  scale_coeff test: 1.1620462766141726 2 1.1620462766141726 1.3 0.8

Determining the symmetry factor...
Setting symmetry factors as racemic= True
reduced int sym 1.0

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/C3H4O.CH3/HXKSAMBJENJDKD/0_0/1_2/UHFFFAOYSA-N/2/hJUn9NU/TS/00/CONFS/rrh-ibZTIPKv4/cGMDAkeOkJAgr/SP/0zlOGvR
  - Ene = 1.000 x -231.437668216582 Eh
Final electronic energy: -231.437668216582 Eh
Process 3634690 prepping species: ts_1_7_0
[H][H]
C
O

Determining reference molecules for scheme: basic

Determining basis for species: ts_1_7_0
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Debug:  Energy already found for basis species:  InChI=1S/H2O/h1H2
Basis H contribution InChI=1S/H2/h1H -5.5 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 4.0 -0.025347824478645156 -40.409952504287865
Basis H contribution InChI=1S/H2O/h1H2 1.0 -0.09100420373931285 -76.3486703990646
ABS Energy  (hart):  -231.34299424174364
Hf0K Energy (hart):  0.21353743481330492


Getting energies for the reaction channel...
reac ene 0.031084571959397067 0.031084571959397067
prod ene -0.021890400174314095 -0.021890400174314095
prod ene 0.05652899401031419 0.05652899401031419
Debug:  REAC HoF (0 K) spc lvl kcal/mol:  19.50586339284125
Debug:  REAC HoF (0 K) ts lvl kcal/mol:  19.50586339284125
Debug:  PROD HoF (0 K) spc lvl kcal/mol:  21.736045790422274
Debug:  PROD HoF (0 K) ts lvl kcal/mol:  21.736045790422274
Debug:  TS HoF (0 K) ts lvl kcal/mol:  32.02599506489057
Debug:  TS HoF (0 K) approx spc lvl kcal/mol:  32.02599506489057



Reading PES electronic structure data
Running Channel 8: C4H7O4H74fm0 = C2H4OALD-UPQWKw+C2H3ALK-S58hH1
Begin parallel job array on 2 processors

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
rKfEmOBtanXsi   cY4hZsJvgwtyp   0.00  *  
rKfEmOBtanXsi   cxeuERJebYplM   0.14     

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading filesystem info for C4H7O4H74fm0
Using /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/hJUn9NU/CONFS/rKfEmOBtanXsi/cY4hZsJvgwtyp as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/u-un9NU/CONFS/rBPyqEPcXezfu/cS6UQ_qtHitU9 for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/hJUn9NU/CONFS/rKfEmOBtanXsi/cY4hZsJvgwtyp

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
rotor names (('D6',), ('D9',))
potential test:
names ('D6',)
grids ((2.017769807523133, 2.541368583121432, 3.0649673587197306, 3.5885661343180297, 4.112164909916329, 4.635763685514627, 5.159362461112926, 5.682961236711225, 6.206560012309524, 6.730158787907823, 7.253757563506121, 7.77735633910442),)
max norm diff of splines  0.06225998209434073 0.05
Removing bad angle at 415.60969399999993 degrees
potential test:
names ('D9',)
grids ((3.062114792590272, 3.5857135681885706, 4.109312343786869, 4.632911119385168),)
max norm diff of splines  0.06144846645806796 0.1
Debug:  tors model in scale set 1dhrf
Debug:  tors model in scale set 1dhrf
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/hJUn9NU/CONFS/rKfEmOBtanXsi/cY4hZsJvgwtyp
Path for PROJROT/FREQ/3863482 Job:
/lcrc/project/PACC/AutoMech/data/run/PROJROT/FREQ/C4H7O/3863482
running projrot the first time:
running projrot the second time:
Debug:  tors model in scale set 1dhrf
TAU FACTOR 24595.912123 	 2 	 0.977878 
Debug:  scale_coeff test: 0.9778780167211941 2 0.9778780167211941 1.3 0.8

Determining the symmetry factor...
Setting symmetry factors as racemic= True
reduced int sym 1.0

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/hJUn9NU/CONFS/rKfEmOBtanXsi/cY4hZsJvgwtyp/SP/0zlOGvR
  - Ene = 1.000 x -231.461611024044 Eh
Final electronic energy: -231.461611024044 Eh
Process 3634877 prepping species: C4H7O4H74fm0
[H][H]
C
O

Determining reference molecules for scheme: basic

Determining basis for species: C4H7O4H74fm0
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Debug:  Energy already found for basis species:  InChI=1S/H2O/h1H2
Basis H contribution InChI=1S/H2/h1H -5.5 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 4.0 -0.025347824478645156 -40.409952504287865
Basis H contribution InChI=1S/H2O/h1H2 1.0 -0.09100420373931285 -76.3486703990646
ABS Energy  (hart):  -231.36294634158475
Hf0K Energy (hart):  0.13005784907811732

Determining energy transfer parameters...
  - No bath provided, using Argon bath as default

- Determining the masses...
  - Obtaining masses from geometries...

- Determining the Lennard-Jones model parameters...
- Estimating the parameters...
    - Series to use for estimation: frozenset({'1-alkyl', 'InChI=1S/Ar'})
    - Heavy atom count: 5

- Determining the energy-down transfer model parameters...
  - Estimating the parameters...
    - Series to use for estimation: frozenset({'1-alkyl', 'InChI=1S/Ar'})
    - Found effective rotor count: 3.67
    - Using following LJ parameters for collisional frequency and alpha calculation:
       eps=165.90 cm-1, sigma=4.60 Ang,
       mass1=71.05 amu, mass2=39.96 amu
edown_vec test: [ 402.81471776  803.84812758 1289.83282782] 402.81471776444926
    - E_down prefactor (after dividing by empirical factor of 2.0): 402.81471776444926
    - E_down power: 0.60

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
r_dYTaNODYFFz   cE01lKokGc6BI   0.00  *  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading filesystem info for C2H4OALD-UPQWKw
Using /lcrc/project/PACC/AutoMech/data/save/SPC/C2H4O/IKHGUXGNUITLKF/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/r_dYTaNODYFFz/cE01lKokGc6BI as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/C2H4O/IKHGUXGNUITLKF/0/1/UHFFFAOYSA-N/u-un9NR/CONFS/roTZ11KoGu4MR/cJu5792Tyaefq for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/SPC/C2H4O/IKHGUXGNUITLKF/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/r_dYTaNODYFFz/cE01lKokGc6BI

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
rotor names (('D5',),)
potential test:
names ('D5',)
grids ((2.123053408710942, 2.6466521843092408, 3.1702509599075395, 3.6938497355058386),)
max norm diff of splines  0.06784498705999874 0.1
Debug:  tors model in scale set 1dhrf
Debug:  tors model in scale set 1dhrf
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/C2H4O/IKHGUXGNUITLKF/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/r_dYTaNODYFFz/cE01lKokGc6BI
Path for PROJROT/FREQ/1328306 Job:
/lcrc/project/PACC/AutoMech/data/run/PROJROT/FREQ/C2H4O/1328306
running projrot the first time:
running projrot the second time:
Debug:  tors model in scale set 1dhrf
TAU FACTOR 159.914887 	 1 	 1.048464 
Debug:  scale_coeff test: 1.0484640776109937 1 1.0992769220406717 1.3 0.8

Determining the symmetry factor...
Setting symmetry factors as racemic= True
reduced int sym 1.0

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/C2H4O/IKHGUXGNUITLKF/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/r_dYTaNODYFFz/cE01lKokGc6BI/SP/0zlOGvR
  - Ene = 1.000 x -153.649720291023 Eh
Final electronic energy: -153.649720291023 Eh
Process 3635104 prepping species: C2H4OALD-UPQWKw
[H][H]
C
O

Determining reference molecules for scheme: basic

Determining basis for species: C2H4OALD-UPQWKw
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Debug:  Energy already found for basis species:  InChI=1S/H2O/h1H2
Basis H contribution InChI=1S/H2/h1H -3.0 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 2.0 -0.025347824478645156 -40.409952504287865
Basis H contribution InChI=1S/H2O/h1H2 1.0 -0.09100420373931285 -76.3486703990646
ABS Energy  (hart):  -153.59480125799968
Hf0K Energy (hart):  -0.2508523817276205

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
r-cOYLMr8Oy0k   coRpLx7rSWO3C   0.00  *  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading filesystem info for C2H3ALK-S58hH1
Using /lcrc/project/PACC/AutoMech/data/save/SPC/C2H3/ORGHESHFQPYLAO/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/r-cOYLMr8Oy0k/coRpLx7rSWO3C as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/C2H3/ORGHESHFQPYLAO/0/2/UHFFFAOYSA-N/u-un9NU/CONFS/ra6fq0p5z0e88/cd5-wgfJF3EzQ for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/SPC/C2H3/ORGHESHFQPYLAO/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/r-cOYLMr8Oy0k/coRpLx7rSWO3C

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/C2H3/ORGHESHFQPYLAO/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/r-cOYLMr8Oy0k/coRpLx7rSWO3C
Calling ProjRot to diagonalize Hessian and get freqs...

Harmonic frequencies [cm-1]:
     720.800     830.880     938.060    1064.800    1407.380    1671.700
    3077.980    3177.350    3266.440

Harmonic ZPVE [kcal mol-1]: 23.09528945163597


Determining the symmetry factor...
Setting symmetry factors as racemic= True

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/C2H3/ORGHESHFQPYLAO/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/r-cOYLMr8Oy0k/coRpLx7rSWO3C/SP/0zlOGvR
  - Ene = 1.000 x -77.781098717394 Eh
Final electronic energy: -77.781098717394 Eh
Process 3635213 prepping species: C2H3ALK-S58hH1
[H][H]
C

Determining reference molecules for scheme: basic

Determining basis for species: C2H3ALK-S58hH1
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Basis H contribution InChI=1S/H2/h1H -2.5 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 2.0 -0.025347824478645156 -40.409952504287865
ABS Energy  (hart):  -77.74479457464066
Hf0K Energy (hart):  0.47860876022912296
Begin parallel job array on 2 processors
No freqs found that match  /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/C2H4O.C2H3/RPNVETMGGXGKAX/0_0/1_2/UHFFFAOYSA-N/2/hJUn9NU/TS/00/CONFS/rINag0S5fc1IM/chltuCcdp5GMX in the freq location /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/C2H4O.C2H3/RPNVETMGGXGKAX/0_0/1_2/UHFFFAOYSA-N/2/hJUn9NU/TS/u-ulpJU/CONFS

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
rINag0S5fc1IM   c9YyxLldD3FMH   0.00  *  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading Reading filesystem info for ts_1_8_0
Obtaining a ZRXN object from conformer any TS, shouldn't matter
-----
Using /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/C2H4O.C2H3/RPNVETMGGXGKAX/0_0/1_2/UHFFFAOYSA-N/2/hJUn9NU/TS/00/CONFS/rINag0S5fc1IM/c9YyxLldD3FMH as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/C2H4O.C2H3/RPNVETMGGXGKAX/0_0/1_2/UHFFFAOYSA-N/2/u-un9NU/TS/00/CONFS/rKaZCS6x7Or06/cXmPfxQEaE0FT for torsional profiles
-----
Using /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/C2H4O.C2H3/RPNVETMGGXGKAX/0_0/1_2/UHFFFAOYSA-N/2/hJUn9NU/TS/00/CONFS/rINag0S5fc1IM/c9YyxLldD3FMH as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/C2H4O.C2H3/RPNVETMGGXGKAX/0_0/1_2/UHFFFAOYSA-N/2/u-un9NU/TS/00/CONFS/rKaZCS6x7Or06/cXmPfxQEaE0FT for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/C2H4O.C2H3/RPNVETMGGXGKAX/0_0/1_2/UHFFFAOYSA-N/2/hJUn9NU/TS/00/CONFS/rINag0S5fc1IM/c9YyxLldD3FMH

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
rotor names (('D6',), ('D9',))
potential test:
names ('D6',)
grids ((2.3444771349926183, 2.868075910590917, 3.3916746861892157, 3.915273461787515, 4.438872237385814, 4.962471012984112, 5.4860697885824115, 6.009668564180711, 6.533267339779009, 7.056866115377308, 7.580464890975606, 8.104063666573905),)
max norm diff of splines  0.0353473532984198 0.05
potential test:
names ('D9',)
grids ((0.8953237120770315, 1.4189224876753304, 1.9425212632736293, 2.466120038871928),)
max norm diff of splines  0.05364251788330295 0.1
Debug:  tors model in scale set 1dhrf
Debug:  tors model in scale set 1dhrf
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/C2H4O.C2H3/RPNVETMGGXGKAX/0_0/1_2/UHFFFAOYSA-N/2/hJUn9NU/TS/00/CONFS/rINag0S5fc1IM/c9YyxLldD3FMH
Path for PROJROT/FREQ/2574116 Job:
/lcrc/project/PACC/AutoMech/data/run/PROJROT/FREQ/C4H7O/2574116
running projrot the first time:
running projrot the second time:
Debug:  tors model in scale set 1dhrf
TAU FACTOR 11233.152662 	 2 	 1.170933 
Debug:  scale_coeff test: 1.1709332145843294 2 1.1709332145843294 1.3 0.8

Determining the symmetry factor...
Setting symmetry factors as racemic= True
reduced int sym 1.0

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/CUSJKSZZDNGAJQ/0/2/BYPYZUCNSA-N/C2H4O.C2H3/RPNVETMGGXGKAX/0_0/1_2/UHFFFAOYSA-N/2/hJUn9NU/TS/00/CONFS/rINag0S5fc1IM/c9YyxLldD3FMH/SP/0zlOGvR
  - Ene = 1.000 x -231.425875388685 Eh
Final electronic energy: -231.425875388685 Eh
Process 3636854 prepping species: ts_1_8_0
[H][H]
C
O

Determining reference molecules for scheme: basic

Determining basis for species: ts_1_8_0
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Debug:  Energy already found for basis species:  InChI=1S/H2O/h1H2
Basis H contribution InChI=1S/H2/h1H -5.5 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 4.0 -0.025347824478645156 -40.409952504287865
Basis H contribution InChI=1S/H2O/h1H2 1.0 -0.09100420373931285 -76.3486703990646
ABS Energy  (hart):  -231.3318656141831
Hf0K Energy (hart):  0.26009961252659597


Getting energies for the reaction channel...
reac ene 0.031084571959397067 0.031084571959397067
prod ene -0.05995515815669705 -0.05995515815669705
prod ene 0.11439023906049783 0.11439023906049783
Debug:  REAC HoF (0 K) spc lvl kcal/mol:  19.50586339284125
Debug:  REAC HoF (0 K) ts lvl kcal/mol:  19.50586339284125
Debug:  PROD HoF (0 K) spc lvl kcal/mol:  34.158528972981706
Debug:  PROD HoF (0 K) ts lvl kcal/mol:  34.158528972981706
Debug:  TS HoF (0 K) ts lvl kcal/mol:  39.00931428926998
Debug:  TS HoF (0 K) approx spc lvl kcal/mol:  39.00931428926998



Reading PES electronic structure data
Running Channel 9: C4H7O-kSV4fm = C2H4OALD-UPQWKw+C2H3ALK-S58hH1
Begin parallel job array on 2 processors

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
rPf7Y7grdiEFT   crdv-3qzacBnq   0.00  *  
rPf7Y7grdiEFT   chCboitlm-bVQ   0.65     

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading filesystem info for C4H7O-kSV4fm
Using /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/QVEJVAOFVGTBQB/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/rPf7Y7grdiEFT/crdv-3qzacBnq as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/QVEJVAOFVGTBQB/0/2/UHFFFAOYSA-N/u-un9NU/CONFS/rvtbNWkLVd4vr/cInx8hxaVqKxb for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/QVEJVAOFVGTBQB/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/rPf7Y7grdiEFT/crdv-3qzacBnq

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
rotor names (('D6',), ('D7',), ('D9',))
potential test:
names ('D6',)
grids ((3.1201899078653894, 3.643788683463688, 4.167387459061987, 4.690986234660286, 5.214585010258585, 5.738183785856883, 6.261782561455183, 6.785381337053481, 7.3089801126517795, 7.8325788882500795, 8.356177663848378, 8.879776439446676),)
max norm diff of splines  0.02064323906207646 0.05
potential test:
names ('D7',)
grids ((0.32325309398698554, 0.8468518695852844, 1.3704506451835832, 1.894049420781882, 2.417648196380181, 2.9412469719784795, 3.4648457475767787, 3.9884445231750774, 4.512043298773376, 5.035642074371675, 5.5592408499699735, 6.082839625568273),)
max norm diff of splines  0.09160190160292288 0.05
Removing bad angle at 258.521038 degrees
potential test:
names ('D9',)
grids ((3.000860298283258, 3.5244590738815567, 4.048057849479855, 4.5716566250781545),)
max norm diff of splines  0.06252005552394407 0.1
Debug:  tors model in scale set 1dhrf
Debug:  tors model in scale set 1dhrf
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/QVEJVAOFVGTBQB/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/rPf7Y7grdiEFT/crdv-3qzacBnq
Path for PROJROT/FREQ/7789995 Job:
/lcrc/project/PACC/AutoMech/data/run/PROJROT/FREQ/C4H7O/7789995
running projrot the first time:
running projrot the second time:
Debug:  tors model in scale set 1dhrf
TAU FACTOR 1569036.394191 	 3 	 0.806278 
Debug:  scale_coeff test: 0.8062780433230428 3 0.8662765444181255 1.3 0.8

Determining the symmetry factor...
Setting symmetry factors as racemic= True
reduced int sym 1.0

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/C4H7O/QVEJVAOFVGTBQB/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/rPf7Y7grdiEFT/crdv-3qzacBnq/SP/0zlOGvR
  - Ene = 1.000 x -231.463893723195 Eh
Final electronic energy: -231.463893723195 Eh
Process 3637034 prepping species: C4H7O-kSV4fm
[H][H]
C
O

Determining reference molecules for scheme: basic

Determining basis for species: C4H7O-kSV4fm
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Debug:  Energy already found for basis species:  InChI=1S/H2O/h1H2
Basis H contribution InChI=1S/H2/h1H -5.5 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 4.0 -0.025347824478645156 -40.409952504287865
Basis H contribution InChI=1S/H2O/h1H2 1.0 -0.09100420373931285 -76.3486703990646
ABS Energy  (hart):  -231.36590636462998
Hf0K Energy (hart):  0.11767311265686192

Determining energy transfer parameters...
  - No bath provided, using Argon bath as default

- Determining the masses...
  - Obtaining masses from geometries...

- Determining the Lennard-Jones model parameters...
- Estimating the parameters...
    - Series to use for estimation: frozenset({'1-alkyl', 'InChI=1S/Ar'})
    - Heavy atom count: 5

- Determining the energy-down transfer model parameters...
  - Estimating the parameters...
    - Series to use for estimation: frozenset({'1-alkyl', 'InChI=1S/Ar'})
    - Found effective rotor count: 3.67
    - Using following LJ parameters for collisional frequency and alpha calculation:
       eps=165.90 cm-1, sigma=4.60 Ang,
       mass1=71.05 amu, mass2=39.96 amu
edown_vec test: [ 402.81471776  803.84812758 1289.83282782] 402.81471776444926
    - E_down prefactor (after dividing by empirical factor of 2.0): 402.81471776444926
    - E_down power: 0.60

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
r_dYTaNODYFFz   cE01lKokGc6BI   0.00  *  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading filesystem info for C2H4OALD-UPQWKw
Using /lcrc/project/PACC/AutoMech/data/save/SPC/C2H4O/IKHGUXGNUITLKF/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/r_dYTaNODYFFz/cE01lKokGc6BI as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/C2H4O/IKHGUXGNUITLKF/0/1/UHFFFAOYSA-N/u-un9NR/CONFS/roTZ11KoGu4MR/cJu5792Tyaefq for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/SPC/C2H4O/IKHGUXGNUITLKF/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/r_dYTaNODYFFz/cE01lKokGc6BI

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
rotor names (('D5',),)
potential test:
names ('D5',)
grids ((2.123053408710942, 2.6466521843092408, 3.1702509599075395, 3.6938497355058386),)
max norm diff of splines  0.06784498705999874 0.1
Debug:  tors model in scale set 1dhrf
Debug:  tors model in scale set 1dhrf
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/C2H4O/IKHGUXGNUITLKF/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/r_dYTaNODYFFz/cE01lKokGc6BI
Path for PROJROT/FREQ/6674663 Job:
/lcrc/project/PACC/AutoMech/data/run/PROJROT/FREQ/C2H4O/6674663
running projrot the first time:
running projrot the second time:
Debug:  tors model in scale set 1dhrf
TAU FACTOR 159.914887 	 1 	 1.048464 
Debug:  scale_coeff test: 1.0484640776109937 1 1.0992769220406717 1.3 0.8

Determining the symmetry factor...
Setting symmetry factors as racemic= True
reduced int sym 1.0

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/C2H4O/IKHGUXGNUITLKF/0/1/UHFFFAOYSA-N/hJUn9NR/CONFS/r_dYTaNODYFFz/cE01lKokGc6BI/SP/0zlOGvR
  - Ene = 1.000 x -153.649720291023 Eh
Final electronic energy: -153.649720291023 Eh
Process 3637234 prepping species: C2H4OALD-UPQWKw
[H][H]
C
O

Determining reference molecules for scheme: basic

Determining basis for species: C2H4OALD-UPQWKw
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Debug:  Energy already found for basis species:  InChI=1S/H2O/h1H2
Basis H contribution InChI=1S/H2/h1H -3.0 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 2.0 -0.025347824478645156 -40.409952504287865
Basis H contribution InChI=1S/H2O/h1H2 1.0 -0.09100420373931285 -76.3486703990646
ABS Energy  (hart):  -153.59480125799968
Hf0K Energy (hart):  -0.2508523817276205

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
r-cOYLMr8Oy0k   coRpLx7rSWO3C   0.00  *  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading filesystem info for C2H3ALK-S58hH1
Using /lcrc/project/PACC/AutoMech/data/save/SPC/C2H3/ORGHESHFQPYLAO/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/r-cOYLMr8Oy0k/coRpLx7rSWO3C as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/SPC/C2H3/ORGHESHFQPYLAO/0/2/UHFFFAOYSA-N/u-un9NU/CONFS/ra6fq0p5z0e88/cd5-wgfJF3EzQ for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/SPC/C2H3/ORGHESHFQPYLAO/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/r-cOYLMr8Oy0k/coRpLx7rSWO3C

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/SPC/C2H3/ORGHESHFQPYLAO/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/r-cOYLMr8Oy0k/coRpLx7rSWO3C
Calling ProjRot to diagonalize Hessian and get freqs...

Harmonic frequencies [cm-1]:
     720.800     830.880     938.060    1064.800    1407.380    1671.700
    3077.980    3177.350    3266.440

Harmonic ZPVE [kcal mol-1]: 23.09528945163597


Determining the symmetry factor...
Setting symmetry factors as racemic= True

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/SPC/C2H3/ORGHESHFQPYLAO/0/2/UHFFFAOYSA-N/hJUn9NU/CONFS/r-cOYLMr8Oy0k/coRpLx7rSWO3C/SP/0zlOGvR
  - Ene = 1.000 x -77.781098717394 Eh
Final electronic energy: -77.781098717394 Eh
Process 3637327 prepping species: C2H3ALK-S58hH1
[H][H]
C

Determining reference molecules for scheme: basic

Determining basis for species: C2H3ALK-S58hH1
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Basis H contribution InChI=1S/H2/h1H -2.5 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 2.0 -0.025347824478645156 -40.409952504287865
ABS Energy  (hart):  -77.74479457464066
Hf0K Energy (hart):  0.47860876022912296

Conformer Ordering for all conformers
rid             cid             energy[kcal/mol]
-------         -------         -------         
rO3najWOlQCkN   c5yFCUiZVRuYq   0.00  *  

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Reading Reading filesystem info for ts_1_9_0
Obtaining a ZRXN object from conformer any TS, shouldn't matter
-----
Using /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/QVEJVAOFVGTBQB/0/2/UHFFFAOYSA-N/C2H4O.C2H3/RPNVETMGGXGKAX/0_0/1_2/UHFFFAOYSA-N/2/hJUn9NU/TS/00/CONFS/rO3najWOlQCkN/c5yFCUiZVRuYq as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/QVEJVAOFVGTBQB/0/2/UHFFFAOYSA-N/C2H4O.C2H3/RPNVETMGGXGKAX/0_0/1_2/UHFFFAOYSA-N/2/u-un9NU/TS/00/CONFS/r1VFt_vvQGHuz/cWul65f1HDcEQ for torsional profiles
-----
Using /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/QVEJVAOFVGTBQB/0/2/UHFFFAOYSA-N/C2H4O.C2H3/RPNVETMGGXGKAX/0_0/1_2/UHFFFAOYSA-N/2/hJUn9NU/TS/00/CONFS/rO3najWOlQCkN/c5yFCUiZVRuYq as the parent conformer location
and /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/QVEJVAOFVGTBQB/0/2/UHFFFAOYSA-N/C2H4O.C2H3/RPNVETMGGXGKAX/0_0/1_2/UHFFFAOYSA-N/2/u-un9NU/TS/00/CONFS/r1VFt_vvQGHuz/cWul65f1HDcEQ for torsional profiles

Obtaining info for rotation partition function...
Reading geometry at /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/QVEJVAOFVGTBQB/0/2/UHFFFAOYSA-N/C2H4O.C2H3/RPNVETMGGXGKAX/0_0/1_2/UHFFFAOYSA-N/2/hJUn9NU/TS/00/CONFS/rO3najWOlQCkN/c5yFCUiZVRuYq

Preparing internal rotor info building partition functions...

Obtaining the vibrational frequencies and zpves...
rotor names (('D6',), ('D7',), ('D9',))
potential test:
names ('D6',)
grids ((0.15153788069184976, 0.6751366562901486, 1.1987354318884473, 1.7223342074867463, 2.245932983085045, 2.769531758683344, 3.293130534281643, 3.8167293098799417, 4.34032808547824, 4.863926861076539, 5.387525636674837, 5.911124412273137),)
potential test:
names ('D7',)
grids ((1.5643498484829004, 2.087948624081199, 2.6115473996794982, 3.135146175277797, 3.6587449508760956, 4.182343726474395, 4.705942502072693, 5.229541277670992, 5.753140053269291, 6.27673882886759, 6.800337604465888, 7.323936380064188),)
potential test:
names ('D9',)
grids ((2.291175128702562, 2.8147739043008606, 3.3383726798991598, 3.8619714554974585),)
Debug:  tors model in scale set 1dhrf
Debug:  tors model in scale set 1dhrf
WARNING: empty potential will crash MESS so using rigid model instead
Reading Hessian at /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/QVEJVAOFVGTBQB/0/2/UHFFFAOYSA-N/C2H4O.C2H3/RPNVETMGGXGKAX/0_0/1_2/UHFFFAOYSA-N/2/hJUn9NU/TS/00/CONFS/rO3najWOlQCkN/c5yFCUiZVRuYq
Calling ProjRot to diagonalize Hessian and get freqs...

Harmonic frequencies [cm-1]:
      48.540      69.110     113.320     189.700     371.990     408.450
     505.180     741.110     772.870     880.450     897.620     936.480
    1054.270    1065.450    1129.980    1356.700    1397.840    1400.570
    1466.130    1481.780    1541.890    1678.260    3001.510    3033.440
    3082.990    3088.560    3152.330    3163.150    3300.580

Harmonic ZPVE [kcal mol-1]: 59.08455858128325


Determining the symmetry factor...
Setting symmetry factors as racemic= True
reduced int sym 1.0

Obtaining the electronic energy + zpve...
- Calculating electronic energy
Reading Energy at /lcrc/project/PACC/AutoMech/data/save/RXN/C4H7O/QVEJVAOFVGTBQB/0/2/UHFFFAOYSA-N/C2H4O.C2H3/RPNVETMGGXGKAX/0_0/1_2/UHFFFAOYSA-N/2/hJUn9NU/TS/00/CONFS/rO3najWOlQCkN/c5yFCUiZVRuYq/SP/0zlOGvR
  - Ene = 1.000 x -231.410991484844 Eh
Final electronic energy: -231.410991484844 Eh
Process 3638725 prepping species: ts_1_9_0
[H][H]
C
O

Determining reference molecules for scheme: basic

Determining basis for species: ts_1_9_0
Debug:  Energy already found for basis species:  InChI=1S/H2/h1H
Debug:  Energy already found for basis species:  InChI=1S/CH4/h1H4
Debug:  Energy already found for basis species:  InChI=1S/H2O/h1H2
Basis H contribution InChI=1S/H2/h1H -5.5 0.0 -1.1640098183669148
Basis H contribution InChI=1S/CH4/h1H4 4.0 -0.025347824478645156 -40.409952504287865
Basis H contribution InChI=1S/H2O/h1H2 1.0 -0.09100420373931285 -76.3486703990646
ABS Energy  (hart):  -231.31811478573422
Hf0K Energy (hart):  0.3176330787566991


Getting energies for the reaction channel...
reac ene 0.028124548914163938 0.028124548914163938
prod ene -0.05995515815669705 -0.05995515815669705
prod ene 0.11439023906049783 0.11439023906049783
Debug:  REAC HoF (0 K) spc lvl kcal/mol:  17.648420889357624
Debug:  REAC HoF (0 K) ts lvl kcal/mol:  17.648420889357624
Debug:  PROD HoF (0 K) spc lvl kcal/mol:  34.158528972981706
Debug:  PROD HoF (0 K) ts lvl kcal/mol:  34.158528972981706
Debug:  TS HoF (0 K) ts lvl kcal/mol:  47.63808941323025
Debug:  TS HoF (0 K) approx spc lvl kcal/mol:  47.63808941323025
Preparing global energy transfer section for MESS input...
- Determining reference well species...
  - Using C4H7ORvE4fmAA0 for global collision target for PES
- Determining information for the bath species...
  - No bath provided, using Argon bath as default

- Determining the masses...
  - Obtaining masses from geometries...

- Determining the Lennard-Jones model parameters...
- Estimating the parameters...
    - Series to use for estimation: frozenset({'1-alkyl', 'InChI=1S/Ar'})
    - Heavy atom count: 5

- Determining the energy-down transfer model parameters...
  - Estimating the parameters...
    - Series to use for estimation: frozenset({'1-alkyl', 'InChI=1S/Ar'})
    - Found effective rotor count: 2.00
    - Using following LJ parameters for collisional frequency and alpha calculation:
       eps=165.90 cm-1, sigma=4.60 Ang,
       mass1=71.05 amu, mass2=39.96 amu
edown_vec test: [267.6721487  588.79654867 979.47461383] 267.67214869983155
    - E_down prefactor (after dividing by empirical factor of 2.0): 267.67214869983155
    - E_down power: 0.68
Species for Hot: C4H7ORvE4fmAA0
Ranges for k(E) calculations: (0.1, 289.4530789778327, 0.1)
Preparing global keywords section for MESS input...
 - Using temperatures and pressures defined by user
 - Using internal AutoMech defaults for other MESS keywords:
Debug:  EnergyStepOverTemperature, ExcessEnergyOverTemperature, ModelEnergyLimit
Debug:  CalculationMethod, WellCutoff, ReductionMethod, AtomDistanceMin
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Writing MESS input file at /lcrc/project/PACC/AutoMech/data/run/MESS/RATE/C4H7O1_1_1/basev1
Debug:  MESS Input:

!===================================================
!  GLOBAL KEYWORDS
!===================================================
TemperatureList[K]                     300.0  350.0  400.0  450.0  500.0  550.0  600.0  650.0  700.0  750.0  800.0  850.0  900.0  950.0  1000.0
PressureList[atm]                      0.01  0.03  0.1  0.3  1.0  3.0  10.0  30.0  100.0
!
ModelEnergyLimit[kcal/mol]             800.00
EnergyStepOverTemperature              0.20
!
CalculationMethod                      direct
!
WellCutoff                             10
!WellExtension                          0.0010
!
ChemicalEigenvalueMax                  0.20
!
ReductionMethod                        diagonalization
!
HotEnergies[kcal/mol]                  1
C4H7ORvE4fmAA0 0.0:1.0:289.5
!
MicroRateOutput                        ke.out
MicroEnerMin[kcal/mol]                 0.1
MicroEnerMax[kcal/mol]                 289.4530789778327
MicroEnerStep[kcal/mol]                0.1
!
AtomDistanceMin[angstrom]              0.68793
!
RateOutput                             rate.out
!
!
!===================================================
!  BEGIN MASTER EQUATION MODEL
!===================================================
!
Model
!
GroundEnergyShiftMax[kcal/mol]  10
!
UseShortNames
!
!---------------------------------------------------
!  ENERGY TRANSFER SECTION
!---------------------------------------------------
  EnergyRelaxation
    Exponential
       Factor[1/cm]                     267.672
       Power                            0.675
       ExponentCutoff                   15.000
  End  ! EneRelax
  CollisionFrequency
    LennardJones
       Epsilons[1/cm]                   165.902    165.902
       Sigmas[angstrom]                 4.601      4.601
       Masses[amu]                      71.050     39.962
  End  ! CollidFreq
!---------------------------------------------------
!  REACTION CHANNELS SECTION
!---------------------------------------------------
Well C4H7ORvE4fmAA0   ! [[CH2][C@H]1[C@H](C)O1]
  Species
    RRHO
      Geometry[angstrom]        12
        C          0.66636      -0.17413      -0.40397
        C          1.98338      -0.39696       0.14653
        C         -0.53894      -0.02155       0.44414
        H          0.49187      -0.52500      -1.41434
        O          0.05448       1.13100      -0.14121
        C         -1.90277      -0.40553      -0.04841
        H         -0.38603      -0.09237       1.51741
        H          2.24763       0.03973       1.09620
        H          2.71463      -0.98005      -0.38760
        H         -2.65917       0.25189       0.37975
        H         -2.14006      -1.42924       0.24073
        H         -1.95294      -0.32398      -1.13223
      Core RigidRotor
        SymmetryFactor          1.0
      End  ! Core
      Frequencies[1/cm]         28
        247     287     451     464     549     699
        812     882     964     1025    1057    1133
        1144    1164    1232    1337    1380    1414
        1446    1455    1467    2919    2976    2982
        3001    3010    3042    3145
      ElectronicLevels[1/cm]    1
        0.0  2
      Rotor  Hindered   # D7
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.44559
              C          0.00000       1.24745      -0.79839
              H         -0.42947      -0.87132      -0.48562
              O          1.18318       0.49653      -0.65920
              C         -0.61408       1.31351      -2.16545
              H          0.00362       2.18059      -0.23902
              H          0.54715       0.76113       1.98232
              H         -0.53462      -0.75686       1.99812
              H         -0.05864       2.00835      -2.79651
              H         -1.64590       1.66091      -2.10385
              H         -0.59969       0.33346      -2.64082
        Group                        3   4   5   6   7   10  11  12
        Axis                         1   2
        Symmetry                     1
        PotentialSpline[kcal/mol]    12   11
          0.00    30.00   60.00   90.00   120.00  150.00
          180.00  210.00  240.00  270.00  300.00  330.00
          0.0000  1.1975  3.9796  5.4028  3.5627  0.8968
          0.0002  0.7866  3.2526  5.3325  3.4394  1.1154
      End  ! HindRot
      Rotor  Hindered   # D9
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.44559
              C          0.00000       1.24745      -0.79839
              H         -0.42947      -0.87132      -0.48562
              O          1.18318       0.49653      -0.65920
              C         -0.61408       1.31351      -2.16545
              H          0.00362       2.18059      -0.23902
              H          0.54715       0.76113       1.98232
              H         -0.53462      -0.75686       1.99812
              H         -0.05864       2.00835      -2.79651
              H         -1.64590       1.66091      -2.10385
              H         -0.59969       0.33346      -2.64082
        Group                        1   2   4   5   7   8   9
        Axis                         3   6
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.3355  2.9126  1.3504
      End  ! HindRot
      ZeroEnergy[kcal/mol]      0.00
  End  ! Species
    EnergyRelaxation
      Exponential
         Factor[1/cm]                     267.672
         Power                            0.675
         ExponentCutoff                   15.000
    End  ! EneRelax
    CollisionFrequency
      LennardJones
         Epsilons[1/cm]                   165.902    165.902
         Sigmas[angstrom]                 4.601      4.601
         Masses[amu]                      71.050     39.962
    End  ! CollidFreq
End  ! Well
Well C4H7O4H74fm0   ! [C=C[C@H](C)[O]]
  Species
    RRHO
      Geometry[angstrom]        12
        C          1.92181      -0.01641      -0.29413
        C          0.88159      -0.57253       0.31436
        H          1.84502       0.96923      -0.72874
        H          2.86747      -0.53159      -0.36973
        C         -0.47007       0.07947       0.44927
        H          0.96613      -1.55945       0.75571
        C         -1.54085      -0.69258      -0.36769
        O         -0.53470       1.36617      -0.01172
        H         -0.80164       0.04761       1.49754
        H         -2.52406      -0.25963      -0.20740
        H         -1.54115      -1.73016      -0.04041
        H         -1.28908      -0.65307      -1.42414
      Core RigidRotor
        SymmetryFactor          0.5
      End  ! Core
      Frequencies[1/cm]         28
        275     332     365     588     649     805
        885     948     954     1014    1021    1036
        1100    1219    1288    1330    1358    1411
        1449    1470    1654    2833    2933    3011
        3017    3023    3032    3113
      ElectronicLevels[1/cm]    1
        0.0  2
      Rotor  Hindered   # D6
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.32110
              H          0.00000       0.92952      -0.55412
              H          0.00149      -0.92353      -0.56210
              C         -0.01106       1.24493       2.17242
              H          0.00523      -0.93600       1.87140
              C         -1.31911       1.33781       3.00293
              O          0.07924       2.41531       1.48972
              H          0.80663       1.19854       2.91119
              H         -1.28249       2.19438       3.67145
              H         -1.42610       0.42398       3.58556
              H         -2.17017       1.43167       2.33144
        Group                        1   3   4   6
        Axis                         2   5
        Symmetry                     1
        PotentialSpline[kcal/mol]    12   11
          0.00    30.00   60.00   90.00   120.00  150.00
          180.00  210.00  240.00  270.00  300.00  330.00
          0.0000  0.3412  1.8945  1.4039  0.0000  0.3596
          1.4012  0.9421  0.3139  1.3925  2.9508  0.9794
      End  ! HindRot
      Rotor  Hindered   # D9
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.32110
              H          0.00000       0.92952      -0.55412
              H          0.00149      -0.92353      -0.56210
              C         -0.01106       1.24493       2.17242
              H          0.00523      -0.93600       1.87140
              C         -1.31911       1.33781       3.00293
              O          0.07924       2.41531       1.48972
              H          0.80663       1.19854       2.91119
              H         -1.28249       2.19438       3.67145
              H         -1.42610       0.42398       3.58556
              H         -2.17017       1.43167       2.33144
        Group                        1   2   3   4   6   8   9
        Axis                         5   7
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.4563  3.0346  1.5339
      End  ! HindRot
      ZeroEnergy[kcal/mol]      0.69
  End  ! Species
    EnergyRelaxation
      Exponential
         Factor[1/cm]                     402.815
         Power                            0.602
         ExponentCutoff                   15.000
    End  ! EneRelax
    CollisionFrequency
      LennardJones
         Epsilons[1/cm]                   165.902    165.902
         Sigmas[angstrom]                 4.601      4.601
         Masses[amu]                      71.050     39.962
    End  ! CollidFreq
End  ! Well
Well C4H7O-kSV4fm   ! [C=CO[CH]C]
  Species
    RRHO
      Geometry[angstrom]        12
        C          2.27851      -0.21273       0.04621
        C          0.95978      -0.32110      -0.07900
        H          2.74809       0.73971       0.23554
        H          2.89295      -1.09268      -0.04236
        O          0.15061       0.76820       0.02630
        H          0.47033      -1.26407      -0.27149
        C         -1.20683       0.64838      -0.12793
        C         -1.91169      -0.64303       0.06641
        H         -1.68817       1.59012       0.07473
        H         -2.98329      -0.46062       0.03693
        H         -1.67711      -1.10910       1.03146
        H         -1.68631      -1.37810      -0.70931
      Core RigidRotor
        SymmetryFactor          1.0
      End  ! Core
      Frequencies[1/cm]         27
        239     398     485     594     697     839
        847     958     964     997     1104    1142
        1274    1320    1360    1396    1406    1443
        1465    1653    2860    2919    2995    3046
        3073    3093    3138
      ElectronicLevels[1/cm]    1
        0.0  2
      Rotor  Hindered   # D6
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.32437
              H          0.00000       0.92163      -0.56361
              H          0.00085      -0.93840      -0.53134
              O         -0.00004       1.15566       2.02817
              H         -0.00233      -0.91503       1.90219
              C         -0.02491       1.15767       3.39000
              C          0.34395      -0.02962       4.19606
              H          0.06965       2.16166       3.77145
              H          0.38377       0.26020       5.24422
              H          1.32679      -0.43644       3.92327
              H         -0.37779      -0.84822       4.11254
        Group                        1   3   4   6
        Axis                         2   5
        Symmetry                     1
        PotentialSpline[kcal/mol]    12   11
          0.00    30.00   60.00   90.00   120.00  150.00
          180.00  210.00  240.00  270.00  300.00  330.00
          0.0000  0.4575  1.7308  3.1244  3.6427  3.2671
          2.5242  2.1012  2.4620  3.1972  1.9974  0.5563
      End  ! HindRot
      Rotor  Hindered   # D7
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.32437
              H          0.00000       0.92163      -0.56361
              H          0.00085      -0.93840      -0.53134
              O         -0.00004       1.15566       2.02817
              H         -0.00233      -0.91503       1.90219
              C         -0.02491       1.15767       3.39000
              C          0.34395      -0.02962       4.19606
              H          0.06965       2.16166       3.77145
              H          0.38377       0.26020       5.24422
              H          1.32679      -0.43644       3.92327
              H         -0.37779      -0.84822       4.11254
        Group                        1   2   3   4   6
        Axis                         5   7
        Symmetry                     1
        PotentialSpline[kcal/mol]    12   11
          0.00    30.00   60.00   90.00   120.00  150.00
          180.00  210.00  240.00  270.00  300.00  330.00
          0.0000  0.4151  1.6993  1.6692  0.0000  0.0000
          0.0000  0.3243  2.3528  1.1501  0.5245  0.3223
      End  ! HindRot
      Rotor  Hindered   # D9
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.32437
              H          0.00000       0.92163      -0.56361
              H          0.00085      -0.93840      -0.53134
              O         -0.00004       1.15566       2.02817
              H         -0.00233      -0.91503       1.90219
              C         -0.02491       1.15767       3.39000
              C          0.34395      -0.02962       4.19606
              H          0.06965       2.16166       3.77145
              H          0.38377       0.26020       5.24422
              H          1.32679      -0.43644       3.92327
              H         -0.37779      -0.84822       4.11254
        Group                        1   2   3   4   5   6   9
        Axis                         7   8
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.1453  2.3475  1.1802
      End  ! HindRot
      ZeroEnergy[kcal/mol]      -1.17
  End  ! Species
    EnergyRelaxation
      Exponential
         Factor[1/cm]                     402.815
         Power                            0.602
         ExponentCutoff                   15.000
    End  ! EneRelax
    CollisionFrequency
      LennardJones
         Epsilons[1/cm]                   165.902    165.902
         Sigmas[angstrom]                 4.601      4.601
         Masses[amu]                      71.050     39.962
    End  ! CollidFreq
End  ! Well
Well FakeW-C4H6O-RvErx50+H-TcYTcY   ! Fake Well for C4H6O-RvErx50+H-TcYTcY
  Species
    RRHO
      Geometry[angstrom]        12
        C          0.69607      -0.03882       0.09276
        C          1.87010      -0.61804      -0.06579
        C         -0.67176       0.05077       0.50963
        O          0.07561       1.12674      -0.21596
        C         -1.79350      -0.58859      -0.24748
        H         -0.87266       0.32837       1.53777
        H          2.03163      -1.61023       0.32098
        H          2.67289      -0.11052      -0.57674
        H         -1.49463      -0.78944      -1.27301
        H         -2.67147       0.05575      -0.25091
        H         -2.06713      -1.53128       0.22686
        H          0.00000       0.00000       4.43193
      Core RigidRotor
        SymmetryFactor          0.5
      End  ! Core
      Frequencies[1/cm]         29
        10      20      30      204     348     410
        555     676     715     800     822     931
        1013    1061    1107    1120    1208    1345
        1387    1424    1456    1465    1808    2924
        2985    3003    3020    3044    3133
      ElectronicLevels[1/cm]    1
        0.0  2
      Rotor  Hindered   # D8
        Geometry[angstrom]     11
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.31327
              C          0.00000       0.56904      -1.31357
              O         -0.04575      -0.87334      -1.02229
              C         -1.22354       1.16093      -1.94194
              H          0.95344       0.87113      -1.73545
              H          0.04213       0.93582       1.84745
              H         -0.03899      -0.92600       1.86726
              H         -2.12363       0.77972      -1.46359
              H         -1.25915       0.92734      -3.00595
              H         -1.20393       2.24587      -1.83304
        Group                        1   2   4   6   7   8
        Axis                         3   5
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.1106  2.3476  1.0405
      End  ! HindRot
      ZeroEnergy[kcal/mol]      37.69
  End  ! Species
End  ! Well
Well FakeW-C3H4OALAD-Wv9FbZ+CH3   ! Fake Well for C3H4OALAD-Wv9FbZ+CH3
  Species
    RRHO
      Geometry[angstrom]        12
        C         -1.83430       0.15529       0.00004
        C         -0.64043      -0.43795      -0.00007
        H         -1.91404       1.23477       0.00006
        H         -2.75648      -0.40584       0.00013
        C          0.59404       0.36114      -0.00004
        H         -0.52572      -1.51324      -0.00008
        O          1.71111      -0.10754       0.00006
        H          0.43265       1.45668      -0.00016
        C          0.00000      -0.00000       3.00013
        H          0.00000       1.07573       3.00013
        H          0.93161      -0.53787       3.00013
        H         -0.93161      -0.53787       3.00013
      Core RigidRotor
        SymmetryFactor          6.0
      End  ! Core
      Frequencies[1/cm]         29
        10      20      30      40      50      60
        320     568     603     911     983     1010
        1022    1152    1274    1362    1426    1628
        1708    2786    3018    3059    3106    509
        1390    1390    3001    3169    3169
      ElectronicLevels[1/cm]    1
        0.0  2
      Rotor  Hindered   # D6
        Geometry[angstrom]     8
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.32632
              H          0.00000       0.93115      -0.55562
              H         -0.00000      -0.91518      -0.57561
              C          0.00001       1.26600       2.08029
              H          0.00000      -0.91309       1.90838
              O          0.00001       1.33912       3.28041
              H          0.00001       2.17986       1.45087
        Group                        1   3   4   6
        Axis                         2   5
        Symmetry                     1
        PotentialSpline[kcal/mol]    12   11
          0.00    30.00   60.00   90.00   120.00  150.00
          180.00  210.00  240.00  270.00  300.00  330.00
          0.0000  1.8695  6.8539  9.9516  6.9141  3.4410
          2.3041  3.4411  6.9140  9.9515  6.8537  1.8694
      End  ! HindRot
      ZeroEnergy[kcal/mol]      -0.08
  End  ! Species
End  ! Well
Well FakeW-C2H4OALD-UPQWKw+C2H3ALK-S58hH1   ! Fake Well for C2H4OALD-UPQWKw+C2H3ALK-S58hH1
  Species
    RRHO
      Geometry[angstrom]        12
        C          1.26146      -0.13303      -0.00000
        C         -0.13550       0.41436       0.00000
        H          1.79668       0.23656      -0.87605
        H          1.79659       0.23634       0.87620
        H          1.24756      -1.21875      -0.00014
        O         -1.13683      -0.25982      -0.00000
        H         -0.20516       1.51966      -0.00002
        C          0.02725       0.68893       3.39994
        C          0.02725      -0.61439       3.39994
        H         -0.69326       1.48854       3.39994
        H         -0.90022      -1.18499       3.39994
        H          0.94444      -1.19109       3.39994
      Core RigidRotor
        SymmetryFactor          1.0
      End  ! Core
      Frequencies[1/cm]         29
        10      20      30      40      50      60
        504     766     879     1114    1118    1353
        1396    1434    1444    1742    2782    2916
        2974    3025    711     817     921     1043
        1371    1622    2943    3035    3118
      ElectronicLevels[1/cm]    1
        0.0  2
      Rotor  Hindered   # D5
        Geometry[angstrom]     7
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.49911
              H          0.00000       1.02963      -0.36370
              H          0.91942      -0.46358      -0.36360
              H         -0.86583      -0.53321      -0.38391
              O         -0.84028      -0.51779       2.18101
              H          0.85486       0.52673       1.97023
        Group                        3   4   5
        Axis                         1   2
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  0.5592  1.2391  0.4533
      End  ! HindRot
      ZeroEnergy[kcal/mol]      12.34
  End  ! Species
End  ! Well
Bimolecular C4H6O-RvErx50+H-TcYTcY   ! [C=C1[C@H](C)O1 + [H]]
!---------------------------------------------------
  Fragment C4H6O-RvErx50   ! C=C1[C@H](C)O1
    RRHO
      Geometry[angstrom]        11
        C          0.72742       0.00885       0.09297
        C          1.90144      -0.57037      -0.06558
        C         -0.64042       0.09844       0.50984
        O          0.10695       1.17441      -0.21575
        C         -1.76216      -0.54091      -0.24727
        H         -0.84131       0.37604       1.53798
        H          2.06298      -1.56256       0.32119
        H          2.70423      -0.06285      -0.57653
        H         -1.46328      -0.74177      -1.27280
        H         -2.64013       0.10342      -0.25070
        H         -2.03579      -1.48361       0.22707
      Core RigidRotor
        SymmetryFactor          0.5
      End  ! Core
      Frequencies[1/cm]         26
        204     348     410     555     676     715
        800     822     931     1013    1061    1107
        1120    1208    1345    1387    1424    1456
        1465    1808    2924    2985    3003    3020
        3044    3133
      ElectronicLevels[1/cm]    1
        0.0  1
      Rotor  Hindered   # D8
        Geometry[angstrom]     11
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.31327
              C          0.00000       0.56904      -1.31357
              O         -0.04575      -0.87334      -1.02229
              C         -1.22354       1.16093      -1.94194
              H          0.95344       0.87113      -1.73545
              H          0.04213       0.93582       1.84745
              H         -0.03899      -0.92600       1.86726
              H         -2.12363       0.77972      -1.46359
              H         -1.25915       0.92734      -3.00595
              H         -1.20393       2.24587      -1.83304
        Group                        1   2   4   6   7   8
        Axis                         3   5
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.1106  2.3476  1.0405
      End  ! HindRot
      ZeroEnergy[kcal/mol]    0.0
  End  ! Frag1
!---------------------------------------------------
  Fragment H-TcYTcY   ! [H]
    Atom
      Mass[amu]                 1.00782503223
      ElectronicLevels[1/cm]    1
        0.0  2
  End  ! Frag2
!---------------------------------------------------
  GroundEnergy[kcal/mol]    40.69
End  ! Bimol
Bimolecular C3H4OALAD-Wv9FbZ+CH3   ! [C=CC=O + [CH3]]
!---------------------------------------------------
  Fragment C3H4OALAD-Wv9FbZ   ! C=CC=O
    RRHO
      Geometry[angstrom]        8
        C         -1.75567       0.14253       0.00004
        C         -0.56180      -0.45071      -0.00007
        H         -1.83542       1.22201       0.00006
        H         -2.67786      -0.41861       0.00013
        C          0.67267       0.34838      -0.00004
        H         -0.44709      -1.52601      -0.00008
        O          1.78974      -0.12031       0.00006
        H          0.51128       1.44392      -0.00016
      Core RigidRotor
        SymmetryFactor          1.0
      End  ! Core
      Frequencies[1/cm]         17
        320     568     603     911     983     1010
        1022    1152    1274    1362    1426    1628
        1708    2786    3018    3059    3106
      ElectronicLevels[1/cm]    1
        0.0  1
      Rotor  Hindered   # D6
        Geometry[angstrom]     8
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.32632
              H          0.00000       0.93115      -0.55562
              H         -0.00000      -0.91518      -0.57561
              C          0.00001       1.26600       2.08029
              H          0.00000      -0.91309       1.90838
              O          0.00001       1.33912       3.28041
              H          0.00001       2.17986       1.45087
        Group                        1   3   4   6
        Axis                         2   5
        Symmetry                     1
        PotentialSpline[kcal/mol]    12   11
          0.00    30.00   60.00   90.00   120.00  150.00
          180.00  210.00  240.00  270.00  300.00  330.00
          0.0000  1.8695  6.8539  9.9516  6.9141  3.4410
          2.3041  3.4411  6.9140  9.9515  6.8537  1.8694
      End  ! HindRot
      ZeroEnergy[kcal/mol]    0.0
  End  ! Frag1
!---------------------------------------------------
  Fragment CH3   ! [CH3]
    RRHO
      Geometry[angstrom]        4
        C          0.00000       0.00000       0.00000
        H          0.00000       1.07573       0.00000
        H          0.93161      -0.53787       0.00000
        H         -0.93161      -0.53787       0.00000
      Core RigidRotor
        SymmetryFactor          6.0
      End  ! Core
      Frequencies[1/cm]         6
        509     1390    1390    3001    3169    3169
      ElectronicLevels[1/cm]    1
        0.0  2
      ZeroEnergy[kcal/mol]    0.0
  End  ! Frag2
!---------------------------------------------------
  GroundEnergy[kcal/mol]    2.92
End  ! Bimol
Bimolecular C2H4OALD-UPQWKw+C2H3ALK-S58hH1   ! [CC=O + [CH]=C]
!---------------------------------------------------
  Fragment C2H4OALD-UPQWKw   ! CC=O
    RRHO
      Geometry[angstrom]        7
        C          1.16576      -0.14899      -0.00000
        C         -0.23120       0.39839       0.00000
        H          1.70098       0.22059      -0.87605
        H          1.70089       0.22037       0.87620
        H          1.15186      -1.23472      -0.00014
        O         -1.23253      -0.27579      -0.00000
        H         -0.30086       1.50370      -0.00002
      Core RigidRotor
        SymmetryFactor          1.0
      End  ! Core
      Frequencies[1/cm]         14
        504     766     879     1114    1118    1353
        1396    1434    1444    1742    2782    2916
        2974    3025
      ElectronicLevels[1/cm]    1
        0.0  1
      Rotor  Hindered   # D5
        Geometry[angstrom]     7
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.49911
              H          0.00000       1.02963      -0.36370
              H          0.91942      -0.46358      -0.36360
              H         -0.86583      -0.53321      -0.38391
              O         -0.84028      -0.51779       2.18101
              H          0.85486       0.52673       1.97023
        Group                        3   4   5
        Axis                         1   2
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  0.5592  1.2391  0.4533
      End  ! HindRot
      ZeroEnergy[kcal/mol]    0.0
  End  ! Frag1
!---------------------------------------------------
  Fragment C2H3ALK-S58hH1   ! [CH]=C
    RRHO
      Geometry[angstrom]        5
        C          0.04872       0.71828       0.00000
        C          0.04872      -0.58503       0.00000
        H         -0.67179       1.51789      -0.00000
        H         -0.87875      -1.15563      -0.00000
        H          0.96591      -1.16174       0.00000
      Core RigidRotor
        SymmetryFactor          1.0
      End  ! Core
      Frequencies[1/cm]         9
        711     817     921     1043    1371    1622
        2943    3035    3118
      ElectronicLevels[1/cm]    1
        0.0  2
      ZeroEnergy[kcal/mol]    0.0
  End  ! Frag2
!---------------------------------------------------
  GroundEnergy[kcal/mol]    15.34
End  ! Bimol
Barrier ts_1_4 C4H7ORvE4fmAA0 C4H7O4H74fm0
  RRHO
    Geometry[angstrom]        12
      C          0.70929      -0.34961      -0.36551
      C          1.97432      -0.35029       0.15997
      O         -0.10208       1.24709      -0.19034
      H          0.53659      -0.64523      -1.38855
      C         -0.49313       0.05967       0.40594
      H         -0.35355       0.03441       1.49056
      C         -1.83007      -0.49595      -0.02297
      H          2.14623      -0.03282       1.17698
      H          2.82746      -0.62899      -0.43816
      H         -2.63236       0.11663       0.38547
      H         -1.95795      -1.51567       0.33990
      H         -1.91221      -0.48802      -1.10813
    Core RigidRotor
      SymmetryFactor          0.5
    End  ! Core
    Frequencies[1/cm]         29
      210     229     282     397     492     521
      825     832     881     955     1000    1085
      1110    1196    1222    1254    1330    1375
      1409    1456    1467    1487    2896    2921
      2989    2999    3033    3077    3128
    ElectronicLevels[1/cm]    1
      0.0  2
    ZeroEnergy[kcal/mol]      5.22
    Tunneling  Eckart
      ImaginaryFrequency[1/cm]  557
      WellDepth[kcal/mol]       5.22
      WellDepth[kcal/mol]       4.53
  End
End  ! Barrier
Barrier ts_1_5 C4H7ORvE4fmAA0 C4H7O-kSV4fm
  RRHO
    Geometry[angstrom]        12
      C          0.87709      -0.21741      -0.40632
      C          2.08394      -0.28612       0.20957
      C         -0.70667       0.09340       0.50006
      H          0.57596      -0.92870      -1.16502
      O          0.06416       0.92182      -0.31338
      C         -2.01971      -0.35608      -0.02535
      H         -0.52239       0.19787       1.56085
      H          2.40860       0.49640       0.87705
      H          2.71374      -1.14858       0.06419
      H         -2.72213       0.48277      -0.07911
      H         -2.45400      -1.12084       0.61564
      H         -1.92100      -0.75623      -1.03434
    Core RigidRotor
      SymmetryFactor          0.5
    End  ! Core
    Frequencies[1/cm]         29
      167     185     231     413     504     568
      701     776     882     887     937     1018
      1093    1107    1171    1272    1338    1377
      1386    1442    1454    1500    2880    2949
      2994    3027    3036    3042    3135
    ElectronicLevels[1/cm]    1
      0.0  2
    ZeroEnergy[kcal/mol]      12.82
    Tunneling  Eckart
      ImaginaryFrequency[1/cm]  692
      WellDepth[kcal/mol]       12.82
      WellDepth[kcal/mol]       13.99
  End
End  ! Barrier
Barrier FakeB-C4H6O-RvErx50+H-TcYTcY C4H6O-RvErx50+H-TcYTcY FakeW-C4H6O-RvErx50+H-TcYTcY
  RRHO
    Stoichiometry  C4H7O1
    Core PhaseSpaceTheory
      FragmentGeometry[angstrom]    11
        C          0.72742       0.00885       0.09297
        C          1.90144      -0.57037      -0.06558
        C         -0.64042       0.09844       0.50984
        O          0.10695       1.17441      -0.21575
        C         -1.76216      -0.54091      -0.24727
        H         -0.84131       0.37604       1.53798
        H          2.06298      -1.56256       0.32119
        H          2.70423      -0.06285      -0.57653
        H         -1.46328      -0.74177      -1.27280
        H         -2.64013       0.10342      -0.25070
        H         -2.03579      -1.48361       0.22707
      FragmentGeometry[angstrom]    1
        H          0.00000       0.00000       0.00000
      SymmetryFactor                  0.5
      PotentialPrefactor[au]          10.0
      PotentialPowerExponent          6.0
      TSTLevel EJ
    End  ! Core
    Frequencies[1/cm]         26
      204     348     410     555     676     715
      800     822     931     1013    1061    1107
      1120    1208    1345    1387    1424    1456
      1465    1808    2924    2985    3003    3020
      3044    3133
    ElectronicLevels[1/cm]    1
      0.0  2
    Rotor  Hindered   # D8
      Geometry[angstrom]     11
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.31327
            C          0.00000       0.56904      -1.31357
            O         -0.04575      -0.87334      -1.02229
            C         -1.22354       1.16093      -1.94194
            H          0.95344       0.87113      -1.73545
            H          0.04213       0.93582       1.84745
            H         -0.03899      -0.92600       1.86726
            H         -2.12363       0.77972      -1.46359
            H         -1.25915       0.92734      -3.00595
            H         -1.20393       2.24587      -1.83304
      Group                        1   2   4   6   7   8
      Axis                         3   5
      Symmetry                     3
      PotentialSpline[kcal/mol]    4   3
        0.00    30.00   60.00   90.00
        0.0000  1.1106  2.3476  1.0405
    End  ! HindRot
    ZeroEnergy[kcal/mol]      40.69
End  ! Barrier
Barrier ts_1_6 C4H7ORvE4fmAA0 FakeW-C4H6O-RvErx50+H-TcYTcY
  RRHO
    Geometry[angstrom]        12
      C         -0.71018      -0.03538      -0.00197
      C         -1.97420      -0.46870      -0.07735
      C          0.63388       0.08548      -0.50955
      H         -0.38178      -1.06511       1.53556
      O         -0.09843       1.14868       0.23953
      C          1.86303      -0.46292       0.14063
      H          0.72056       0.33182      -1.56213
      H         -2.17268      -1.46323      -0.43974
      H         -2.77508       0.11089       0.35378
      H          2.70240       0.21253      -0.01739
      H          2.11441      -1.42670      -0.30273
      H          1.70438      -0.60052       1.20585
    Core RigidRotor
      SymmetryFactor          0.5
    End  ! Core
    Frequencies[1/cm]         29
      183     229     307     399     422     547
      622     659     683     798     821     932
      1011    1068    1107    1125    1209    1348
      1386    1424    1454    1459    1718    2925
      2986    3002    3022    3043    3138
    ElectronicLevels[1/cm]    1
      0.0  2
    ZeroEnergy[kcal/mol]      46.96
    Tunneling  Eckart
      ImaginaryFrequency[1/cm]  912
      WellDepth[kcal/mol]       46.96
      WellDepth[kcal/mol]       9.26
  End
End  ! Barrier
Barrier FakeB-C3H4OALAD-Wv9FbZ+CH3 C3H4OALAD-Wv9FbZ+CH3 FakeW-C3H4OALAD-Wv9FbZ+CH3
  RRHO
    Stoichiometry  C4H7O1
    Core PhaseSpaceTheory
      FragmentGeometry[angstrom]    8
        C         -1.75567       0.14253       0.00004
        C         -0.56180      -0.45071      -0.00007
        H         -1.83542       1.22201       0.00006
        H         -2.67786      -0.41861       0.00013
        C          0.67267       0.34838      -0.00004
        H         -0.44709      -1.52601      -0.00008
        O          1.78974      -0.12031       0.00006
        H          0.51128       1.44392      -0.00016
      FragmentGeometry[angstrom]    4
        C          0.00000       0.00000       0.00000
        H          0.00000       1.07573       0.00000
        H          0.93161      -0.53787       0.00000
        H         -0.93161      -0.53787       0.00000
      SymmetryFactor                  6.0
      PotentialPrefactor[au]          10.0
      PotentialPowerExponent          6.0
      TSTLevel EJ
    End  ! Core
    Frequencies[1/cm]         23
      320     568     603     911     983     1010
      1022    1152    1274    1362    1426    1628
      1708    2786    3018    3059    3106    509
      1390    1390    3001    3169    3169
    ElectronicLevels[1/cm]    1
      0.0  2
    Rotor  Hindered   # D6
      Geometry[angstrom]     8
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.32632
            H          0.00000       0.93115      -0.55562
            H         -0.00000      -0.91518      -0.57561
            C          0.00001       1.26600       2.08029
            H          0.00000      -0.91309       1.90838
            O          0.00001       1.33912       3.28041
            H          0.00001       2.17986       1.45087
      Group                        1   3   4   6
      Axis                         2   5
      Symmetry                     1
      PotentialSpline[kcal/mol]    12   11
        0.00    30.00   60.00   90.00   120.00  150.00
        180.00  210.00  240.00  270.00  300.00  330.00
        0.0000  1.8695  6.8539  9.9516  6.9141  3.4410
        2.3041  3.4411  6.9140  9.9515  6.8537  1.8694
    End  ! HindRot
    ZeroEnergy[kcal/mol]      2.92
End  ! Barrier
Barrier ts_1_7 C4H7O4H74fm0 FakeW-C3H4OALAD-Wv9FbZ+CH3
  RRHO
    Geometry[angstrom]        12
      C          2.03204       0.22082      -0.15401
      C          0.92673      -0.25955       0.40989
      H          2.03721       0.53196      -1.19105
      H          2.95963       0.30991       0.39092
      C         -0.34013      -0.44216      -0.34821
      H          0.90557      -0.59028       1.44033
      C         -1.25902       1.35546       0.11157
      O         -1.21678      -1.24032       0.02256
      H         -0.27544      -0.14183      -1.41016
      H         -2.18762       1.22423      -0.42119
      H         -1.31077       1.27641       1.18628
      H         -0.55211       2.06478      -0.29101
    Core RigidRotor
      SymmetryFactor          0.5
    End  ! Core
    Frequencies[1/cm]         27
      214     309     334     537     623     638
      668     891     926     954     1017    1037
      1141    1269    1329    1396    1407    1411
      1513    1647    2779    2976    3013    3046
      3101    3130    3133
    ElectronicLevels[1/cm]    1
      0.0  2
    Rotor  Hindered   # D6
      Geometry[angstrom]     12
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.32432
            H          0.00000       0.92966      -0.55859
            H         -0.00895      -0.91678      -0.57274
            C         -0.04477       1.25473       2.12376
            H         -0.01441      -0.91877       1.89894
            C          2.02809       1.53907       2.40054
            O         -0.43187       1.26699       3.29545
            H         -0.07433       2.18033       1.51748
            H          2.00801       2.44078       2.99473
            H          2.27798       0.62616       2.92153
            H          2.36576       1.62508       1.37728
      Group                        1   3   4   6
      Axis                         2   5
      Symmetry                     1
      PotentialSpline[kcal/mol]    12   11
        0.00    30.00   60.00   90.00   120.00  150.00
        180.00  210.00  240.00  270.00  300.00  330.00
        0.0000  1.5936  4.9687  7.1719  7.5927  4.9557
        1.5678  0.5301  2.6923  6.7487  6.1852  1.7893
    End  ! HindRot
    Rotor  Hindered   # D9
      Geometry[angstrom]     12
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.32432
            H          0.00000       0.92966      -0.55859
            H         -0.00895      -0.91678      -0.57274
            C         -0.04477       1.25473       2.12376
            H         -0.01441      -0.91877       1.89894
            C          2.02809       1.53907       2.40054
            O         -0.43187       1.26699       3.29545
            H         -0.07433       2.18033       1.51748
            H          2.00801       2.44078       2.99473
            H          2.27798       0.62616       2.92153
            H          2.36576       1.62508       1.37728
      Group                        1   2   3   4   6   8   9
      Axis                         5   7
      Symmetry                     3
      PotentialSpline[kcal/mol]    4   3
        0.00    30.00   60.00   90.00
        0.0000  0.8022  1.5728  0.7094
    End  ! HindRot
    ZeroEnergy[kcal/mol]      13.21
    Tunneling  Eckart
      ImaginaryFrequency[1/cm]  491
      WellDepth[kcal/mol]       12.52
      WellDepth[kcal/mol]       13.29
  End
End  ! Barrier
Barrier FakeB-C2H4OALD-UPQWKw+C2H3ALK-S58hH1 C2H4OALD-UPQWKw+C2H3ALK-S58hH1 FakeW-C2H4OALD-UPQWKw+C2H3ALK-S58hH1
  RRHO
    Stoichiometry  C4H7O1
    Core PhaseSpaceTheory
      FragmentGeometry[angstrom]    7
        C          1.16576      -0.14899      -0.00000
        C         -0.23120       0.39839       0.00000
        H          1.70098       0.22059      -0.87605
        H          1.70089       0.22037       0.87620
        H          1.15186      -1.23472      -0.00014
        O         -1.23253      -0.27579      -0.00000
        H         -0.30086       1.50370      -0.00002
      FragmentGeometry[angstrom]    5
        C          0.04872       0.71828       0.00000
        C          0.04872      -0.58503       0.00000
        H         -0.67179       1.51789      -0.00000
        H         -0.87875      -1.15563      -0.00000
        H          0.96591      -1.16174       0.00000
      SymmetryFactor                  1.0
      PotentialPrefactor[au]          10.0
      PotentialPowerExponent          6.0
      TSTLevel EJ
    End  ! Core
    Frequencies[1/cm]         23
      504     766     879     1114    1118    1353
      1396    1434    1444    1742    2782    2916
      2974    3025    711     817     921     1043
      1371    1622    2943    3035    3118
    ElectronicLevels[1/cm]    1
      0.0  2
    Rotor  Hindered   # D5
      Geometry[angstrom]     7
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.49911
            H          0.00000       1.02963      -0.36370
            H          0.91942      -0.46358      -0.36360
            H         -0.86583      -0.53321      -0.38391
            O         -0.84028      -0.51779       2.18101
            H          0.85486       0.52673       1.97023
      Group                        3   4   5
      Axis                         1   2
      Symmetry                     3
      PotentialSpline[kcal/mol]    4   3
        0.00    30.00   60.00   90.00
        0.0000  0.5592  1.2391  0.4533
    End  ! HindRot
    ZeroEnergy[kcal/mol]      15.34
End  ! Barrier
Barrier ts_1_8 C4H7O4H74fm0 FakeW-C2H4OALD-UPQWKw+C2H3ALK-S58hH1
  RRHO
    Geometry[angstrom]        12
      C          2.08607       0.02667      -0.19969
      C          1.10095      -0.72780       0.20199
      H          1.93084       1.07450      -0.41725
      H          3.08400      -0.38254      -0.32378
      C         -0.76658       0.26289       0.40817
      H          0.96655      -1.75990       0.48040
      C         -1.66038      -0.74005      -0.28700
      O         -0.52566       1.36891      -0.07638
      H         -0.63106       0.10046       1.49430
      H         -1.52292      -1.74929       0.09619
      H         -2.69538      -0.44725      -0.09994
      H         -1.48708      -0.71756      -1.35971
    Core RigidRotor
      SymmetryFactor          0.5
    End  ! Core
    Frequencies[1/cm]         27
      193     243     341     426     497     792
      814     831     890     942     1020    1081
      1105    1344    1355    1366    1443    1447
      1582    1631    2768    2917    2980    2981
      3016    3075    3104
    ElectronicLevels[1/cm]    1
      0.0  2
    Rotor  Hindered   # D6
      Geometry[angstrom]     12
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.30038
            H          0.00000       0.92947      -0.55668
            H         -0.00030      -0.93245      -0.55785
            C          0.02898       1.94561       2.22673
            H         -0.00040      -0.74321       2.08234
            C         -1.04084       1.73770       3.27411
            O         -0.13579       2.68622       1.26484
            H          1.05672       1.67300       2.53727
            H         -0.86834       0.83928       3.86535
            H         -1.01611       2.59529       3.95046
            H         -2.02285       1.69799       2.80724
      Group                        1   3   4   6
      Axis                         2   5
      Symmetry                     1
      PotentialSpline[kcal/mol]    12   11
        0.00    30.00   60.00   90.00   120.00  150.00
        180.00  210.00  240.00  270.00  300.00  330.00
        0.0000  0.4713  1.2137  1.2376  1.1356  1.2116
        1.2620  0.9709  1.0080  1.6960  1.2601  0.3796
    End  ! HindRot
    Rotor  Hindered   # D9
      Geometry[angstrom]     12
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.30038
            H          0.00000       0.92947      -0.55668
            H         -0.00030      -0.93245      -0.55785
            C          0.02898       1.94561       2.22673
            H         -0.00040      -0.74321       2.08234
            C         -1.04084       1.73770       3.27411
            O         -0.13579       2.68622       1.26484
            H          1.05672       1.67300       2.53727
            H         -0.86834       0.83928       3.86535
            H         -1.01611       2.59529       3.95046
            H         -2.02285       1.69799       2.80724
      Group                        1   2   3   4   6   8   9
      Axis                         5   7
      Symmetry                     3
      PotentialSpline[kcal/mol]    4   3
        0.00    30.00   60.00   90.00
        0.0000  1.1120  2.0695  0.8873
    End  ! HindRot
    ZeroEnergy[kcal/mol]      20.20
    Tunneling  Eckart
      ImaginaryFrequency[1/cm]  392
      WellDepth[kcal/mol]       19.50
      WellDepth[kcal/mol]       7.85
  End
End  ! Barrier
Barrier ts_1_9 C4H7O-kSV4fm FakeW-C2H4OALD-UPQWKw+C2H3ALK-S58hH1
  RRHO
    Geometry[angstrom]        12
      C          1.82147       0.82777       0.13516
      C          1.60394      -0.37936      -0.30264
      H          1.02738       1.38225       0.63204
      H          2.77811       1.32882       0.03527
      O         -0.18123      -1.05618       0.04050
      H          2.14310      -1.16305      -0.80014
      C         -1.00401      -0.24445       0.50589
      C         -1.92044       0.56738      -0.35315
      H         -1.03454      -0.06554       1.58866
      H         -2.95157       0.46544      -0.01035
      H         -1.84642       0.24350      -1.38780
      H         -1.67194       1.63008      -0.29321
    Core RigidRotor
      SymmetryFactor          1.0
    End  ! Core
    Frequencies[1/cm]         29
      49      70      114     190     370     406
      501     731     761     865     882     919
      1033    1043    1105    1322    1362    1364
      1427    1442    1499    1628    2871    2901
      2947    2952    3012    3022    3149
    ElectronicLevels[1/cm]    1
      0.0  2
    ZeroEnergy[kcal/mol]      28.82
    Tunneling  Eckart
      ImaginaryFrequency[1/cm]  616
      WellDepth[kcal/mol]       29.99
      WellDepth[kcal/mol]       16.48
  End
End  ! Barrier
End  ! Model
!
!===================================================
!  END MASTER EQUATION MODEL
!===================================================

User requested well extension scheme for rates...
  - Running MESS base job at path /lcrc/project/PACC/AutoMech/data/run/MESS/RATE/C4H7O1_1_1/basev1
  - Reading input and output from base MESSRATE job at /lcrc/project/PACC/AutoMech/data/run/MESS/RATE/C4H7O1_1_1/basev1
  - Setting up the well-extended MESSRATE input

***********************************************

Obtaining information for well W1 at P=1.0
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (1010000000.0, 3390000000.0, 8440000000.0, 17200000000.0, 30500000000.0, 48600000000.0, 71800000000.0, 99900000000.0, 133000000000.0, 170000000000.0, 211000000000.0, 255000000000.0, 303000000000.0, 353000000000.0, 406000000000.0))
- New max temperature for well: 300.0 K
- from reaction W1->W2
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (5020.0, 103000.0, 1010000.0, 6010000.0, 25300000.0, 82200000.0, 221000000.0, 510000000.0, 1050000000.0, 1960000000.0, 3410000000.0, 5550000000.0, 8570000000.0, 12700000000.0, 18000000000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (8.47e-22, 5.67e-17, 2.49e-13, 1.76e-10, 3.41e-08, 2.58e-06, 9.62e-05, 0.00208, 0.0291, 0.289, 2.17, 12.9, 63.3, 263.0, 954.0))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

Max temperature for energies is 300.0 K

***********************************************

Obtaining information for well W2 at P=1.0
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (581000000.0, 1640000000.0, 3600000000.0, 6690000000.0, 11000000000.0, 16700000000.0, 23800000000.0, 32100000000.0, 41700000000.0, 52400000000.0, 64300000000.0, 77100000000.0, 90900000000.0, 105000000000.0, 121000000000.0))
- New max temperature for well: 300.0 K
- from reaction W2->W1
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
- New max temperature for well: 500.0 K
- from reaction W2->W3
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (5800.0, 137000.0, 1510000.0, 10000000.0, 46000000.0, 162000000.0, 468000000.0, 1160000000.0, 2520000000.0, 4970000000.0, 9050000000.0, 15400000000.0, 24800000000.0, 38000000000.0, 56000000000.0))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (0.0824, 11.4, 476.0, 8820.0, 92200.0, 634000.0, 3170000.0, 12500000.0, 40300000.0, 112000000.0, 274000000.0, 603000000.0, 1220000000.0, 2290000000.0, 4040000000.0))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

Max temperature for energies is 500.0 K

***********************************************

Obtaining information for well W3 at P=1.0
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (77.7, 1850.0, 20300.0, 131000.0, 587000.0, 2010000.0, 5650000.0, 13600000.0, 28900000.0, 56000000.0, 100000000.0, 168000000.0, 267000000.0, 404000000.0, 590000000.0))
- New max temperature for well: 300.0 K
- from reaction W3->W1
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
- New max temperature for well: 500.0 K
- from reaction W3->W2
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (1.72e-09, 2.43e-06, 0.000576, 0.0411, 1.27, 21.2, 223.0, 1650.0, 9230.0, 41300.0, 154000.0, 493000.0, 1400000.0, 3550000.0, 8270000.0))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
- New max temperature for well: 600.0 K
- from reaction W3->P1
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

Max temperature for energies is 600.0 K

***********************************************

Obtaining information for well W4 at P=1.0
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (1400.0, 8090.0, 30900.0, 88900.0, 209000.0, 421000.0, 759000.0, 1250000.0, 1930000.0, 2820000.0, 3930000.0, 5270000.0, 6860000.0, 8700000.0, 10800000.0))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
- New max temperature for well: 300.0 K
- from reaction W4->W1
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (2340000000.0, 3980000000.0, 5800000000.0, 7630000000.0, 9360000000.0, 10900000000.0, 12300000000.0, 13500000000.0, 14500000000.0, 15300000000.0, 16000000000.0, 16600000000.0, 17000000000.0, 17300000000.0, 17500000000.0))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output

Max temperature for energies is 300.0 K

***********************************************

Obtaining information for well W5 at P=1.0
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
- New max temperature for well: 300.0 K
- from reaction W5->W1
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (0.664, 10.5, 80.8, 388.0, 1340.0, 3670.0, 8410.0, 16800.0, 30400.0, 50400.0, 78300.0, 115000.0, 162000.0, 218000.0, 286000.0))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (17400000000.0, 24800000000.0, 30700000000.0, 34800000000.0, 37400000000.0, 38600000000.0, 38700000000.0, 38200000000.0, 37100000000.0, 35800000000.0, 34200000000.0, 32500000000.0, 30900000000.0, 29200000000.0, 27500000000.0))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output

Max temperature for energies is 300.0 K

***********************************************

Obtaining information for well W6 at P=1.0
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
- New max temperature for well: 300.0 K
- from reaction W6->W1
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (1760.0, 9170.0, 31500.0, 82400.0, 177000.0, 332000.0, 558000.0, 865000.0, 1260000.0, 1740000.0, 2300000.0, 2950000.0, 3670000.0, 4450000.0, 5300000.0))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (0.00137, 0.0521, 0.806, 6.84, 38.1, 156.0, 508.0, 1380.0, 3280.0, 6940.0, 13400.0, 24100.0, 40500.0, 64700.0, 98600.0))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (68900000000.0, 97900000000.0, 121000000000.0, 138000000000.0, 147000000000.0, 152000000000.0, 153000000000.0, 151000000000.0, 147000000000.0, 141000000000.0, 135000000000.0, 128000000000.0, 122000000000.0, 115000000000.0, 109000000000.0))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output

Max temperature for energies is 300.0 K
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Writing New Well-Extended MESS input file at path /lcrc/project/PACC/AutoMech/data/run/MESS/RATE/C4H7O1_1_1/basev1
  - Warning, old base input overwritten.
Debug:  MESS Input:

!===================================================
!  GLOBAL KEYWORDS
!===================================================
TemperatureList[K]                     300.0  350.0  400.0  450.0  500.0  550.0  600.0  650.0  700.0  750.0  800.0  850.0  900.0  950.0  1000.0
PressureList[atm]                      0.01  0.03  0.1  0.3  1.0  3.0  10.0  30.0  100.0
!
ModelEnergyLimit[kcal/mol]             800.00
EnergyStepOverTemperature              0.20
!
CalculationMethod                      direct
!
WellCutoff                             10
WellExtension                          0.0010
!
ChemicalEigenvalueMax                  0.20
!
ReductionMethod                        diagonalization
!
HotEnergies[kcal/mol]                  1
C4H7ORvE4fmAA0 0.0:1.0:289.5
!
MicroRateOutput                        ke.out
MicroEnerMin[kcal/mol]                 0.1
MicroEnerMax[kcal/mol]                 289.4530789778327
MicroEnerStep[kcal/mol]                0.1
!
AtomDistanceMin[angstrom]              0.68793
!
RateOutput                             rate.out
!
!
!===================================================
!  BEGIN MASTER EQUATION MODEL
!===================================================
!
ExtensionCorrection    0.6
Model
!
GroundEnergyShiftMax[kcal/mol]  10
!
UseShortNames
!
!---------------------------------------------------
!  ENERGY TRANSFER SECTION
!---------------------------------------------------
  EnergyRelaxation
    Exponential
       Factor[1/cm]                     267.672
       Power                            0.675
       ExponentCutoff                   15.000
  End  ! EneRelax
  CollisionFrequency
    LennardJones
       Epsilons[1/cm]                   165.902    165.902
       Sigmas[angstrom]                 4.601      4.601
       Masses[amu]                      71.050     39.962
  End  ! CollidFreq
!---------------------------------------------------
!  REACTION CHANNELS SECTION
!---------------------------------------------------
Well C4H7ORvE4fmAA0   ! [[CH2][C@H]1[C@H](C)O1]
  WellExtensionCap[kcal/mol]    3.10
  Species
    RRHO
      Geometry[angstrom]        12
        C          0.66636      -0.17413      -0.40397
        C          1.98338      -0.39696       0.14653
        C         -0.53894      -0.02155       0.44414
        H          0.49187      -0.52500      -1.41434
        O          0.05448       1.13100      -0.14121
        C         -1.90277      -0.40553      -0.04841
        H         -0.38603      -0.09237       1.51741
        H          2.24763       0.03973       1.09620
        H          2.71463      -0.98005      -0.38760
        H         -2.65917       0.25189       0.37975
        H         -2.14006      -1.42924       0.24073
        H         -1.95294      -0.32398      -1.13223
      Core RigidRotor
        SymmetryFactor          1.0
      End  ! Core
      Frequencies[1/cm]         28
        247     287     451     464     549     699
        812     882     964     1025    1057    1133
        1144    1164    1232    1337    1380    1414
        1446    1455    1467    2919    2976    2982
        3001    3010    3042    3145
      ElectronicLevels[1/cm]    1
        0.0  2
      Rotor  Hindered   # D7
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.44559
              C          0.00000       1.24745      -0.79839
              H         -0.42947      -0.87132      -0.48562
              O          1.18318       0.49653      -0.65920
              C         -0.61408       1.31351      -2.16545
              H          0.00362       2.18059      -0.23902
              H          0.54715       0.76113       1.98232
              H         -0.53462      -0.75686       1.99812
              H         -0.05864       2.00835      -2.79651
              H         -1.64590       1.66091      -2.10385
              H         -0.59969       0.33346      -2.64082
        Group                        3   4   5   6   7   10  11  12
        Axis                         1   2
        Symmetry                     1
        PotentialSpline[kcal/mol]    12   11
          0.00    30.00   60.00   90.00   120.00  150.00
          180.00  210.00  240.00  270.00  300.00  330.00
          0.0000  1.1975  3.9796  5.4028  3.5627  0.8968
          0.0002  0.7866  3.2526  5.3325  3.4394  1.1154
      End  ! HindRot
      Rotor  Hindered   # D9
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.44559
              C          0.00000       1.24745      -0.79839
              H         -0.42947      -0.87132      -0.48562
              O          1.18318       0.49653      -0.65920
              C         -0.61408       1.31351      -2.16545
              H          0.00362       2.18059      -0.23902
              H          0.54715       0.76113       1.98232
              H         -0.53462      -0.75686       1.99812
              H         -0.05864       2.00835      -2.79651
              H         -1.64590       1.66091      -2.10385
              H         -0.59969       0.33346      -2.64082
        Group                        1   2   4   5   7   8   9
        Axis                         3   6
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.3355  2.9126  1.3504
      End  ! HindRot
      ZeroEnergy[kcal/mol]      0.00
  End  ! Species
    EnergyRelaxation
      Exponential
         Factor[1/cm]                     267.672
         Power                            0.675
         ExponentCutoff                   15.000
    End  ! EneRelax
    CollisionFrequency
      LennardJones
         Epsilons[1/cm]                   165.902    165.902
         Sigmas[angstrom]                 4.601      4.601
         Masses[amu]                      71.050     39.962
    End  ! CollidFreq
End  ! Well
Well C4H7O4H74fm0   ! [C=C[C@H](C)[O]]
  WellExtensionCap[kcal/mol]    7.90
  Species
    RRHO
      Geometry[angstrom]        12
        C          1.92181      -0.01641      -0.29413
        C          0.88159      -0.57253       0.31436
        H          1.84502       0.96923      -0.72874
        H          2.86747      -0.53159      -0.36973
        C         -0.47007       0.07947       0.44927
        H          0.96613      -1.55945       0.75571
        C         -1.54085      -0.69258      -0.36769
        O         -0.53470       1.36617      -0.01172
        H         -0.80164       0.04761       1.49754
        H         -2.52406      -0.25963      -0.20740
        H         -1.54115      -1.73016      -0.04041
        H         -1.28908      -0.65307      -1.42414
      Core RigidRotor
        SymmetryFactor          0.5
      End  ! Core
      Frequencies[1/cm]         28
        275     332     365     588     649     805
        885     948     954     1014    1021    1036
        1100    1219    1288    1330    1358    1411
        1449    1470    1654    2833    2933    3011
        3017    3023    3032    3113
      ElectronicLevels[1/cm]    1
        0.0  2
      Rotor  Hindered   # D6
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.32110
              H          0.00000       0.92952      -0.55412
              H          0.00149      -0.92353      -0.56210
              C         -0.01106       1.24493       2.17242
              H          0.00523      -0.93600       1.87140
              C         -1.31911       1.33781       3.00293
              O          0.07924       2.41531       1.48972
              H          0.80663       1.19854       2.91119
              H         -1.28249       2.19438       3.67145
              H         -1.42610       0.42398       3.58556
              H         -2.17017       1.43167       2.33144
        Group                        1   3   4   6
        Axis                         2   5
        Symmetry                     1
        PotentialSpline[kcal/mol]    12   11
          0.00    30.00   60.00   90.00   120.00  150.00
          180.00  210.00  240.00  270.00  300.00  330.00
          0.0000  0.3412  1.8945  1.4039  0.0000  0.3596
          1.4012  0.9421  0.3139  1.3925  2.9508  0.9794
      End  ! HindRot
      Rotor  Hindered   # D9
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.32110
              H          0.00000       0.92952      -0.55412
              H          0.00149      -0.92353      -0.56210
              C         -0.01106       1.24493       2.17242
              H          0.00523      -0.93600       1.87140
              C         -1.31911       1.33781       3.00293
              O          0.07924       2.41531       1.48972
              H          0.80663       1.19854       2.91119
              H         -1.28249       2.19438       3.67145
              H         -1.42610       0.42398       3.58556
              H         -2.17017       1.43167       2.33144
        Group                        1   2   3   4   6   8   9
        Axis                         5   7
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.4563  3.0346  1.5339
      End  ! HindRot
      ZeroEnergy[kcal/mol]      0.69
  End  ! Species
    EnergyRelaxation
      Exponential
         Factor[1/cm]                     402.815
         Power                            0.602
         ExponentCutoff                   15.000
    End  ! EneRelax
    CollisionFrequency
      LennardJones
         Epsilons[1/cm]                   165.902    165.902
         Sigmas[angstrom]                 4.601      4.601
         Masses[amu]                      71.050     39.962
    End  ! CollidFreq
End  ! Well
Well C4H7O-kSV4fm   ! [C=CO[CH]C]
  WellExtensionCap[kcal/mol]    11.80
  Species
    RRHO
      Geometry[angstrom]        12
        C          2.27851      -0.21273       0.04621
        C          0.95978      -0.32110      -0.07900
        H          2.74809       0.73971       0.23554
        H          2.89295      -1.09268      -0.04236
        O          0.15061       0.76820       0.02630
        H          0.47033      -1.26407      -0.27149
        C         -1.20683       0.64838      -0.12793
        C         -1.91169      -0.64303       0.06641
        H         -1.68817       1.59012       0.07473
        H         -2.98329      -0.46062       0.03693
        H         -1.67711      -1.10910       1.03146
        H         -1.68631      -1.37810      -0.70931
      Core RigidRotor
        SymmetryFactor          1.0
      End  ! Core
      Frequencies[1/cm]         27
        239     398     485     594     697     839
        847     958     964     997     1104    1142
        1274    1320    1360    1396    1406    1443
        1465    1653    2860    2919    2995    3046
        3073    3093    3138
      ElectronicLevels[1/cm]    1
        0.0  2
      Rotor  Hindered   # D6
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.32437
              H          0.00000       0.92163      -0.56361
              H          0.00085      -0.93840      -0.53134
              O         -0.00004       1.15566       2.02817
              H         -0.00233      -0.91503       1.90219
              C         -0.02491       1.15767       3.39000
              C          0.34395      -0.02962       4.19606
              H          0.06965       2.16166       3.77145
              H          0.38377       0.26020       5.24422
              H          1.32679      -0.43644       3.92327
              H         -0.37779      -0.84822       4.11254
        Group                        1   3   4   6
        Axis                         2   5
        Symmetry                     1
        PotentialSpline[kcal/mol]    12   11
          0.00    30.00   60.00   90.00   120.00  150.00
          180.00  210.00  240.00  270.00  300.00  330.00
          0.0000  0.4575  1.7308  3.1244  3.6427  3.2671
          2.5242  2.1012  2.4620  3.1972  1.9974  0.5563
      End  ! HindRot
      Rotor  Hindered   # D7
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.32437
              H          0.00000       0.92163      -0.56361
              H          0.00085      -0.93840      -0.53134
              O         -0.00004       1.15566       2.02817
              H         -0.00233      -0.91503       1.90219
              C         -0.02491       1.15767       3.39000
              C          0.34395      -0.02962       4.19606
              H          0.06965       2.16166       3.77145
              H          0.38377       0.26020       5.24422
              H          1.32679      -0.43644       3.92327
              H         -0.37779      -0.84822       4.11254
        Group                        1   2   3   4   6
        Axis                         5   7
        Symmetry                     1
        PotentialSpline[kcal/mol]    12   11
          0.00    30.00   60.00   90.00   120.00  150.00
          180.00  210.00  240.00  270.00  300.00  330.00
          0.0000  0.4151  1.6993  1.6692  0.0000  0.0000
          0.0000  0.3243  2.3528  1.1501  0.5245  0.3223
      End  ! HindRot
      Rotor  Hindered   # D9
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.32437
              H          0.00000       0.92163      -0.56361
              H          0.00085      -0.93840      -0.53134
              O         -0.00004       1.15566       2.02817
              H         -0.00233      -0.91503       1.90219
              C         -0.02491       1.15767       3.39000
              C          0.34395      -0.02962       4.19606
              H          0.06965       2.16166       3.77145
              H          0.38377       0.26020       5.24422
              H          1.32679      -0.43644       3.92327
              H         -0.37779      -0.84822       4.11254
        Group                        1   2   3   4   5   6   9
        Axis                         7   8
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.1453  2.3475  1.1802
      End  ! HindRot
      ZeroEnergy[kcal/mol]      -1.17
  End  ! Species
    EnergyRelaxation
      Exponential
         Factor[1/cm]                     402.815
         Power                            0.602
         ExponentCutoff                   15.000
    End  ! EneRelax
    CollisionFrequency
      LennardJones
         Epsilons[1/cm]                   165.902    165.902
         Sigmas[angstrom]                 4.601      4.601
         Masses[amu]                      71.050     39.962
    End  ! CollidFreq
End  ! Well
Well FakeW-C4H6O-RvErx50+H-TcYTcY   ! Fake Well for C4H6O-RvErx50+H-TcYTcY
  WellExtensionCap[kcal/mol]    4.30
  Species
    RRHO
      Geometry[angstrom]        12
        C          0.69607      -0.03882       0.09276
        C          1.87010      -0.61804      -0.06579
        C         -0.67176       0.05077       0.50963
        O          0.07561       1.12674      -0.21596
        C         -1.79350      -0.58859      -0.24748
        H         -0.87266       0.32837       1.53777
        H          2.03163      -1.61023       0.32098
        H          2.67289      -0.11052      -0.57674
        H         -1.49463      -0.78944      -1.27301
        H         -2.67147       0.05575      -0.25091
        H         -2.06713      -1.53128       0.22686
        H          0.00000       0.00000       4.43193
      Core RigidRotor
        SymmetryFactor          0.5
      End  ! Core
      Frequencies[1/cm]         29
        10      20      30      204     348     410
        555     676     715     800     822     931
        1013    1061    1107    1120    1208    1345
        1387    1424    1456    1465    1808    2924
        2985    3003    3020    3044    3133
      ElectronicLevels[1/cm]    1
        0.0  2
      Rotor  Hindered   # D8
        Geometry[angstrom]     11
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.31327
              C          0.00000       0.56904      -1.31357
              O         -0.04575      -0.87334      -1.02229
              C         -1.22354       1.16093      -1.94194
              H          0.95344       0.87113      -1.73545
              H          0.04213       0.93582       1.84745
              H         -0.03899      -0.92600       1.86726
              H         -2.12363       0.77972      -1.46359
              H         -1.25915       0.92734      -3.00595
              H         -1.20393       2.24587      -1.83304
        Group                        1   2   4   6   7   8
        Axis                         3   5
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.1106  2.3476  1.0405
      End  ! HindRot
      ZeroEnergy[kcal/mol]      37.69
  End  ! Species
End  ! Well
Well FakeW-C3H4OALAD-Wv9FbZ+CH3   ! Fake Well for C3H4OALAD-Wv9FbZ+CH3
  WellExtensionCap[kcal/mol]    5.40
  Species
    RRHO
      Geometry[angstrom]        12
        C         -1.83430       0.15529       0.00004
        C         -0.64043      -0.43795      -0.00007
        H         -1.91404       1.23477       0.00006
        H         -2.75648      -0.40584       0.00013
        C          0.59404       0.36114      -0.00004
        H         -0.52572      -1.51324      -0.00008
        O          1.71111      -0.10754       0.00006
        H          0.43265       1.45668      -0.00016
        C          0.00000      -0.00000       3.00013
        H          0.00000       1.07573       3.00013
        H          0.93161      -0.53787       3.00013
        H         -0.93161      -0.53787       3.00013
      Core RigidRotor
        SymmetryFactor          6.0
      End  ! Core
      Frequencies[1/cm]         29
        10      20      30      40      50      60
        320     568     603     911     983     1010
        1022    1152    1274    1362    1426    1628
        1708    2786    3018    3059    3106    509
        1390    1390    3001    3169    3169
      ElectronicLevels[1/cm]    1
        0.0  2
      Rotor  Hindered   # D6
        Geometry[angstrom]     8
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.32632
              H          0.00000       0.93115      -0.55562
              H         -0.00000      -0.91518      -0.57561
              C          0.00001       1.26600       2.08029
              H          0.00000      -0.91309       1.90838
              O          0.00001       1.33912       3.28041
              H          0.00001       2.17986       1.45087
        Group                        1   3   4   6
        Axis                         2   5
        Symmetry                     1
        PotentialSpline[kcal/mol]    12   11
          0.00    30.00   60.00   90.00   120.00  150.00
          180.00  210.00  240.00  270.00  300.00  330.00
          0.0000  1.8695  6.8539  9.9516  6.9141  3.4410
          2.3041  3.4411  6.9140  9.9515  6.8537  1.8694
      End  ! HindRot
      ZeroEnergy[kcal/mol]      -0.08
  End  ! Species
End  ! Well
Well FakeW-C2H4OALD-UPQWKw+C2H3ALK-S58hH1   ! Fake Well for C2H4OALD-UPQWKw+C2H3ALK-S58hH1
  WellExtensionCap[kcal/mol]    5.10
  Species
    RRHO
      Geometry[angstrom]        12
        C          1.26146      -0.13303      -0.00000
        C         -0.13550       0.41436       0.00000
        H          1.79668       0.23656      -0.87605
        H          1.79659       0.23634       0.87620
        H          1.24756      -1.21875      -0.00014
        O         -1.13683      -0.25982      -0.00000
        H         -0.20516       1.51966      -0.00002
        C          0.02725       0.68893       3.39994
        C          0.02725      -0.61439       3.39994
        H         -0.69326       1.48854       3.39994
        H         -0.90022      -1.18499       3.39994
        H          0.94444      -1.19109       3.39994
      Core RigidRotor
        SymmetryFactor          1.0
      End  ! Core
      Frequencies[1/cm]         29
        10      20      30      40      50      60
        504     766     879     1114    1118    1353
        1396    1434    1444    1742    2782    2916
        2974    3025    711     817     921     1043
        1371    1622    2943    3035    3118
      ElectronicLevels[1/cm]    1
        0.0  2
      Rotor  Hindered   # D5
        Geometry[angstrom]     7
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.49911
              H          0.00000       1.02963      -0.36370
              H          0.91942      -0.46358      -0.36360
              H         -0.86583      -0.53321      -0.38391
              O         -0.84028      -0.51779       2.18101
              H          0.85486       0.52673       1.97023
        Group                        3   4   5
        Axis                         1   2
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  0.5592  1.2391  0.4533
      End  ! HindRot
      ZeroEnergy[kcal/mol]      12.34
  End  ! Species
End  ! Well
Bimolecular C4H6O-RvErx50+H-TcYTcY   ! [C=C1[C@H](C)O1 + [H]]
!---------------------------------------------------
  Fragment C4H6O-RvErx50   ! C=C1[C@H](C)O1
    RRHO
      Geometry[angstrom]        11
        C          0.72742       0.00885       0.09297
        C          1.90144      -0.57037      -0.06558
        C         -0.64042       0.09844       0.50984
        O          0.10695       1.17441      -0.21575
        C         -1.76216      -0.54091      -0.24727
        H         -0.84131       0.37604       1.53798
        H          2.06298      -1.56256       0.32119
        H          2.70423      -0.06285      -0.57653
        H         -1.46328      -0.74177      -1.27280
        H         -2.64013       0.10342      -0.25070
        H         -2.03579      -1.48361       0.22707
      Core RigidRotor
        SymmetryFactor          0.5
      End  ! Core
      Frequencies[1/cm]         26
        204     348     410     555     676     715
        800     822     931     1013    1061    1107
        1120    1208    1345    1387    1424    1456
        1465    1808    2924    2985    3003    3020
        3044    3133
      ElectronicLevels[1/cm]    1
        0.0  1
      Rotor  Hindered   # D8
        Geometry[angstrom]     11
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.31327
              C          0.00000       0.56904      -1.31357
              O         -0.04575      -0.87334      -1.02229
              C         -1.22354       1.16093      -1.94194
              H          0.95344       0.87113      -1.73545
              H          0.04213       0.93582       1.84745
              H         -0.03899      -0.92600       1.86726
              H         -2.12363       0.77972      -1.46359
              H         -1.25915       0.92734      -3.00595
              H         -1.20393       2.24587      -1.83304
        Group                        1   2   4   6   7   8
        Axis                         3   5
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.1106  2.3476  1.0405
      End  ! HindRot
      ZeroEnergy[kcal/mol]    0.0
  End  ! Frag1
!---------------------------------------------------
  Fragment H-TcYTcY   ! [H]
    Atom
      Mass[amu]                 1.00782503223
      ElectronicLevels[1/cm]    1
        0.0  2
  End  ! Frag2
!---------------------------------------------------
  GroundEnergy[kcal/mol]    40.69
End  ! Bimol
Bimolecular C3H4OALAD-Wv9FbZ+CH3   ! [C=CC=O + [CH3]]
!---------------------------------------------------
  Fragment C3H4OALAD-Wv9FbZ   ! C=CC=O
    RRHO
      Geometry[angstrom]        8
        C         -1.75567       0.14253       0.00004
        C         -0.56180      -0.45071      -0.00007
        H         -1.83542       1.22201       0.00006
        H         -2.67786      -0.41861       0.00013
        C          0.67267       0.34838      -0.00004
        H         -0.44709      -1.52601      -0.00008
        O          1.78974      -0.12031       0.00006
        H          0.51128       1.44392      -0.00016
      Core RigidRotor
        SymmetryFactor          1.0
      End  ! Core
      Frequencies[1/cm]         17
        320     568     603     911     983     1010
        1022    1152    1274    1362    1426    1628
        1708    2786    3018    3059    3106
      ElectronicLevels[1/cm]    1
        0.0  1
      Rotor  Hindered   # D6
        Geometry[angstrom]     8
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.32632
              H          0.00000       0.93115      -0.55562
              H         -0.00000      -0.91518      -0.57561
              C          0.00001       1.26600       2.08029
              H          0.00000      -0.91309       1.90838
              O          0.00001       1.33912       3.28041
              H          0.00001       2.17986       1.45087
        Group                        1   3   4   6
        Axis                         2   5
        Symmetry                     1
        PotentialSpline[kcal/mol]    12   11
          0.00    30.00   60.00   90.00   120.00  150.00
          180.00  210.00  240.00  270.00  300.00  330.00
          0.0000  1.8695  6.8539  9.9516  6.9141  3.4410
          2.3041  3.4411  6.9140  9.9515  6.8537  1.8694
      End  ! HindRot
      ZeroEnergy[kcal/mol]    0.0
  End  ! Frag1
!---------------------------------------------------
  Fragment CH3   ! [CH3]
    RRHO
      Geometry[angstrom]        4
        C          0.00000       0.00000       0.00000
        H          0.00000       1.07573       0.00000
        H          0.93161      -0.53787       0.00000
        H         -0.93161      -0.53787       0.00000
      Core RigidRotor
        SymmetryFactor          6.0
      End  ! Core
      Frequencies[1/cm]         6
        509     1390    1390    3001    3169    3169
      ElectronicLevels[1/cm]    1
        0.0  2
      ZeroEnergy[kcal/mol]    0.0
  End  ! Frag2
!---------------------------------------------------
  GroundEnergy[kcal/mol]    2.92
End  ! Bimol
Bimolecular C2H4OALD-UPQWKw+C2H3ALK-S58hH1   ! [CC=O + [CH]=C]
!---------------------------------------------------
  Fragment C2H4OALD-UPQWKw   ! CC=O
    RRHO
      Geometry[angstrom]        7
        C          1.16576      -0.14899      -0.00000
        C         -0.23120       0.39839       0.00000
        H          1.70098       0.22059      -0.87605
        H          1.70089       0.22037       0.87620
        H          1.15186      -1.23472      -0.00014
        O         -1.23253      -0.27579      -0.00000
        H         -0.30086       1.50370      -0.00002
      Core RigidRotor
        SymmetryFactor          1.0
      End  ! Core
      Frequencies[1/cm]         14
        504     766     879     1114    1118    1353
        1396    1434    1444    1742    2782    2916
        2974    3025
      ElectronicLevels[1/cm]    1
        0.0  1
      Rotor  Hindered   # D5
        Geometry[angstrom]     7
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.49911
              H          0.00000       1.02963      -0.36370
              H          0.91942      -0.46358      -0.36360
              H         -0.86583      -0.53321      -0.38391
              O         -0.84028      -0.51779       2.18101
              H          0.85486       0.52673       1.97023
        Group                        3   4   5
        Axis                         1   2
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  0.5592  1.2391  0.4533
      End  ! HindRot
      ZeroEnergy[kcal/mol]    0.0
  End  ! Frag1
!---------------------------------------------------
  Fragment C2H3ALK-S58hH1   ! [CH]=C
    RRHO
      Geometry[angstrom]        5
        C          0.04872       0.71828       0.00000
        C          0.04872      -0.58503       0.00000
        H         -0.67179       1.51789      -0.00000
        H         -0.87875      -1.15563      -0.00000
        H          0.96591      -1.16174       0.00000
      Core RigidRotor
        SymmetryFactor          1.0
      End  ! Core
      Frequencies[1/cm]         9
        711     817     921     1043    1371    1622
        2943    3035    3118
      ElectronicLevels[1/cm]    1
        0.0  2
      ZeroEnergy[kcal/mol]    0.0
  End  ! Frag2
!---------------------------------------------------
  GroundEnergy[kcal/mol]    15.34
End  ! Bimol
Barrier ts_1_4 C4H7ORvE4fmAA0 C4H7O4H74fm0
  RRHO
    Geometry[angstrom]        12
      C          0.70929      -0.34961      -0.36551
      C          1.97432      -0.35029       0.15997
      O         -0.10208       1.24709      -0.19034
      H          0.53659      -0.64523      -1.38855
      C         -0.49313       0.05967       0.40594
      H         -0.35355       0.03441       1.49056
      C         -1.83007      -0.49595      -0.02297
      H          2.14623      -0.03282       1.17698
      H          2.82746      -0.62899      -0.43816
      H         -2.63236       0.11663       0.38547
      H         -1.95795      -1.51567       0.33990
      H         -1.91221      -0.48802      -1.10813
    Core RigidRotor
      SymmetryFactor          0.5
    End  ! Core
    Frequencies[1/cm]         29
      210     229     282     397     492     521
      825     832     881     955     1000    1085
      1110    1196    1222    1254    1330    1375
      1409    1456    1467    1487    2896    2921
      2989    2999    3033    3077    3128
    ElectronicLevels[1/cm]    1
      0.0  2
    ZeroEnergy[kcal/mol]      5.22
    Tunneling  Eckart
      ImaginaryFrequency[1/cm]  557
      WellDepth[kcal/mol]       5.22
      WellDepth[kcal/mol]       4.53
  End
End  ! Barrier
Barrier ts_1_5 C4H7ORvE4fmAA0 C4H7O-kSV4fm
  RRHO
    Geometry[angstrom]        12
      C          0.87709      -0.21741      -0.40632
      C          2.08394      -0.28612       0.20957
      C         -0.70667       0.09340       0.50006
      H          0.57596      -0.92870      -1.16502
      O          0.06416       0.92182      -0.31338
      C         -2.01971      -0.35608      -0.02535
      H         -0.52239       0.19787       1.56085
      H          2.40860       0.49640       0.87705
      H          2.71374      -1.14858       0.06419
      H         -2.72213       0.48277      -0.07911
      H         -2.45400      -1.12084       0.61564
      H         -1.92100      -0.75623      -1.03434
    Core RigidRotor
      SymmetryFactor          0.5
    End  ! Core
    Frequencies[1/cm]         29
      167     185     231     413     504     568
      701     776     882     887     937     1018
      1093    1107    1171    1272    1338    1377
      1386    1442    1454    1500    2880    2949
      2994    3027    3036    3042    3135
    ElectronicLevels[1/cm]    1
      0.0  2
    ZeroEnergy[kcal/mol]      12.82
    Tunneling  Eckart
      ImaginaryFrequency[1/cm]  692
      WellDepth[kcal/mol]       12.82
      WellDepth[kcal/mol]       13.99
  End
End  ! Barrier
Barrier FakeB-C4H6O-RvErx50+H-TcYTcY C4H6O-RvErx50+H-TcYTcY FakeW-C4H6O-RvErx50+H-TcYTcY
  RRHO
    Stoichiometry  C4H7O1
    Core PhaseSpaceTheory
      FragmentGeometry[angstrom]    11
        C          0.72742       0.00885       0.09297
        C          1.90144      -0.57037      -0.06558
        C         -0.64042       0.09844       0.50984
        O          0.10695       1.17441      -0.21575
        C         -1.76216      -0.54091      -0.24727
        H         -0.84131       0.37604       1.53798
        H          2.06298      -1.56256       0.32119
        H          2.70423      -0.06285      -0.57653
        H         -1.46328      -0.74177      -1.27280
        H         -2.64013       0.10342      -0.25070
        H         -2.03579      -1.48361       0.22707
      FragmentGeometry[angstrom]    1
        H          0.00000       0.00000       0.00000
      SymmetryFactor                  0.5
      PotentialPrefactor[au]          10.0
      PotentialPowerExponent          6.0
      TSTLevel EJ
    End  ! Core
    Frequencies[1/cm]         26
      204     348     410     555     676     715
      800     822     931     1013    1061    1107
      1120    1208    1345    1387    1424    1456
      1465    1808    2924    2985    3003    3020
      3044    3133
    ElectronicLevels[1/cm]    1
      0.0  2
    Rotor  Hindered   # D8
      Geometry[angstrom]     11
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.31327
            C          0.00000       0.56904      -1.31357
            O         -0.04575      -0.87334      -1.02229
            C         -1.22354       1.16093      -1.94194
            H          0.95344       0.87113      -1.73545
            H          0.04213       0.93582       1.84745
            H         -0.03899      -0.92600       1.86726
            H         -2.12363       0.77972      -1.46359
            H         -1.25915       0.92734      -3.00595
            H         -1.20393       2.24587      -1.83304
      Group                        1   2   4   6   7   8
      Axis                         3   5
      Symmetry                     3
      PotentialSpline[kcal/mol]    4   3
        0.00    30.00   60.00   90.00
        0.0000  1.1106  2.3476  1.0405
    End  ! HindRot
    ZeroEnergy[kcal/mol]      40.69
End  ! Barrier
Barrier ts_1_6 C4H7ORvE4fmAA0 FakeW-C4H6O-RvErx50+H-TcYTcY
  RRHO
    Geometry[angstrom]        12
      C         -0.71018      -0.03538      -0.00197
      C         -1.97420      -0.46870      -0.07735
      C          0.63388       0.08548      -0.50955
      H         -0.38178      -1.06511       1.53556
      O         -0.09843       1.14868       0.23953
      C          1.86303      -0.46292       0.14063
      H          0.72056       0.33182      -1.56213
      H         -2.17268      -1.46323      -0.43974
      H         -2.77508       0.11089       0.35378
      H          2.70240       0.21253      -0.01739
      H          2.11441      -1.42670      -0.30273
      H          1.70438      -0.60052       1.20585
    Core RigidRotor
      SymmetryFactor          0.5
    End  ! Core
    Frequencies[1/cm]         29
      183     229     307     399     422     547
      622     659     683     798     821     932
      1011    1068    1107    1125    1209    1348
      1386    1424    1454    1459    1718    2925
      2986    3002    3022    3043    3138
    ElectronicLevels[1/cm]    1
      0.0  2
    ZeroEnergy[kcal/mol]      46.96
    Tunneling  Eckart
      ImaginaryFrequency[1/cm]  912
      WellDepth[kcal/mol]       46.96
      WellDepth[kcal/mol]       9.26
  End
End  ! Barrier
Barrier FakeB-C3H4OALAD-Wv9FbZ+CH3 C3H4OALAD-Wv9FbZ+CH3 FakeW-C3H4OALAD-Wv9FbZ+CH3
  RRHO
    Stoichiometry  C4H7O1
    Core PhaseSpaceTheory
      FragmentGeometry[angstrom]    8
        C         -1.75567       0.14253       0.00004
        C         -0.56180      -0.45071      -0.00007
        H         -1.83542       1.22201       0.00006
        H         -2.67786      -0.41861       0.00013
        C          0.67267       0.34838      -0.00004
        H         -0.44709      -1.52601      -0.00008
        O          1.78974      -0.12031       0.00006
        H          0.51128       1.44392      -0.00016
      FragmentGeometry[angstrom]    4
        C          0.00000       0.00000       0.00000
        H          0.00000       1.07573       0.00000
        H          0.93161      -0.53787       0.00000
        H         -0.93161      -0.53787       0.00000
      SymmetryFactor                  6.0
      PotentialPrefactor[au]          10.0
      PotentialPowerExponent          6.0
      TSTLevel EJ
    End  ! Core
    Frequencies[1/cm]         23
      320     568     603     911     983     1010
      1022    1152    1274    1362    1426    1628
      1708    2786    3018    3059    3106    509
      1390    1390    3001    3169    3169
    ElectronicLevels[1/cm]    1
      0.0  2
    Rotor  Hindered   # D6
      Geometry[angstrom]     8
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.32632
            H          0.00000       0.93115      -0.55562
            H         -0.00000      -0.91518      -0.57561
            C          0.00001       1.26600       2.08029
            H          0.00000      -0.91309       1.90838
            O          0.00001       1.33912       3.28041
            H          0.00001       2.17986       1.45087
      Group                        1   3   4   6
      Axis                         2   5
      Symmetry                     1
      PotentialSpline[kcal/mol]    12   11
        0.00    30.00   60.00   90.00   120.00  150.00
        180.00  210.00  240.00  270.00  300.00  330.00
        0.0000  1.8695  6.8539  9.9516  6.9141  3.4410
        2.3041  3.4411  6.9140  9.9515  6.8537  1.8694
    End  ! HindRot
    ZeroEnergy[kcal/mol]      2.92
End  ! Barrier
Barrier ts_1_7 C4H7O4H74fm0 FakeW-C3H4OALAD-Wv9FbZ+CH3
  RRHO
    Geometry[angstrom]        12
      C          2.03204       0.22082      -0.15401
      C          0.92673      -0.25955       0.40989
      H          2.03721       0.53196      -1.19105
      H          2.95963       0.30991       0.39092
      C         -0.34013      -0.44216      -0.34821
      H          0.90557      -0.59028       1.44033
      C         -1.25902       1.35546       0.11157
      O         -1.21678      -1.24032       0.02256
      H         -0.27544      -0.14183      -1.41016
      H         -2.18762       1.22423      -0.42119
      H         -1.31077       1.27641       1.18628
      H         -0.55211       2.06478      -0.29101
    Core RigidRotor
      SymmetryFactor          0.5
    End  ! Core
    Frequencies[1/cm]         27
      214     309     334     537     623     638
      668     891     926     954     1017    1037
      1141    1269    1329    1396    1407    1411
      1513    1647    2779    2976    3013    3046
      3101    3130    3133
    ElectronicLevels[1/cm]    1
      0.0  2
    Rotor  Hindered   # D6
      Geometry[angstrom]     12
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.32432
            H          0.00000       0.92966      -0.55859
            H         -0.00895      -0.91678      -0.57274
            C         -0.04477       1.25473       2.12376
            H         -0.01441      -0.91877       1.89894
            C          2.02809       1.53907       2.40054
            O         -0.43187       1.26699       3.29545
            H         -0.07433       2.18033       1.51748
            H          2.00801       2.44078       2.99473
            H          2.27798       0.62616       2.92153
            H          2.36576       1.62508       1.37728
      Group                        1   3   4   6
      Axis                         2   5
      Symmetry                     1
      PotentialSpline[kcal/mol]    12   11
        0.00    30.00   60.00   90.00   120.00  150.00
        180.00  210.00  240.00  270.00  300.00  330.00
        0.0000  1.5936  4.9687  7.1719  7.5927  4.9557
        1.5678  0.5301  2.6923  6.7487  6.1852  1.7893
    End  ! HindRot
    Rotor  Hindered   # D9
      Geometry[angstrom]     12
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.32432
            H          0.00000       0.92966      -0.55859
            H         -0.00895      -0.91678      -0.57274
            C         -0.04477       1.25473       2.12376
            H         -0.01441      -0.91877       1.89894
            C          2.02809       1.53907       2.40054
            O         -0.43187       1.26699       3.29545
            H         -0.07433       2.18033       1.51748
            H          2.00801       2.44078       2.99473
            H          2.27798       0.62616       2.92153
            H          2.36576       1.62508       1.37728
      Group                        1   2   3   4   6   8   9
      Axis                         5   7
      Symmetry                     3
      PotentialSpline[kcal/mol]    4   3
        0.00    30.00   60.00   90.00
        0.0000  0.8022  1.5728  0.7094
    End  ! HindRot
    ZeroEnergy[kcal/mol]      13.21
    Tunneling  Eckart
      ImaginaryFrequency[1/cm]  491
      WellDepth[kcal/mol]       12.52
      WellDepth[kcal/mol]       13.29
  End
End  ! Barrier
Barrier FakeB-C2H4OALD-UPQWKw+C2H3ALK-S58hH1 C2H4OALD-UPQWKw+C2H3ALK-S58hH1 FakeW-C2H4OALD-UPQWKw+C2H3ALK-S58hH1
  RRHO
    Stoichiometry  C4H7O1
    Core PhaseSpaceTheory
      FragmentGeometry[angstrom]    7
        C          1.16576      -0.14899      -0.00000
        C         -0.23120       0.39839       0.00000
        H          1.70098       0.22059      -0.87605
        H          1.70089       0.22037       0.87620
        H          1.15186      -1.23472      -0.00014
        O         -1.23253      -0.27579      -0.00000
        H         -0.30086       1.50370      -0.00002
      FragmentGeometry[angstrom]    5
        C          0.04872       0.71828       0.00000
        C          0.04872      -0.58503       0.00000
        H         -0.67179       1.51789      -0.00000
        H         -0.87875      -1.15563      -0.00000
        H          0.96591      -1.16174       0.00000
      SymmetryFactor                  1.0
      PotentialPrefactor[au]          10.0
      PotentialPowerExponent          6.0
      TSTLevel EJ
    End  ! Core
    Frequencies[1/cm]         23
      504     766     879     1114    1118    1353
      1396    1434    1444    1742    2782    2916
      2974    3025    711     817     921     1043
      1371    1622    2943    3035    3118
    ElectronicLevels[1/cm]    1
      0.0  2
    Rotor  Hindered   # D5
      Geometry[angstrom]     7
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.49911
            H          0.00000       1.02963      -0.36370
            H          0.91942      -0.46358      -0.36360
            H         -0.86583      -0.53321      -0.38391
            O         -0.84028      -0.51779       2.18101
            H          0.85486       0.52673       1.97023
      Group                        3   4   5
      Axis                         1   2
      Symmetry                     3
      PotentialSpline[kcal/mol]    4   3
        0.00    30.00   60.00   90.00
        0.0000  0.5592  1.2391  0.4533
    End  ! HindRot
    ZeroEnergy[kcal/mol]      15.34
End  ! Barrier
Barrier ts_1_8 C4H7O4H74fm0 FakeW-C2H4OALD-UPQWKw+C2H3ALK-S58hH1
  RRHO
    Geometry[angstrom]        12
      C          2.08607       0.02667      -0.19969
      C          1.10095      -0.72780       0.20199
      H          1.93084       1.07450      -0.41725
      H          3.08400      -0.38254      -0.32378
      C         -0.76658       0.26289       0.40817
      H          0.96655      -1.75990       0.48040
      C         -1.66038      -0.74005      -0.28700
      O         -0.52566       1.36891      -0.07638
      H         -0.63106       0.10046       1.49430
      H         -1.52292      -1.74929       0.09619
      H         -2.69538      -0.44725      -0.09994
      H         -1.48708      -0.71756      -1.35971
    Core RigidRotor
      SymmetryFactor          0.5
    End  ! Core
    Frequencies[1/cm]         27
      193     243     341     426     497     792
      814     831     890     942     1020    1081
      1105    1344    1355    1366    1443    1447
      1582    1631    2768    2917    2980    2981
      3016    3075    3104
    ElectronicLevels[1/cm]    1
      0.0  2
    Rotor  Hindered   # D6
      Geometry[angstrom]     12
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.30038
            H          0.00000       0.92947      -0.55668
            H         -0.00030      -0.93245      -0.55785
            C          0.02898       1.94561       2.22673
            H         -0.00040      -0.74321       2.08234
            C         -1.04084       1.73770       3.27411
            O         -0.13579       2.68622       1.26484
            H          1.05672       1.67300       2.53727
            H         -0.86834       0.83928       3.86535
            H         -1.01611       2.59529       3.95046
            H         -2.02285       1.69799       2.80724
      Group                        1   3   4   6
      Axis                         2   5
      Symmetry                     1
      PotentialSpline[kcal/mol]    12   11
        0.00    30.00   60.00   90.00   120.00  150.00
        180.00  210.00  240.00  270.00  300.00  330.00
        0.0000  0.4713  1.2137  1.2376  1.1356  1.2116
        1.2620  0.9709  1.0080  1.6960  1.2601  0.3796
    End  ! HindRot
    Rotor  Hindered   # D9
      Geometry[angstrom]     12
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.30038
            H          0.00000       0.92947      -0.55668
            H         -0.00030      -0.93245      -0.55785
            C          0.02898       1.94561       2.22673
            H         -0.00040      -0.74321       2.08234
            C         -1.04084       1.73770       3.27411
            O         -0.13579       2.68622       1.26484
            H          1.05672       1.67300       2.53727
            H         -0.86834       0.83928       3.86535
            H         -1.01611       2.59529       3.95046
            H         -2.02285       1.69799       2.80724
      Group                        1   2   3   4   6   8   9
      Axis                         5   7
      Symmetry                     3
      PotentialSpline[kcal/mol]    4   3
        0.00    30.00   60.00   90.00
        0.0000  1.1120  2.0695  0.8873
    End  ! HindRot
    ZeroEnergy[kcal/mol]      20.20
    Tunneling  Eckart
      ImaginaryFrequency[1/cm]  392
      WellDepth[kcal/mol]       19.50
      WellDepth[kcal/mol]       7.85
  End
End  ! Barrier
Barrier ts_1_9 C4H7O-kSV4fm FakeW-C2H4OALD-UPQWKw+C2H3ALK-S58hH1
  RRHO
    Geometry[angstrom]        12
      C          1.82147       0.82777       0.13516
      C          1.60394      -0.37936      -0.30264
      H          1.02738       1.38225       0.63204
      H          2.77811       1.32882       0.03527
      O         -0.18123      -1.05618       0.04050
      H          2.14310      -1.16305      -0.80014
      C         -1.00401      -0.24445       0.50589
      C         -1.92044       0.56738      -0.35315
      H         -1.03454      -0.06554       1.58866
      H         -2.95157       0.46544      -0.01035
      H         -1.84642       0.24350      -1.38780
      H         -1.67194       1.63008      -0.29321
    Core RigidRotor
      SymmetryFactor          1.0
    End  ! Core
    Frequencies[1/cm]         29
      49      70      114     190     370     406
      501     731     761     865     882     919
      1033    1043    1105    1322    1362    1364
      1427    1442    1499    1628    2871    2901
      2947    2952    3012    3022    3149
    ElectronicLevels[1/cm]    1
      0.0  2
    ZeroEnergy[kcal/mol]      28.82
    Tunneling  Eckart
      ImaginaryFrequency[1/cm]  616
      WellDepth[kcal/mol]       29.99
      WellDepth[kcal/mol]       16.48
  End
End  ! Barrier
End  ! Model
!
!===================================================
!  END MASTER EQUATION MODEL
!===================================================
  - Running MESS base job at path /lcrc/project/PACC/AutoMech/data/run/MESS/RATE/C4H7O1_1_1/basev1
  - Warning, old base results overwritten.
  - Setting up the well-extended MESSRATE input with
   lumping/extension Scheme for P=1.0 atm, T=300.0 K

***********************************************

Obtaining information for well W1 at P=1.0
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (1010000000.0, 3390000000.0, 8440000000.0, 17200000000.0, 30500000000.0, 48600000000.0, 71800000000.0, 99900000000.0, 133000000000.0, 170000000000.0, 211000000000.0, 255000000000.0, 303000000000.0, 353000000000.0, 406000000000.0))
- New max temperature for well: 300.0 K
- from reaction W1->W2
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (5020.0, 103000.0, 1010000.0, 6010000.0, 25300000.0, 82200000.0, 221000000.0, 510000000.0, 1050000000.0, 1960000000.0, 3410000000.0, 5550000000.0, 8570000000.0, 12700000000.0, 18000000000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (8.47e-22, 5.67e-17, 2.49e-13, 1.76e-10, 3.41e-08, 2.58e-06, 9.62e-05, 0.00208, 0.0291, 0.289, 2.17, 12.9, 63.3, 263.0, 954.0))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

Max temperature for energies is 300.0 K

***********************************************

Obtaining information for well W2 at P=1.0
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (581000000.0, 1640000000.0, 3600000000.0, 6690000000.0, 11000000000.0, 16700000000.0, 23800000000.0, 32100000000.0, 41700000000.0, 52400000000.0, 64300000000.0, 77100000000.0, 90900000000.0, 105000000000.0, 121000000000.0))
- New max temperature for well: 300.0 K
- from reaction W2->W1
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
- New max temperature for well: 500.0 K
- from reaction W2->W3
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (5800.0, 137000.0, 1510000.0, 10000000.0, 46000000.0, 162000000.0, 468000000.0, 1160000000.0, 2520000000.0, 4970000000.0, 9050000000.0, 15400000000.0, 24800000000.0, 38000000000.0, 56000000000.0))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (0.0824, 11.4, 476.0, 8820.0, 92200.0, 634000.0, 3170000.0, 12500000.0, 40300000.0, 112000000.0, 274000000.0, 603000000.0, 1220000000.0, 2290000000.0, 4040000000.0))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

Max temperature for energies is 500.0 K

***********************************************

Obtaining information for well W3 at P=1.0
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (77.7, 1850.0, 20300.0, 131000.0, 587000.0, 2010000.0, 5650000.0, 13600000.0, 28900000.0, 56000000.0, 100000000.0, 168000000.0, 267000000.0, 404000000.0, 590000000.0))
- New max temperature for well: 300.0 K
- from reaction W3->W1
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
- New max temperature for well: 500.0 K
- from reaction W3->W2
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (1.72e-09, 2.43e-06, 0.000576, 0.0411, 1.27, 21.2, 223.0, 1650.0, 9230.0, 41300.0, 154000.0, 493000.0, 1400000.0, 3550000.0, 8270000.0))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
- New max temperature for well: 600.0 K
- from reaction W3->P1
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

Max temperature for energies is 600.0 K

***********************************************

Obtaining information for well W4 at P=1.0
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (1400.0, 8090.0, 30900.0, 88900.0, 209000.0, 421000.0, 759000.0, 1250000.0, 1930000.0, 2820000.0, 3930000.0, 5270000.0, 6860000.0, 8700000.0, 10800000.0))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
- New max temperature for well: 300.0 K
- from reaction W4->W1
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (2340000000.0, 3980000000.0, 5800000000.0, 7630000000.0, 9360000000.0, 10900000000.0, 12300000000.0, 13500000000.0, 14500000000.0, 15300000000.0, 16000000000.0, 16600000000.0, 17000000000.0, 17300000000.0, 17500000000.0))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output

Max temperature for energies is 300.0 K

***********************************************

Obtaining information for well W5 at P=1.0
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
- New max temperature for well: 300.0 K
- from reaction W5->W1
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (0.664, 10.5, 80.8, 388.0, 1340.0, 3670.0, 8410.0, 16800.0, 30400.0, 50400.0, 78300.0, 115000.0, 162000.0, 218000.0, 286000.0))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (17400000000.0, 24800000000.0, 30700000000.0, 34800000000.0, 37400000000.0, 38600000000.0, 38700000000.0, 38200000000.0, 37100000000.0, 35800000000.0, 34200000000.0, 32500000000.0, 30900000000.0, 29200000000.0, 27500000000.0))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output

Max temperature for energies is 300.0 K

***********************************************

Obtaining information for well W6 at P=1.0
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
- New max temperature for well: 300.0 K
- from reaction W6->W1
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (1760.0, 9170.0, 31500.0, 82400.0, 177000.0, 332000.0, 558000.0, 865000.0, 1260000.0, 1740000.0, 2300000.0, 2950000.0, 3670000.0, 4450000.0, 5300000.0))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (0.00137, 0.0521, 0.806, 6.84, 38.1, 156.0, 508.0, 1380.0, 3280.0, 6940.0, 13400.0, 24100.0, 40500.0, 64700.0, 98600.0))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (68900000000.0, 97900000000.0, 121000000000.0, 138000000000.0, 147000000000.0, 152000000000.0, 153000000000.0, 151000000000.0, 147000000000.0, 141000000000.0, 135000000000.0, 128000000000.0, 122000000000.0, 115000000000.0, 109000000000.0))

No k(T) values found for P = 1.0 atm.
T=300.0: minimum of all temps in output

Max temperature for energies is 300.0 K
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Writing New Well-Extended MESS input file at path /lcrc/project/PACC/AutoMech/data/run/MESS/RATE/C4H7O1_1_1/wextv1
Debug:  MESS Input:

!===================================================
!  GLOBAL KEYWORDS
!===================================================
TemperatureList[K]                     300.0  350.0  400.0  450.0  500.0  550.0  600.0  650.0  700.0  750.0  800.0  850.0  900.0  950.0  1000.0
PressureList[atm]                      0.01  0.03  0.1  0.3  1.0  3.0  10.0  30.0  100.0
!
ModelEnergyLimit[kcal/mol]             800.00
EnergyStepOverTemperature              0.20
!
CalculationMethod                      direct
!
WellCutoff                             10
WellExtension                          0.0010
!
ChemicalEigenvalueMax                  0.20
!
ReductionMethod                        diagonalization
!
HotEnergies[kcal/mol]                  1
C4H7ORvE4fmAA0 0.0:1.0:289.5
!
MicroRateOutput                        ke.out
MicroEnerMin[kcal/mol]                 0.1
MicroEnerMax[kcal/mol]                 289.4530789778327
MicroEnerStep[kcal/mol]                0.1
!
AtomDistanceMin[angstrom]              0.68793
!
RateOutput                             rate.out
!
!
!===================================================
!  BEGIN MASTER EQUATION MODEL
!===================================================
!
ExtensionCorrection    0.6
Model
  LumpingScheme   C4H7O-kSV4fm&FakeW-C4H6O-RvErx50+H-TcYTcY
  WellSeparator  &
!
GroundEnergyShiftMax[kcal/mol]  10
!
UseShortNames
!
!---------------------------------------------------
!  ENERGY TRANSFER SECTION
!---------------------------------------------------
  EnergyRelaxation
    Exponential
       Factor[1/cm]                     267.672
       Power                            0.675
       ExponentCutoff                   15.000
  End  ! EneRelax
  CollisionFrequency
    LennardJones
       Epsilons[1/cm]                   165.902    165.902
       Sigmas[angstrom]                 4.601      4.601
       Masses[amu]                      71.050     39.962
  End  ! CollidFreq
!---------------------------------------------------
!  REACTION CHANNELS SECTION
!---------------------------------------------------
Well C4H7ORvE4fmAA0   ! [[CH2][C@H]1[C@H](C)O1]
  WellExtensionCap[kcal/mol]    3.10
  Species
    RRHO
      Geometry[angstrom]        12
        C          0.66636      -0.17413      -0.40397
        C          1.98338      -0.39696       0.14653
        C         -0.53894      -0.02155       0.44414
        H          0.49187      -0.52500      -1.41434
        O          0.05448       1.13100      -0.14121
        C         -1.90277      -0.40553      -0.04841
        H         -0.38603      -0.09237       1.51741
        H          2.24763       0.03973       1.09620
        H          2.71463      -0.98005      -0.38760
        H         -2.65917       0.25189       0.37975
        H         -2.14006      -1.42924       0.24073
        H         -1.95294      -0.32398      -1.13223
      Core RigidRotor
        SymmetryFactor          1.0
      End  ! Core
      Frequencies[1/cm]         28
        247     287     451     464     549     699
        812     882     964     1025    1057    1133
        1144    1164    1232    1337    1380    1414
        1446    1455    1467    2919    2976    2982
        3001    3010    3042    3145
      ElectronicLevels[1/cm]    1
        0.0  2
      Rotor  Hindered   # D7
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.44559
              C          0.00000       1.24745      -0.79839
              H         -0.42947      -0.87132      -0.48562
              O          1.18318       0.49653      -0.65920
              C         -0.61408       1.31351      -2.16545
              H          0.00362       2.18059      -0.23902
              H          0.54715       0.76113       1.98232
              H         -0.53462      -0.75686       1.99812
              H         -0.05864       2.00835      -2.79651
              H         -1.64590       1.66091      -2.10385
              H         -0.59969       0.33346      -2.64082
        Group                        3   4   5   6   7   10  11  12
        Axis                         1   2
        Symmetry                     1
        PotentialSpline[kcal/mol]    12   11
          0.00    30.00   60.00   90.00   120.00  150.00
          180.00  210.00  240.00  270.00  300.00  330.00
          0.0000  1.1975  3.9796  5.4028  3.5627  0.8968
          0.0002  0.7866  3.2526  5.3325  3.4394  1.1154
      End  ! HindRot
      Rotor  Hindered   # D9
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.44559
              C          0.00000       1.24745      -0.79839
              H         -0.42947      -0.87132      -0.48562
              O          1.18318       0.49653      -0.65920
              C         -0.61408       1.31351      -2.16545
              H          0.00362       2.18059      -0.23902
              H          0.54715       0.76113       1.98232
              H         -0.53462      -0.75686       1.99812
              H         -0.05864       2.00835      -2.79651
              H         -1.64590       1.66091      -2.10385
              H         -0.59969       0.33346      -2.64082
        Group                        1   2   4   5   7   8   9
        Axis                         3   6
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.3355  2.9126  1.3504
      End  ! HindRot
      ZeroEnergy[kcal/mol]      0.00
  End  ! Species
    EnergyRelaxation
      Exponential
         Factor[1/cm]                     267.672
         Power                            0.675
         ExponentCutoff                   15.000
    End  ! EneRelax
    CollisionFrequency
      LennardJones
         Epsilons[1/cm]                   165.902    165.902
         Sigmas[angstrom]                 4.601      4.601
         Masses[amu]                      71.050     39.962
    End  ! CollidFreq
End  ! Well
Well C4H7O4H74fm0   ! [C=C[C@H](C)[O]]
  WellExtensionCap[kcal/mol]    7.90
  Species
    RRHO
      Geometry[angstrom]        12
        C          1.92181      -0.01641      -0.29413
        C          0.88159      -0.57253       0.31436
        H          1.84502       0.96923      -0.72874
        H          2.86747      -0.53159      -0.36973
        C         -0.47007       0.07947       0.44927
        H          0.96613      -1.55945       0.75571
        C         -1.54085      -0.69258      -0.36769
        O         -0.53470       1.36617      -0.01172
        H         -0.80164       0.04761       1.49754
        H         -2.52406      -0.25963      -0.20740
        H         -1.54115      -1.73016      -0.04041
        H         -1.28908      -0.65307      -1.42414
      Core RigidRotor
        SymmetryFactor          0.5
      End  ! Core
      Frequencies[1/cm]         28
        275     332     365     588     649     805
        885     948     954     1014    1021    1036
        1100    1219    1288    1330    1358    1411
        1449    1470    1654    2833    2933    3011
        3017    3023    3032    3113
      ElectronicLevels[1/cm]    1
        0.0  2
      Rotor  Hindered   # D6
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.32110
              H          0.00000       0.92952      -0.55412
              H          0.00149      -0.92353      -0.56210
              C         -0.01106       1.24493       2.17242
              H          0.00523      -0.93600       1.87140
              C         -1.31911       1.33781       3.00293
              O          0.07924       2.41531       1.48972
              H          0.80663       1.19854       2.91119
              H         -1.28249       2.19438       3.67145
              H         -1.42610       0.42398       3.58556
              H         -2.17017       1.43167       2.33144
        Group                        1   3   4   6
        Axis                         2   5
        Symmetry                     1
        PotentialSpline[kcal/mol]    12   11
          0.00    30.00   60.00   90.00   120.00  150.00
          180.00  210.00  240.00  270.00  300.00  330.00
          0.0000  0.3412  1.8945  1.4039  0.0000  0.3596
          1.4012  0.9421  0.3139  1.3925  2.9508  0.9794
      End  ! HindRot
      Rotor  Hindered   # D9
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.32110
              H          0.00000       0.92952      -0.55412
              H          0.00149      -0.92353      -0.56210
              C         -0.01106       1.24493       2.17242
              H          0.00523      -0.93600       1.87140
              C         -1.31911       1.33781       3.00293
              O          0.07924       2.41531       1.48972
              H          0.80663       1.19854       2.91119
              H         -1.28249       2.19438       3.67145
              H         -1.42610       0.42398       3.58556
              H         -2.17017       1.43167       2.33144
        Group                        1   2   3   4   6   8   9
        Axis                         5   7
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.4563  3.0346  1.5339
      End  ! HindRot
      ZeroEnergy[kcal/mol]      0.69
  End  ! Species
    EnergyRelaxation
      Exponential
         Factor[1/cm]                     402.815
         Power                            0.602
         ExponentCutoff                   15.000
    End  ! EneRelax
    CollisionFrequency
      LennardJones
         Epsilons[1/cm]                   165.902    165.902
         Sigmas[angstrom]                 4.601      4.601
         Masses[amu]                      71.050     39.962
    End  ! CollidFreq
End  ! Well
Well C4H7O-kSV4fm   ! [C=CO[CH]C]
  WellExtensionCap[kcal/mol]    11.80
  Species
    RRHO
      Geometry[angstrom]        12
        C          2.27851      -0.21273       0.04621
        C          0.95978      -0.32110      -0.07900
        H          2.74809       0.73971       0.23554
        H          2.89295      -1.09268      -0.04236
        O          0.15061       0.76820       0.02630
        H          0.47033      -1.26407      -0.27149
        C         -1.20683       0.64838      -0.12793
        C         -1.91169      -0.64303       0.06641
        H         -1.68817       1.59012       0.07473
        H         -2.98329      -0.46062       0.03693
        H         -1.67711      -1.10910       1.03146
        H         -1.68631      -1.37810      -0.70931
      Core RigidRotor
        SymmetryFactor          1.0
      End  ! Core
      Frequencies[1/cm]         27
        239     398     485     594     697     839
        847     958     964     997     1104    1142
        1274    1320    1360    1396    1406    1443
        1465    1653    2860    2919    2995    3046
        3073    3093    3138
      ElectronicLevels[1/cm]    1
        0.0  2
      Rotor  Hindered   # D6
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.32437
              H          0.00000       0.92163      -0.56361
              H          0.00085      -0.93840      -0.53134
              O         -0.00004       1.15566       2.02817
              H         -0.00233      -0.91503       1.90219
              C         -0.02491       1.15767       3.39000
              C          0.34395      -0.02962       4.19606
              H          0.06965       2.16166       3.77145
              H          0.38377       0.26020       5.24422
              H          1.32679      -0.43644       3.92327
              H         -0.37779      -0.84822       4.11254
        Group                        1   3   4   6
        Axis                         2   5
        Symmetry                     1
        PotentialSpline[kcal/mol]    12   11
          0.00    30.00   60.00   90.00   120.00  150.00
          180.00  210.00  240.00  270.00  300.00  330.00
          0.0000  0.4575  1.7308  3.1244  3.6427  3.2671
          2.5242  2.1012  2.4620  3.1972  1.9974  0.5563
      End  ! HindRot
      Rotor  Hindered   # D7
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.32437
              H          0.00000       0.92163      -0.56361
              H          0.00085      -0.93840      -0.53134
              O         -0.00004       1.15566       2.02817
              H         -0.00233      -0.91503       1.90219
              C         -0.02491       1.15767       3.39000
              C          0.34395      -0.02962       4.19606
              H          0.06965       2.16166       3.77145
              H          0.38377       0.26020       5.24422
              H          1.32679      -0.43644       3.92327
              H         -0.37779      -0.84822       4.11254
        Group                        1   2   3   4   6
        Axis                         5   7
        Symmetry                     1
        PotentialSpline[kcal/mol]    12   11
          0.00    30.00   60.00   90.00   120.00  150.00
          180.00  210.00  240.00  270.00  300.00  330.00
          0.0000  0.4151  1.6993  1.6692  0.0000  0.0000
          0.0000  0.3243  2.3528  1.1501  0.5245  0.3223
      End  ! HindRot
      Rotor  Hindered   # D9
        Geometry[angstrom]     12
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.32437
              H          0.00000       0.92163      -0.56361
              H          0.00085      -0.93840      -0.53134
              O         -0.00004       1.15566       2.02817
              H         -0.00233      -0.91503       1.90219
              C         -0.02491       1.15767       3.39000
              C          0.34395      -0.02962       4.19606
              H          0.06965       2.16166       3.77145
              H          0.38377       0.26020       5.24422
              H          1.32679      -0.43644       3.92327
              H         -0.37779      -0.84822       4.11254
        Group                        1   2   3   4   5   6   9
        Axis                         7   8
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.1453  2.3475  1.1802
      End  ! HindRot
      ZeroEnergy[kcal/mol]      -1.17
  End  ! Species
    EnergyRelaxation
      Exponential
         Factor[1/cm]                     402.815
         Power                            0.602
         ExponentCutoff                   15.000
    End  ! EneRelax
    CollisionFrequency
      LennardJones
         Epsilons[1/cm]                   165.902    165.902
         Sigmas[angstrom]                 4.601      4.601
         Masses[amu]                      71.050     39.962
    End  ! CollidFreq
End  ! Well
Well FakeW-C4H6O-RvErx50+H-TcYTcY   ! Fake Well for C4H6O-RvErx50+H-TcYTcY
  WellExtensionCap[kcal/mol]    4.30
  Species
    RRHO
      Geometry[angstrom]        12
        C          0.69607      -0.03882       0.09276
        C          1.87010      -0.61804      -0.06579
        C         -0.67176       0.05077       0.50963
        O          0.07561       1.12674      -0.21596
        C         -1.79350      -0.58859      -0.24748
        H         -0.87266       0.32837       1.53777
        H          2.03163      -1.61023       0.32098
        H          2.67289      -0.11052      -0.57674
        H         -1.49463      -0.78944      -1.27301
        H         -2.67147       0.05575      -0.25091
        H         -2.06713      -1.53128       0.22686
        H          0.00000       0.00000       4.43193
      Core RigidRotor
        SymmetryFactor          0.5
      End  ! Core
      Frequencies[1/cm]         29
        10      20      30      204     348     410
        555     676     715     800     822     931
        1013    1061    1107    1120    1208    1345
        1387    1424    1456    1465    1808    2924
        2985    3003    3020    3044    3133
      ElectronicLevels[1/cm]    1
        0.0  2
      Rotor  Hindered   # D8
        Geometry[angstrom]     11
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.31327
              C          0.00000       0.56904      -1.31357
              O         -0.04575      -0.87334      -1.02229
              C         -1.22354       1.16093      -1.94194
              H          0.95344       0.87113      -1.73545
              H          0.04213       0.93582       1.84745
              H         -0.03899      -0.92600       1.86726
              H         -2.12363       0.77972      -1.46359
              H         -1.25915       0.92734      -3.00595
              H         -1.20393       2.24587      -1.83304
        Group                        1   2   4   6   7   8
        Axis                         3   5
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.1106  2.3476  1.0405
      End  ! HindRot
      ZeroEnergy[kcal/mol]      37.69
  End  ! Species
End  ! Well
Well FakeW-C3H4OALAD-Wv9FbZ+CH3   ! Fake Well for C3H4OALAD-Wv9FbZ+CH3
  WellExtensionCap[kcal/mol]    5.40
  Species
    RRHO
      Geometry[angstrom]        12
        C         -1.83430       0.15529       0.00004
        C         -0.64043      -0.43795      -0.00007
        H         -1.91404       1.23477       0.00006
        H         -2.75648      -0.40584       0.00013
        C          0.59404       0.36114      -0.00004
        H         -0.52572      -1.51324      -0.00008
        O          1.71111      -0.10754       0.00006
        H          0.43265       1.45668      -0.00016
        C          0.00000      -0.00000       3.00013
        H          0.00000       1.07573       3.00013
        H          0.93161      -0.53787       3.00013
        H         -0.93161      -0.53787       3.00013
      Core RigidRotor
        SymmetryFactor          6.0
      End  ! Core
      Frequencies[1/cm]         29
        10      20      30      40      50      60
        320     568     603     911     983     1010
        1022    1152    1274    1362    1426    1628
        1708    2786    3018    3059    3106    509
        1390    1390    3001    3169    3169
      ElectronicLevels[1/cm]    1
        0.0  2
      Rotor  Hindered   # D6
        Geometry[angstrom]     8
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.32632
              H          0.00000       0.93115      -0.55562
              H         -0.00000      -0.91518      -0.57561
              C          0.00001       1.26600       2.08029
              H          0.00000      -0.91309       1.90838
              O          0.00001       1.33912       3.28041
              H          0.00001       2.17986       1.45087
        Group                        1   3   4   6
        Axis                         2   5
        Symmetry                     1
        PotentialSpline[kcal/mol]    12   11
          0.00    30.00   60.00   90.00   120.00  150.00
          180.00  210.00  240.00  270.00  300.00  330.00
          0.0000  1.8695  6.8539  9.9516  6.9141  3.4410
          2.3041  3.4411  6.9140  9.9515  6.8537  1.8694
      End  ! HindRot
      ZeroEnergy[kcal/mol]      -0.08
  End  ! Species
End  ! Well
Well FakeW-C2H4OALD-UPQWKw+C2H3ALK-S58hH1   ! Fake Well for C2H4OALD-UPQWKw+C2H3ALK-S58hH1
  WellExtensionCap[kcal/mol]    5.10
  Species
    RRHO
      Geometry[angstrom]        12
        C          1.26146      -0.13303      -0.00000
        C         -0.13550       0.41436       0.00000
        H          1.79668       0.23656      -0.87605
        H          1.79659       0.23634       0.87620
        H          1.24756      -1.21875      -0.00014
        O         -1.13683      -0.25982      -0.00000
        H         -0.20516       1.51966      -0.00002
        C          0.02725       0.68893       3.39994
        C          0.02725      -0.61439       3.39994
        H         -0.69326       1.48854       3.39994
        H         -0.90022      -1.18499       3.39994
        H          0.94444      -1.19109       3.39994
      Core RigidRotor
        SymmetryFactor          1.0
      End  ! Core
      Frequencies[1/cm]         29
        10      20      30      40      50      60
        504     766     879     1114    1118    1353
        1396    1434    1444    1742    2782    2916
        2974    3025    711     817     921     1043
        1371    1622    2943    3035    3118
      ElectronicLevels[1/cm]    1
        0.0  2
      Rotor  Hindered   # D5
        Geometry[angstrom]     7
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.49911
              H          0.00000       1.02963      -0.36370
              H          0.91942      -0.46358      -0.36360
              H         -0.86583      -0.53321      -0.38391
              O         -0.84028      -0.51779       2.18101
              H          0.85486       0.52673       1.97023
        Group                        3   4   5
        Axis                         1   2
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  0.5592  1.2391  0.4533
      End  ! HindRot
      ZeroEnergy[kcal/mol]      12.34
  End  ! Species
End  ! Well
Bimolecular C4H6O-RvErx50+H-TcYTcY   ! [C=C1[C@H](C)O1 + [H]]
!---------------------------------------------------
  Fragment C4H6O-RvErx50   ! C=C1[C@H](C)O1
    RRHO
      Geometry[angstrom]        11
        C          0.72742       0.00885       0.09297
        C          1.90144      -0.57037      -0.06558
        C         -0.64042       0.09844       0.50984
        O          0.10695       1.17441      -0.21575
        C         -1.76216      -0.54091      -0.24727
        H         -0.84131       0.37604       1.53798
        H          2.06298      -1.56256       0.32119
        H          2.70423      -0.06285      -0.57653
        H         -1.46328      -0.74177      -1.27280
        H         -2.64013       0.10342      -0.25070
        H         -2.03579      -1.48361       0.22707
      Core RigidRotor
        SymmetryFactor          0.5
      End  ! Core
      Frequencies[1/cm]         26
        204     348     410     555     676     715
        800     822     931     1013    1061    1107
        1120    1208    1345    1387    1424    1456
        1465    1808    2924    2985    3003    3020
        3044    3133
      ElectronicLevels[1/cm]    1
        0.0  1
      Rotor  Hindered   # D8
        Geometry[angstrom]     11
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.31327
              C          0.00000       0.56904      -1.31357
              O         -0.04575      -0.87334      -1.02229
              C         -1.22354       1.16093      -1.94194
              H          0.95344       0.87113      -1.73545
              H          0.04213       0.93582       1.84745
              H         -0.03899      -0.92600       1.86726
              H         -2.12363       0.77972      -1.46359
              H         -1.25915       0.92734      -3.00595
              H         -1.20393       2.24587      -1.83304
        Group                        1   2   4   6   7   8
        Axis                         3   5
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  1.1106  2.3476  1.0405
      End  ! HindRot
      ZeroEnergy[kcal/mol]    0.0
  End  ! Frag1
!---------------------------------------------------
  Fragment H-TcYTcY   ! [H]
    Atom
      Mass[amu]                 1.00782503223
      ElectronicLevels[1/cm]    1
        0.0  2
  End  ! Frag2
!---------------------------------------------------
  GroundEnergy[kcal/mol]    40.69
End  ! Bimol
Bimolecular C3H4OALAD-Wv9FbZ+CH3   ! [C=CC=O + [CH3]]
!---------------------------------------------------
  Fragment C3H4OALAD-Wv9FbZ   ! C=CC=O
    RRHO
      Geometry[angstrom]        8
        C         -1.75567       0.14253       0.00004
        C         -0.56180      -0.45071      -0.00007
        H         -1.83542       1.22201       0.00006
        H         -2.67786      -0.41861       0.00013
        C          0.67267       0.34838      -0.00004
        H         -0.44709      -1.52601      -0.00008
        O          1.78974      -0.12031       0.00006
        H          0.51128       1.44392      -0.00016
      Core RigidRotor
        SymmetryFactor          1.0
      End  ! Core
      Frequencies[1/cm]         17
        320     568     603     911     983     1010
        1022    1152    1274    1362    1426    1628
        1708    2786    3018    3059    3106
      ElectronicLevels[1/cm]    1
        0.0  1
      Rotor  Hindered   # D6
        Geometry[angstrom]     8
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.32632
              H          0.00000       0.93115      -0.55562
              H         -0.00000      -0.91518      -0.57561
              C          0.00001       1.26600       2.08029
              H          0.00000      -0.91309       1.90838
              O          0.00001       1.33912       3.28041
              H          0.00001       2.17986       1.45087
        Group                        1   3   4   6
        Axis                         2   5
        Symmetry                     1
        PotentialSpline[kcal/mol]    12   11
          0.00    30.00   60.00   90.00   120.00  150.00
          180.00  210.00  240.00  270.00  300.00  330.00
          0.0000  1.8695  6.8539  9.9516  6.9141  3.4410
          2.3041  3.4411  6.9140  9.9515  6.8537  1.8694
      End  ! HindRot
      ZeroEnergy[kcal/mol]    0.0
  End  ! Frag1
!---------------------------------------------------
  Fragment CH3   ! [CH3]
    RRHO
      Geometry[angstrom]        4
        C          0.00000       0.00000       0.00000
        H          0.00000       1.07573       0.00000
        H          0.93161      -0.53787       0.00000
        H         -0.93161      -0.53787       0.00000
      Core RigidRotor
        SymmetryFactor          6.0
      End  ! Core
      Frequencies[1/cm]         6
        509     1390    1390    3001    3169    3169
      ElectronicLevels[1/cm]    1
        0.0  2
      ZeroEnergy[kcal/mol]    0.0
  End  ! Frag2
!---------------------------------------------------
  GroundEnergy[kcal/mol]    2.92
End  ! Bimol
Bimolecular C2H4OALD-UPQWKw+C2H3ALK-S58hH1   ! [CC=O + [CH]=C]
!---------------------------------------------------
  Fragment C2H4OALD-UPQWKw   ! CC=O
    RRHO
      Geometry[angstrom]        7
        C          1.16576      -0.14899      -0.00000
        C         -0.23120       0.39839       0.00000
        H          1.70098       0.22059      -0.87605
        H          1.70089       0.22037       0.87620
        H          1.15186      -1.23472      -0.00014
        O         -1.23253      -0.27579      -0.00000
        H         -0.30086       1.50370      -0.00002
      Core RigidRotor
        SymmetryFactor          1.0
      End  ! Core
      Frequencies[1/cm]         14
        504     766     879     1114    1118    1353
        1396    1434    1444    1742    2782    2916
        2974    3025
      ElectronicLevels[1/cm]    1
        0.0  1
      Rotor  Hindered   # D5
        Geometry[angstrom]     7
              C          0.00000       0.00000       0.00000
              C          0.00000       0.00000       1.49911
              H          0.00000       1.02963      -0.36370
              H          0.91942      -0.46358      -0.36360
              H         -0.86583      -0.53321      -0.38391
              O         -0.84028      -0.51779       2.18101
              H          0.85486       0.52673       1.97023
        Group                        3   4   5
        Axis                         1   2
        Symmetry                     3
        PotentialSpline[kcal/mol]    4   3
          0.00    30.00   60.00   90.00
          0.0000  0.5592  1.2391  0.4533
      End  ! HindRot
      ZeroEnergy[kcal/mol]    0.0
  End  ! Frag1
!---------------------------------------------------
  Fragment C2H3ALK-S58hH1   ! [CH]=C
    RRHO
      Geometry[angstrom]        5
        C          0.04872       0.71828       0.00000
        C          0.04872      -0.58503       0.00000
        H         -0.67179       1.51789      -0.00000
        H         -0.87875      -1.15563      -0.00000
        H          0.96591      -1.16174       0.00000
      Core RigidRotor
        SymmetryFactor          1.0
      End  ! Core
      Frequencies[1/cm]         9
        711     817     921     1043    1371    1622
        2943    3035    3118
      ElectronicLevels[1/cm]    1
        0.0  2
      ZeroEnergy[kcal/mol]    0.0
  End  ! Frag2
!---------------------------------------------------
  GroundEnergy[kcal/mol]    15.34
End  ! Bimol
Barrier ts_1_4 C4H7ORvE4fmAA0 C4H7O4H74fm0
  RRHO
    Geometry[angstrom]        12
      C          0.70929      -0.34961      -0.36551
      C          1.97432      -0.35029       0.15997
      O         -0.10208       1.24709      -0.19034
      H          0.53659      -0.64523      -1.38855
      C         -0.49313       0.05967       0.40594
      H         -0.35355       0.03441       1.49056
      C         -1.83007      -0.49595      -0.02297
      H          2.14623      -0.03282       1.17698
      H          2.82746      -0.62899      -0.43816
      H         -2.63236       0.11663       0.38547
      H         -1.95795      -1.51567       0.33990
      H         -1.91221      -0.48802      -1.10813
    Core RigidRotor
      SymmetryFactor          0.5
    End  ! Core
    Frequencies[1/cm]         29
      210     229     282     397     492     521
      825     832     881     955     1000    1085
      1110    1196    1222    1254    1330    1375
      1409    1456    1467    1487    2896    2921
      2989    2999    3033    3077    3128
    ElectronicLevels[1/cm]    1
      0.0  2
    ZeroEnergy[kcal/mol]      5.22
    Tunneling  Eckart
      ImaginaryFrequency[1/cm]  557
      WellDepth[kcal/mol]       5.22
      WellDepth[kcal/mol]       4.53
  End
End  ! Barrier
Barrier ts_1_5 C4H7ORvE4fmAA0 C4H7O-kSV4fm
  RRHO
    Geometry[angstrom]        12
      C          0.87709      -0.21741      -0.40632
      C          2.08394      -0.28612       0.20957
      C         -0.70667       0.09340       0.50006
      H          0.57596      -0.92870      -1.16502
      O          0.06416       0.92182      -0.31338
      C         -2.01971      -0.35608      -0.02535
      H         -0.52239       0.19787       1.56085
      H          2.40860       0.49640       0.87705
      H          2.71374      -1.14858       0.06419
      H         -2.72213       0.48277      -0.07911
      H         -2.45400      -1.12084       0.61564
      H         -1.92100      -0.75623      -1.03434
    Core RigidRotor
      SymmetryFactor          0.5
    End  ! Core
    Frequencies[1/cm]         29
      167     185     231     413     504     568
      701     776     882     887     937     1018
      1093    1107    1171    1272    1338    1377
      1386    1442    1454    1500    2880    2949
      2994    3027    3036    3042    3135
    ElectronicLevels[1/cm]    1
      0.0  2
    ZeroEnergy[kcal/mol]      12.82
    Tunneling  Eckart
      ImaginaryFrequency[1/cm]  692
      WellDepth[kcal/mol]       12.82
      WellDepth[kcal/mol]       13.99
  End
End  ! Barrier
Barrier FakeB-C4H6O-RvErx50+H-TcYTcY C4H6O-RvErx50+H-TcYTcY FakeW-C4H6O-RvErx50+H-TcYTcY
  RRHO
    Stoichiometry  C4H7O1
    Core PhaseSpaceTheory
      FragmentGeometry[angstrom]    11
        C          0.72742       0.00885       0.09297
        C          1.90144      -0.57037      -0.06558
        C         -0.64042       0.09844       0.50984
        O          0.10695       1.17441      -0.21575
        C         -1.76216      -0.54091      -0.24727
        H         -0.84131       0.37604       1.53798
        H          2.06298      -1.56256       0.32119
        H          2.70423      -0.06285      -0.57653
        H         -1.46328      -0.74177      -1.27280
        H         -2.64013       0.10342      -0.25070
        H         -2.03579      -1.48361       0.22707
      FragmentGeometry[angstrom]    1
        H          0.00000       0.00000       0.00000
      SymmetryFactor                  0.5
      PotentialPrefactor[au]          10.0
      PotentialPowerExponent          6.0
      TSTLevel EJ
    End  ! Core
    Frequencies[1/cm]         26
      204     348     410     555     676     715
      800     822     931     1013    1061    1107
      1120    1208    1345    1387    1424    1456
      1465    1808    2924    2985    3003    3020
      3044    3133
    ElectronicLevels[1/cm]    1
      0.0  2
    Rotor  Hindered   # D8
      Geometry[angstrom]     11
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.31327
            C          0.00000       0.56904      -1.31357
            O         -0.04575      -0.87334      -1.02229
            C         -1.22354       1.16093      -1.94194
            H          0.95344       0.87113      -1.73545
            H          0.04213       0.93582       1.84745
            H         -0.03899      -0.92600       1.86726
            H         -2.12363       0.77972      -1.46359
            H         -1.25915       0.92734      -3.00595
            H         -1.20393       2.24587      -1.83304
      Group                        1   2   4   6   7   8
      Axis                         3   5
      Symmetry                     3
      PotentialSpline[kcal/mol]    4   3
        0.00    30.00   60.00   90.00
        0.0000  1.1106  2.3476  1.0405
    End  ! HindRot
    ZeroEnergy[kcal/mol]      40.69
End  ! Barrier
Barrier ts_1_6 C4H7ORvE4fmAA0 FakeW-C4H6O-RvErx50+H-TcYTcY
  RRHO
    Geometry[angstrom]        12
      C         -0.71018      -0.03538      -0.00197
      C         -1.97420      -0.46870      -0.07735
      C          0.63388       0.08548      -0.50955
      H         -0.38178      -1.06511       1.53556
      O         -0.09843       1.14868       0.23953
      C          1.86303      -0.46292       0.14063
      H          0.72056       0.33182      -1.56213
      H         -2.17268      -1.46323      -0.43974
      H         -2.77508       0.11089       0.35378
      H          2.70240       0.21253      -0.01739
      H          2.11441      -1.42670      -0.30273
      H          1.70438      -0.60052       1.20585
    Core RigidRotor
      SymmetryFactor          0.5
    End  ! Core
    Frequencies[1/cm]         29
      183     229     307     399     422     547
      622     659     683     798     821     932
      1011    1068    1107    1125    1209    1348
      1386    1424    1454    1459    1718    2925
      2986    3002    3022    3043    3138
    ElectronicLevels[1/cm]    1
      0.0  2
    ZeroEnergy[kcal/mol]      46.96
    Tunneling  Eckart
      ImaginaryFrequency[1/cm]  912
      WellDepth[kcal/mol]       46.96
      WellDepth[kcal/mol]       9.26
  End
End  ! Barrier
Barrier FakeB-C3H4OALAD-Wv9FbZ+CH3 C3H4OALAD-Wv9FbZ+CH3 FakeW-C3H4OALAD-Wv9FbZ+CH3
  RRHO
    Stoichiometry  C4H7O1
    Core PhaseSpaceTheory
      FragmentGeometry[angstrom]    8
        C         -1.75567       0.14253       0.00004
        C         -0.56180      -0.45071      -0.00007
        H         -1.83542       1.22201       0.00006
        H         -2.67786      -0.41861       0.00013
        C          0.67267       0.34838      -0.00004
        H         -0.44709      -1.52601      -0.00008
        O          1.78974      -0.12031       0.00006
        H          0.51128       1.44392      -0.00016
      FragmentGeometry[angstrom]    4
        C          0.00000       0.00000       0.00000
        H          0.00000       1.07573       0.00000
        H          0.93161      -0.53787       0.00000
        H         -0.93161      -0.53787       0.00000
      SymmetryFactor                  6.0
      PotentialPrefactor[au]          10.0
      PotentialPowerExponent          6.0
      TSTLevel EJ
    End  ! Core
    Frequencies[1/cm]         23
      320     568     603     911     983     1010
      1022    1152    1274    1362    1426    1628
      1708    2786    3018    3059    3106    509
      1390    1390    3001    3169    3169
    ElectronicLevels[1/cm]    1
      0.0  2
    Rotor  Hindered   # D6
      Geometry[angstrom]     8
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.32632
            H          0.00000       0.93115      -0.55562
            H         -0.00000      -0.91518      -0.57561
            C          0.00001       1.26600       2.08029
            H          0.00000      -0.91309       1.90838
            O          0.00001       1.33912       3.28041
            H          0.00001       2.17986       1.45087
      Group                        1   3   4   6
      Axis                         2   5
      Symmetry                     1
      PotentialSpline[kcal/mol]    12   11
        0.00    30.00   60.00   90.00   120.00  150.00
        180.00  210.00  240.00  270.00  300.00  330.00
        0.0000  1.8695  6.8539  9.9516  6.9141  3.4410
        2.3041  3.4411  6.9140  9.9515  6.8537  1.8694
    End  ! HindRot
    ZeroEnergy[kcal/mol]      2.92
End  ! Barrier
Barrier ts_1_7 C4H7O4H74fm0 FakeW-C3H4OALAD-Wv9FbZ+CH3
  RRHO
    Geometry[angstrom]        12
      C          2.03204       0.22082      -0.15401
      C          0.92673      -0.25955       0.40989
      H          2.03721       0.53196      -1.19105
      H          2.95963       0.30991       0.39092
      C         -0.34013      -0.44216      -0.34821
      H          0.90557      -0.59028       1.44033
      C         -1.25902       1.35546       0.11157
      O         -1.21678      -1.24032       0.02256
      H         -0.27544      -0.14183      -1.41016
      H         -2.18762       1.22423      -0.42119
      H         -1.31077       1.27641       1.18628
      H         -0.55211       2.06478      -0.29101
    Core RigidRotor
      SymmetryFactor          0.5
    End  ! Core
    Frequencies[1/cm]         27
      214     309     334     537     623     638
      668     891     926     954     1017    1037
      1141    1269    1329    1396    1407    1411
      1513    1647    2779    2976    3013    3046
      3101    3130    3133
    ElectronicLevels[1/cm]    1
      0.0  2
    Rotor  Hindered   # D6
      Geometry[angstrom]     12
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.32432
            H          0.00000       0.92966      -0.55859
            H         -0.00895      -0.91678      -0.57274
            C         -0.04477       1.25473       2.12376
            H         -0.01441      -0.91877       1.89894
            C          2.02809       1.53907       2.40054
            O         -0.43187       1.26699       3.29545
            H         -0.07433       2.18033       1.51748
            H          2.00801       2.44078       2.99473
            H          2.27798       0.62616       2.92153
            H          2.36576       1.62508       1.37728
      Group                        1   3   4   6
      Axis                         2   5
      Symmetry                     1
      PotentialSpline[kcal/mol]    12   11
        0.00    30.00   60.00   90.00   120.00  150.00
        180.00  210.00  240.00  270.00  300.00  330.00
        0.0000  1.5936  4.9687  7.1719  7.5927  4.9557
        1.5678  0.5301  2.6923  6.7487  6.1852  1.7893
    End  ! HindRot
    Rotor  Hindered   # D9
      Geometry[angstrom]     12
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.32432
            H          0.00000       0.92966      -0.55859
            H         -0.00895      -0.91678      -0.57274
            C         -0.04477       1.25473       2.12376
            H         -0.01441      -0.91877       1.89894
            C          2.02809       1.53907       2.40054
            O         -0.43187       1.26699       3.29545
            H         -0.07433       2.18033       1.51748
            H          2.00801       2.44078       2.99473
            H          2.27798       0.62616       2.92153
            H          2.36576       1.62508       1.37728
      Group                        1   2   3   4   6   8   9
      Axis                         5   7
      Symmetry                     3
      PotentialSpline[kcal/mol]    4   3
        0.00    30.00   60.00   90.00
        0.0000  0.8022  1.5728  0.7094
    End  ! HindRot
    ZeroEnergy[kcal/mol]      13.21
    Tunneling  Eckart
      ImaginaryFrequency[1/cm]  491
      WellDepth[kcal/mol]       12.52
      WellDepth[kcal/mol]       13.29
  End
End  ! Barrier
Barrier FakeB-C2H4OALD-UPQWKw+C2H3ALK-S58hH1 C2H4OALD-UPQWKw+C2H3ALK-S58hH1 FakeW-C2H4OALD-UPQWKw+C2H3ALK-S58hH1
  RRHO
    Stoichiometry  C4H7O1
    Core PhaseSpaceTheory
      FragmentGeometry[angstrom]    7
        C          1.16576      -0.14899      -0.00000
        C         -0.23120       0.39839       0.00000
        H          1.70098       0.22059      -0.87605
        H          1.70089       0.22037       0.87620
        H          1.15186      -1.23472      -0.00014
        O         -1.23253      -0.27579      -0.00000
        H         -0.30086       1.50370      -0.00002
      FragmentGeometry[angstrom]    5
        C          0.04872       0.71828       0.00000
        C          0.04872      -0.58503       0.00000
        H         -0.67179       1.51789      -0.00000
        H         -0.87875      -1.15563      -0.00000
        H          0.96591      -1.16174       0.00000
      SymmetryFactor                  1.0
      PotentialPrefactor[au]          10.0
      PotentialPowerExponent          6.0
      TSTLevel EJ
    End  ! Core
    Frequencies[1/cm]         23
      504     766     879     1114    1118    1353
      1396    1434    1444    1742    2782    2916
      2974    3025    711     817     921     1043
      1371    1622    2943    3035    3118
    ElectronicLevels[1/cm]    1
      0.0  2
    Rotor  Hindered   # D5
      Geometry[angstrom]     7
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.49911
            H          0.00000       1.02963      -0.36370
            H          0.91942      -0.46358      -0.36360
            H         -0.86583      -0.53321      -0.38391
            O         -0.84028      -0.51779       2.18101
            H          0.85486       0.52673       1.97023
      Group                        3   4   5
      Axis                         1   2
      Symmetry                     3
      PotentialSpline[kcal/mol]    4   3
        0.00    30.00   60.00   90.00
        0.0000  0.5592  1.2391  0.4533
    End  ! HindRot
    ZeroEnergy[kcal/mol]      15.34
End  ! Barrier
Barrier ts_1_8 C4H7O4H74fm0 FakeW-C2H4OALD-UPQWKw+C2H3ALK-S58hH1
  RRHO
    Geometry[angstrom]        12
      C          2.08607       0.02667      -0.19969
      C          1.10095      -0.72780       0.20199
      H          1.93084       1.07450      -0.41725
      H          3.08400      -0.38254      -0.32378
      C         -0.76658       0.26289       0.40817
      H          0.96655      -1.75990       0.48040
      C         -1.66038      -0.74005      -0.28700
      O         -0.52566       1.36891      -0.07638
      H         -0.63106       0.10046       1.49430
      H         -1.52292      -1.74929       0.09619
      H         -2.69538      -0.44725      -0.09994
      H         -1.48708      -0.71756      -1.35971
    Core RigidRotor
      SymmetryFactor          0.5
    End  ! Core
    Frequencies[1/cm]         27
      193     243     341     426     497     792
      814     831     890     942     1020    1081
      1105    1344    1355    1366    1443    1447
      1582    1631    2768    2917    2980    2981
      3016    3075    3104
    ElectronicLevels[1/cm]    1
      0.0  2
    Rotor  Hindered   # D6
      Geometry[angstrom]     12
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.30038
            H          0.00000       0.92947      -0.55668
            H         -0.00030      -0.93245      -0.55785
            C          0.02898       1.94561       2.22673
            H         -0.00040      -0.74321       2.08234
            C         -1.04084       1.73770       3.27411
            O         -0.13579       2.68622       1.26484
            H          1.05672       1.67300       2.53727
            H         -0.86834       0.83928       3.86535
            H         -1.01611       2.59529       3.95046
            H         -2.02285       1.69799       2.80724
      Group                        1   3   4   6
      Axis                         2   5
      Symmetry                     1
      PotentialSpline[kcal/mol]    12   11
        0.00    30.00   60.00   90.00   120.00  150.00
        180.00  210.00  240.00  270.00  300.00  330.00
        0.0000  0.4713  1.2137  1.2376  1.1356  1.2116
        1.2620  0.9709  1.0080  1.6960  1.2601  0.3796
    End  ! HindRot
    Rotor  Hindered   # D9
      Geometry[angstrom]     12
            C          0.00000       0.00000       0.00000
            C          0.00000       0.00000       1.30038
            H          0.00000       0.92947      -0.55668
            H         -0.00030      -0.93245      -0.55785
            C          0.02898       1.94561       2.22673
            H         -0.00040      -0.74321       2.08234
            C         -1.04084       1.73770       3.27411
            O         -0.13579       2.68622       1.26484
            H          1.05672       1.67300       2.53727
            H         -0.86834       0.83928       3.86535
            H         -1.01611       2.59529       3.95046
            H         -2.02285       1.69799       2.80724
      Group                        1   2   3   4   6   8   9
      Axis                         5   7
      Symmetry                     3
      PotentialSpline[kcal/mol]    4   3
        0.00    30.00   60.00   90.00
        0.0000  1.1120  2.0695  0.8873
    End  ! HindRot
    ZeroEnergy[kcal/mol]      20.20
    Tunneling  Eckart
      ImaginaryFrequency[1/cm]  392
      WellDepth[kcal/mol]       19.50
      WellDepth[kcal/mol]       7.85
  End
End  ! Barrier
Barrier ts_1_9 C4H7O-kSV4fm FakeW-C2H4OALD-UPQWKw+C2H3ALK-S58hH1
  RRHO
    Geometry[angstrom]        12
      C          1.82147       0.82777       0.13516
      C          1.60394      -0.37936      -0.30264
      H          1.02738       1.38225       0.63204
      H          2.77811       1.32882       0.03527
      O         -0.18123      -1.05618       0.04050
      H          2.14310      -1.16305      -0.80014
      C         -1.00401      -0.24445       0.50589
      C         -1.92044       0.56738      -0.35315
      H         -1.03454      -0.06554       1.58866
      H         -2.95157       0.46544      -0.01035
      H         -1.84642       0.24350      -1.38780
      H         -1.67194       1.63008      -0.29321
    Core RigidRotor
      SymmetryFactor          1.0
    End  ! Core
    Frequencies[1/cm]         29
      49      70      114     190     370     406
      501     731     761     865     882     919
      1033    1043    1105    1322    1362    1364
      1427    1442    1499    1628    2871    2901
      2947    2952    3012    3022    3149
    ElectronicLevels[1/cm]    1
      0.0  2
    ZeroEnergy[kcal/mol]      28.82
    Tunneling  Eckart
      ImaginaryFrequency[1/cm]  616
      WellDepth[kcal/mol]       29.99
      WellDepth[kcal/mol]       16.48
  End
End  ! Barrier
End  ! Model
!
!===================================================
!  END MASTER EQUATION MODEL
!===================================================



--------------------------------------------------------------------------------------
Running MESS well-extended input with version v1 at /lcrc/project/PACC/AutoMech/data/run/MESS/RATE/C4H7O1_1_1/wextv1



--------------------------------------------------------------------------------------

Reading Rate Constants from MESS outputs
Fitting rates from
/lcrc/project/PACC/AutoMech/data/run/MESS/RATE/C5H11O2_5_1/basev1
/lcrc/project/PACC/AutoMech/data/run/MESS/RATE/C4H7O1_1_1/wextv1
*Warning: no hotspecies found,               returning empty dictionary 

hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (5850.0, 24400.0, 86000.0, 253000.0, 634000.0, 1390000.0, 2710000.0, 4850000.0, 8050000.0, 12600000.0, 18600000.0, 26400000.0, 36200000.0, 48000000.0, 61900000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (165000000000.0, 234000000000.0, 290000000000.0, 329000000000.0, 352000000000.0, 364000000000.0, 365000000000.0, 360000000000.0, 350000000000.0, 337000000000.0, 323000000000.0, 307000000000.0, 291000000000.0, 275000000000.0, 260000000000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (0.226, 3.34, 30.1, 182.0, 808.0, 2810.0, 8040.0, 19800.0, 43100.0, 85100.0, 155000.0, 263000.0, 422000.0, 645000.0, 946000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (214000000000.0, 304000000000.0, 376000000000.0, 427000000000.0, 458000000000.0, 472000000000.0, 475000000000.0, 468000000000.0, 455000000000.0, 438000000000.0, 419000000000.0, 399000000000.0, 378000000000.0, 357000000000.0, 337000000000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (1.78e-10, 1.83e-10, 1.87e-10, 1.9e-10, 1.94e-10, 1.97e-10, 2e-10, 2.03e-10, 2.05e-10, 2.07e-10, 2.1e-10, 2.12e-10, 2.14e-10, 2.16e-10, 2.18e-10))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (1.76e-10, 1.81e-10, 1.85e-10, 1.89e-10, 1.92e-10, 1.95e-10, 1.98e-10, 2.01e-10, 2.03e-10, 2.06e-10, 2.08e-10, 2.1e-10, 2.12e-10, 2.14e-10, 2.16e-10))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
Error: both directions empty for the rxn (('W1',), ('P2',), (None,))
Error: both directions empty for the rxn (('W2',), ('P1',), (None,))
Error: both directions empty for the rxn (('P1',), ('W2',), (None,))
Error: both directions empty for the rxn (('P2',), ('W1',), (None,))
*Warning: PEDSpecies and PEDOutput options incomplete, returning None 

hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (77.7, 1850.0, 20300.0, 131000.0, 587000.0, 2010000.0, 5650000.0, 13600000.0, 28900000.0, 56000000.0, 100000000.0, 168000000.0, 267000000.0, 404000000.0, 590000000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (1.72e-09, 2.43e-06, 0.000576, 0.0411, 1.27, 21.2, 223.0, 1650.0, 9230.0, 41300.0, 154000.0, 493000.0, 1400000.0, 3550000.0, 8270000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (2.19e-17, 5.05e-13, 9.42e-10, 3.29e-07, 3.56e-05, 0.00164, 0.0399, 0.595, 6.03, 44.9, 260.0, 1230.0, 4870.0, 16700.0, 50900.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (581000000.0, 1640000000.0, 3600000000.0, 6690000000.0, 11000000000.0, 16700000000.0, 23800000000.0, 32100000000.0, 41700000000.0, 52400000000.0, 64300000000.0, 77100000000.0, 90900000000.0, 105000000000.0, 121000000000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (0.0824, 11.4, 476.0, 8820.0, 92200.0, 634000.0, 3170000.0, 12500000.0, 40300000.0, 112000000.0, 274000000.0, 603000000.0, 1220000000.0, 2290000000.0, 4040000000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (5800.0, 137000.0, 1510000.0, 10000000.0, 46000000.0, 162000000.0, 468000000.0, 1160000000.0, 2520000000.0, 4970000000.0, 9050000000.0, 15400000000.0, 24800000000.0, 38000000000.0, 56000000000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (5020.0, 103000.0, 1010000.0, 6010000.0, 25300000.0, 82200000.0, 221000000.0, 510000000.0, 1050000000.0, 1960000000.0, 3410000000.0, 5550000000.0, 8570000000.0, 12700000000.0, 18000000000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (1010000000.0, 3390000000.0, 8440000000.0, 17200000000.0, 30500000000.0, 48600000000.0, 71800000000.0, 99900000000.0, 133000000000.0, 170000000000.0, 211000000000.0, 255000000000.0, 303000000000.0, 353000000000.0, 406000000000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (0.00137, 0.0521, 0.806, 6.84, 38.1, 156.0, 508.0, 1380.0, 3280.0, 6940.0, 13400.0, 24100.0, 40500.0, 64700.0, 98600.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (1760.0, 9170.0, 31500.0, 82400.0, 177000.0, 332000.0, 558000.0, 865000.0, 1260000.0, 1740000.0, 2300000.0, 2950000.0, 3670000.0, 4450000.0, 5300000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (68900000000.0, 97900000000.0, 121000000000.0, 138000000000.0, 147000000000.0, 152000000000.0, 153000000000.0, 151000000000.0, 147000000000.0, 141000000000.0, 135000000000.0, 128000000000.0, 122000000000.0, 115000000000.0, 109000000000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (0.664, 10.5, 80.8, 388.0, 1340.0, 3670.0, 8410.0, 16800.0, 30400.0, 50400.0, 78300.0, 115000.0, 162000.0, 218000.0, 286000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (17400000000.0, 24800000000.0, 30700000000.0, 34800000000.0, 37400000000.0, 38600000000.0, 38700000000.0, 38200000000.0, 37100000000.0, 35800000000.0, 34200000000.0, 32500000000.0, 30900000000.0, 29200000000.0, 27500000000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (8.32e-10, 8.53e-10, 8.73e-10, 8.9e-10, 9.06e-10, 9.2e-10, 9.34e-10, 9.46e-10, 9.58e-10, 9.69e-10, 9.79e-10, 9.89e-10, 9.99e-10, 1.01e-09, 1.02e-09))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (2.41e-10, 2.47e-10, 2.53e-10, 2.58e-10, 2.62e-10, 2.66e-10, 2.7e-10, 2.74e-10, 2.77e-10, 2.81e-10, 2.84e-10, 2.87e-10, 2.89e-10, 2.92e-10, 2.94e-10))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (2.03e-10, 2.08e-10, 2.13e-10, 2.17e-10, 2.21e-10, 2.24e-10, 2.27e-10, 2.3e-10, 2.33e-10, 2.36e-10, 2.39e-10, 2.41e-10, 2.43e-10, 2.45e-10, 2.48e-10))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/ped.py:271: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df[pressure][temp] = prob_en_single(probability, energy)
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:180: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  hoten_dct[hotspecies][_press][_temp] = bf_hotspecies
Warning: found negative fne BFs at 300 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 300 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 350 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 400 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 450 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 450 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 450 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 450 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 450 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 450 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 450 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 450 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 450 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 450 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 450 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 450 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 450 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 450 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 450 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 450 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 450 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 450 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 450 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 450 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 450 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 450 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 450 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 500 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 500 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 500 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 500 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 500 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 500 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 500 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 500 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 500 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 500 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 500 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 500 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 500 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 500 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 500 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 500 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 500 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 500 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 500 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 500 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 500 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 500 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 500 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 550 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 550 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 550 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 550 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 550 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 550 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 550 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 550 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 550 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 550 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 550 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 550 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 550 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 550 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 550 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 550 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 550 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 550 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 550 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 550 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 550 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 550 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 550 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 600 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 600 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 600 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 600 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 600 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 600 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 600 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 600 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 600 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 600 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 600 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 600 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 600 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 600 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 600 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 600 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 600 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 600 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 600 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 600 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 600 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 600 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 600 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 600 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 650 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 650 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 650 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 650 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 650 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 650 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 650 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 650 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 650 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 650 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 650 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 650 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 650 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 650 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 650 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 650 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 650 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 650 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 650 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 650 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 650 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 650 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 650 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 650 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 650 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 700 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 700 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 700 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 700 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 700 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 700 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 700 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 700 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 700 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 700 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 700 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 700 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 700 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 700 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 700 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 700 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 700 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 700 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 700 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 700 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 700 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 700 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 700 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 700 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 700 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 700 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 750 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 800 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 800 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 800 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 800 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 800 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 800 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 800 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 800 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 800 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 800 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 800 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 800 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 800 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 800 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 800 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 800 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 800 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 800 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 800 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 800 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 800 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 800 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 800 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 800 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 800 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 800 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 850 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 850 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 850 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 850 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 850 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 850 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 850 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 850 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 850 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 850 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 850 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 850 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 850 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 850 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 850 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 850 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 850 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 850 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 850 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 850 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 850 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 850 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 850 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 850 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 850 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 850 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 900 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 950 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 3.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 1.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 3.0e-01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 1.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 3.0e+00 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 1.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 3.0e+01 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
Warning: found negative fne BFs at 1000 K and 1.0e+02 atm
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/autoio/mess_io/reader/hoten.py:283: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  dct_bf_tp_df[well][_press][_temp] = pd.Series(
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (5850.0, 24400.0, 86000.0, 253000.0, 634000.0, 1390000.0, 2710000.0, 4850000.0, 8050000.0, 12600000.0, 18600000.0, 26400000.0, 36200000.0, 48000000.0, 61900000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (165000000000.0, 234000000000.0, 290000000000.0, 329000000000.0, 352000000000.0, 364000000000.0, 365000000000.0, 360000000000.0, 350000000000.0, 337000000000.0, 323000000000.0, 307000000000.0, 291000000000.0, 275000000000.0, 260000000000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (0.226, 3.34, 30.1, 182.0, 808.0, 2810.0, 8040.0, 19800.0, 43100.0, 85100.0, 155000.0, 263000.0, 422000.0, 645000.0, 946000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (214000000000.0, 304000000000.0, 376000000000.0, 427000000000.0, 458000000000.0, 472000000000.0, 475000000000.0, 468000000000.0, 455000000000.0, 438000000000.0, 419000000000.0, 399000000000.0, 378000000000.0, 357000000000.0, 337000000000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (1.78e-10, 1.83e-10, 1.87e-10, 1.9e-10, 1.94e-10, 1.97e-10, 2e-10, 2.03e-10, 2.05e-10, 2.07e-10, 2.1e-10, 2.12e-10, 2.14e-10, 2.16e-10, 2.18e-10))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (1.76e-10, 1.81e-10, 1.85e-10, 1.89e-10, 1.92e-10, 1.95e-10, 1.98e-10, 2.01e-10, 2.03e-10, 2.06e-10, 2.08e-10, 2.1e-10, 2.12e-10, 2.14e-10, 2.16e-10))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (None, None, None, None, None, None, None, None, None, None, None, None, None, None, None))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
hihp ((300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0), (300.0, 350.0, 400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, 850.0, 900.0, 950.0, 1000.0))
Processing reaction (('C4H8ORvEsWvAA0', 'CH3O-S58cwB'), ('C4H7ORvE4fmAA0', 'CH4O-S58WKw'), (None,)) with DH of -5.58 kcal/mol
deriving fragment energy distributions for C4H8ORvEsWvAA0+CH3O-S58cwB to C4H7ORvE4fmAA0+CH4O-S58WKw
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/ene_partition.py:525: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  ped_df_prod[pressure][temp] = pd.Series(
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
Warning: found negative BFs at 300 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
Warning: found negative BFs at 350 K and 1.0e-02 atm
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:167: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_tp_df[pressure][temp] = bf_series/np.sum(bf_series.values)
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:217: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_df_sp_i[pressure][temp] = bfrac
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:217: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_df_sp_i[pressure][temp] = bfrac
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:217: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_df_sp_i[pressure][temp] = bfrac
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:217: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_df_sp_i[pressure][temp] = bfrac
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/bf.py:217: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

  bf_df_sp_i[pressure][temp] = bfrac

Fitting Rate Constants for PES to Functional Forms

Fitting Reaction: C4H8ORvEsWvAA0 + CH3O-S58cwB = C4H7ORvE4fmAA0 + CH4O-S58WKw
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Attempting double fit...
Double fit obtained with max error of 32.1% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 27.9% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 40.2% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 33.2% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 25.4% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 21.5% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 21.0% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 31.5% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 25.5% after 1 iteration(s).
Double fit error is worse than single; using single fit.
--------------------------------


Fitting Reaction: C4H8ORvEsWvAA0 + CH3O-S58cwB = C4H7O4H74fm0 + CH4O-S58WKw
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Attempting double fit...
Double fit obtained with max error of 35.8% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 28.3% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 37.4% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 32.7% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 29.2% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 33.2% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 44.1% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 33.9% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 50.8% after 1 iteration(s).
Double fit error is worse than single; using single fit.
--------------------------------


Fitting Reaction: C4H8ORvEsWvAA0 + CH3O-S58cwB = C4H7O-kSV4fm + CH4O-S58WKw
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Attempting double fit...
Double fit obtained with max error of 33.7% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Single fit error is 13.5%, which is less than the input limit of 15.0%. Using single fit.
Attempting double fit...
Double fit obtained with max error of 28.2% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 20.5% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 19.7% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 36.6% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 42.4% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 36.6% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 30.9% after 1 iteration(s).
Double fit error is worse than single; using single fit.
--------------------------------


Fitting Reaction: C4H8ORvEsWvAA0 + CH3O-S58cwB = C3H4OALAD-Wv9FbZ + CH3 + CH4O-S58WKw
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Single fit error is 2.4%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 4.6%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 2.8%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 3.1%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 7.7%, which is less than the input limit of 15.0%. Using single fit.
Attempting double fit...
Double fit obtained with max error of 68.8% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Single fit error is 12.0%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 2.2%, which is less than the input limit of 15.0%. Using single fit.
Attempting double fit...
Double fit obtained with max error of 21.7% after 1 iteration(s).
Double fit error is worse than single; using single fit.
--------------------------------


Fitting Reaction: FakeW-C4H8ORvEsWvAA0 + CH3O-S58cwB = CH4O-S58WKw + FakeW-C4H7ORvE4fmAA0
No pressure dependence, but no k(T)s at 1.0 atm.
No numerical pressures. Grabbing "high" kts.

Fitting k(T,P)s to Arrhenius form...
Single fit error is 11.5%, which is less than the input limit of 15.0%. Using single fit.
--------------------------------


Fitting Reaction: FakeW-C4H8ORvEsWvAA0 + CH3O-S58cwB = C4H7ORvE4fmAA0 + CH4O-S58WKw
No rate constants to fit.
--------------------------------


Fitting Reaction: FakeW-C4H7ORvE4fmAA0 + CH4O-S58WKw = C4H8ORvEsWvAA0 + CH3O-S58cwB
No rate constants to fit.
--------------------------------


Fitting Reaction: C4H8ORvEsWvAA0 + CH3O-S58cwB = CH3O-S58cwB + FakeW-C4H8ORvEsWvAA0
No pressure dependence, but no k(T)s at 1.0 atm.
No numerical pressures. Grabbing "high" kts.

Fitting k(T,P)s to Arrhenius form...
Single fit error is 0.3%, which is less than the input limit of 15.0%. Using single fit.
--------------------------------


Fitting Reaction: C4H7ORvE4fmAA0 + CH4O-S58WKw = CH4O-S58WKw + FakeW-C4H7ORvE4fmAA0
No pressure dependence, but no k(T)s at 1.0 atm.
No numerical pressures. Grabbing "high" kts.

Fitting k(T,P)s to Arrhenius form...
Single fit error is 0.2%, which is less than the input limit of 15.0%. Using single fit.
--------------------------------


Fitting Reaction: C4H7O-kSV4fm = C2H3ALK-S58hH1 + FakeW-C2H4OALD-UPQWKw
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Attempting double fit...
Double fit obtained with max error of 35.1% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 34.1% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 110.2% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 17.5% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 16.8% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 32.7% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Single fit error is 14.2%, which is less than the input limit of 15.0%. Using single fit.
--------------------------------


Fitting Reaction: C4H7O-kSV4fm = CH3 + FakeW-C3H4OALAD-Wv9FbZ
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Attempting double fit...
/lcrc/project/PACC/copan/amech-dev/.pixi/envs/default/lib/python3.10/site-packages/scipy/optimize/_lsq/common.py:115: RuntimeWarning: divide by zero encountered in divide
  phi_prime = -np.sum(suf ** 2 / denom**3) / p_norm
Double fit obtained with max error of 29.5% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 55.6% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 57.7% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 70.6% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 35.4% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 15.5% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 93.8% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 25.1% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 28.5% after 1 iteration(s).
Double fit error is worse than single; using single fit.
--------------------------------


Fitting Reaction: C4H7O-kSV4fm = C3H4OALAD-Wv9FbZ + CH3
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Attempting double fit...
Double fit obtained with max error of 38.2% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 28.0% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 46.6% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Single fit error is 11.4%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 10.2%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 13.9%, which is less than the input limit of 15.0%. Using single fit.
Attempting double fit...
Double fit obtained with max error of 106.1% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 45.0% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 65.2% after 1 iteration(s).
Double fit error is worse than single; using single fit.
--------------------------------


Fitting Reaction: C4H7O-kSV4fm = C2H3ALK-S58hH1 + C2H4OALD-UPQWKw
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Attempting double fit...
Double fit obtained with max error of 41.8% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 33.1% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 22.2% after 1 iteration(s).
Single fit error is 12.0%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 11.7%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 12.3%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 11.3%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 10.9%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 13.0%, which is less than the input limit of 15.0%. Using single fit.
--------------------------------


Fitting Reaction: C4H7O4H74fm0 = C4H7O-kSV4fm
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Attempting double fit...
Double fit obtained with max error of 53.9% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 42.5% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 32.0% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 24.6% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 58.9% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Single fit error is 11.9%, which is less than the input limit of 15.0%. Using single fit.
Attempting double fit...
Double fit obtained with max error of 87.8% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 57.7% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 59.4% after 1 iteration(s).
Double fit error is worse than single; using single fit.
--------------------------------


Fitting Reaction: C4H7O4H74fm0 = C2H3ALK-S58hH1 + FakeW-C2H4OALD-UPQWKw
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Attempting double fit...
Double fit obtained with max error of 64.6% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 30.9% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 22.3% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Single fit error is 14.1%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 11.0%, which is less than the input limit of 15.0%. Using single fit.
--------------------------------


Fitting Reaction: C4H7O4H74fm0 = CH3 + FakeW-C3H4OALAD-Wv9FbZ
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Attempting double fit...
Double fit obtained with max error of 698.3% after 1 iteration(s).
There are less than six rate constants to fit. Using single fit.
There are less than six rate constants to fit. Using single fit.
Attempting double fit...
Double fit obtained with max error of 106.2% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 48.6% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 41.0% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 185.4% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Single fit error is 7.5%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 11.6%, which is less than the input limit of 15.0%. Using single fit.
--------------------------------


Fitting Reaction: C4H7O4H74fm0 = C3H4OALAD-Wv9FbZ + CH3
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Attempting double fit...
Double fit obtained with max error of 33.2% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 29.5% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 24.5% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 45.8% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Single fit error is 12.2%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 11.0%, which is less than the input limit of 15.0%. Using single fit.
Attempting double fit...
Double fit obtained with max error of 91.8% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 108.9% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 123.7% after 1 iteration(s).
Double fit error is worse than single; using single fit.
--------------------------------


Fitting Reaction: C4H7O4H74fm0 = C2H3ALK-S58hH1 + C2H4OALD-UPQWKw
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Attempting double fit...
Double fit obtained with max error of 23.2% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 19.8% after 1 iteration(s).
Single fit error is 14.0%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 12.6%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 5.8%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 7.0%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 13.3%, which is less than the input limit of 15.0%. Using single fit.
Attempting double fit...
Double fit obtained with max error of 102.3% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 121.8% after 1 iteration(s).
Double fit error is worse than single; using single fit.
--------------------------------


Fitting Reaction: C4H7ORvE4fmAA0 = C4H7O-kSV4fm
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Attempting double fit...
Double fit obtained with max error of 19.0% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 94.8% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 78.7% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 60.3% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 38.6% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 21.6% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Single fit error is 11.4%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 12.2%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 13.8%, which is less than the input limit of 15.0%. Using single fit.
--------------------------------


Fitting Reaction: C4H7ORvE4fmAA0 = C4H7O4H74fm0
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Attempting double fit...
Double fit obtained with max error of 15.0% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 15.1% after 1 iteration(s).
Single fit error is 13.3%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 11.1%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 8.7%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 9.3%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 12.1%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 12.9%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 10.2%, which is less than the input limit of 15.0%. Using single fit.
--------------------------------


Fitting Reaction: C4H7ORvE4fmAA0 = C2H3ALK-S58hH1 + FakeW-C2H4OALD-UPQWKw
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Attempting double fit...
Double fit obtained with max error of 99.2% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 37.6% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 18.6% after 1 iteration(s).
Single fit error is 10.5%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 7.0%, which is less than the input limit of 15.0%. Using single fit.
--------------------------------


Fitting Reaction: C4H7ORvE4fmAA0 = CH3 + FakeW-C3H4OALAD-Wv9FbZ
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
There are less than six rate constants to fit. Using single fit.
Attempting double fit...
Double fit obtained with max error of 567.3% after 1 iteration(s).
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/rates.py:191: RuntimeWarning: overflow encountered in power
  kts += a_par * ((temps/tref)**n_par) * numpy.exp(-ea_par/(rval*temps))
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/mechanalyzer/calculator/rates.py:191: RuntimeWarning: invalid value encountered in multiply
  kts += a_par * ((temps/tref)**n_par) * numpy.exp(-ea_par/(rval*temps))
There are less than six rate constants to fit. Using single fit.
Attempting double fit...
Double fit obtained with max error of 305.7% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 134.5% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 67.0% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 290.8% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Single fit error is 8.1%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 7.5%, which is less than the input limit of 15.0%. Using single fit.
--------------------------------


Fitting Reaction: C4H7ORvE4fmAA0 = C3H4OALAD-Wv9FbZ + CH3
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Attempting double fit...
Double fit obtained with max error of 73.0% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 68.4% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 62.3% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 52.0% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 35.3% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 31.0% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Single fit error is 9.2%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 11.9%, which is less than the input limit of 15.0%. Using single fit.
Attempting double fit...
Double fit obtained with max error of 112.5% after 1 iteration(s).
Double fit error is worse than single; using single fit.
--------------------------------


Fitting Reaction: C4H7ORvE4fmAA0 = C2H3ALK-S58hH1 + C2H4OALD-UPQWKw
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Attempting double fit...
Double fit obtained with max error of 43.2% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 37.0% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 24.7% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 23.8% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 31.3% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 23.6% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Single fit error is 9.2%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 10.5%, which is less than the input limit of 15.0%. Using single fit.
Attempting double fit...
Double fit obtained with max error of 111.3% after 1 iteration(s).
Double fit error is worse than single; using single fit.
--------------------------------


Fitting Reaction: FakeW-C2H4OALD-UPQWKw + C2H3ALK-S58hH1 = CH3 + FakeW-C3H4OALAD-Wv9FbZ
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Single fit error is 10.5%, which is less than the input limit of 15.0%. Using single fit.
Attempting double fit...
Double fit obtained with max error of 325.1% after 1 iteration(s).
Double fit error is worse than single; using single fit.
--------------------------------


Fitting Reaction: FakeW-C2H4OALD-UPQWKw + C2H3ALK-S58hH1 = C3H4OALAD-Wv9FbZ + CH3
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Attempting double fit...
Double fit obtained with max error of 12.3% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 204.3% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 18.2% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Single fit error is 13.6%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 12.8%, which is less than the input limit of 15.0%. Using single fit.
--------------------------------


Fitting Reaction: FakeW-C3H4OALAD-Wv9FbZ + CH3 = C2H3ALK-S58hH1 + C2H4OALD-UPQWKw
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Attempting double fit...
/lcrc/project/PACC/copan/amech-dev/src/mechanalyzer/ratefit/fit/arr.py:280: RuntimeWarning: overflow encountered in exp
  k_fit1 = curr_guess[0] * numpy.exp(
Double fit obtained with max error of 2530.9% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 122.9% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 8.6% after 1 iteration(s).
Single fit error is 12.5%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 9.0%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 8.8%, which is less than the input limit of 15.0%. Using single fit.
--------------------------------


Fitting Reaction: C4H6O-RvErx50 + H-TcYTcY = C4H7O-kSV4fm
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Attempting double fit...
Double fit obtained with max error of 2.8% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 225.7% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 24.1% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 16.7% after 1 iteration(s).
Single fit error is 6.1%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 12.2%, which is less than the input limit of 15.0%. Using single fit.
Attempting double fit...
Double fit obtained with max error of 111.6% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 111.4% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Single fit error is 10.4%, which is less than the input limit of 15.0%. Using single fit.
--------------------------------


Fitting Reaction: C4H6O-RvErx50 + H-TcYTcY = C4H7O4H74fm0
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Attempting double fit...
Double fit obtained with max error of 148.1% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 80.8% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 60.3% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 145.9% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 161.6% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 164.6% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 149.9% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 53.0% after 1 iteration(s).
Double fit error is worse than single; using single fit.
--------------------------------


Fitting Reaction: C4H6O-RvErx50 + H-TcYTcY = C4H7ORvE4fmAA0
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Attempting double fit...
Double fit obtained with max error of 42.1% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 23.7% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 25.0% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 25.8% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 39.0% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 33.8% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 28.8% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 21.4% after 1 iteration(s).
Double fit error is worse than single; using single fit.
--------------------------------


Fitting Reaction: C4H6O-RvErx50 + H-TcYTcY = C2H3ALK-S58hH1 + FakeW-C2H4OALD-UPQWKw
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Attempting double fit...
Double fit obtained with max error of 19.8% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 99.4% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 19.6% after 1 iteration(s).
Attempting double fit...
Double fit obtained with max error of 60.2% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 30.6% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Single fit error is 9.0%, which is less than the input limit of 15.0%. Using single fit.
--------------------------------


Fitting Reaction: C4H6O-RvErx50 + H-TcYTcY = CH3 + FakeW-C3H4OALAD-Wv9FbZ
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Attempting double fit...
Double fit obtained with max error of 216.7% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 128.1% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 19.9% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Attempting double fit...
Double fit obtained with max error of 21.8% after 1 iteration(s).
Double fit error is worse than single; using single fit.
Single fit error is 4.2%, which is less than the input limit of 15.0%. Using single fit.
--------------------------------


Fitting Reaction: C4H6O-RvErx50 + H-TcYTcY = C3H4OALAD-Wv9FbZ + CH3
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Single fit error is 3.2%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 3.2%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 3.1%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 3.2%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 2.8%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 3.8%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 8.6%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 10.9%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 7.7%, which is less than the input limit of 15.0%. Using single fit.
--------------------------------


Fitting Reaction: C4H6O-RvErx50 + H-TcYTcY = C2H3ALK-S58hH1 + C2H4OALD-UPQWKw
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Single fit error is 0.9%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 1.0%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 1.0%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 0.9%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 0.8%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 1.6%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 5.6%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 7.9%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 5.7%, which is less than the input limit of 15.0%. Using single fit.
--------------------------------


Fitting Reaction: C3H4OALAD-Wv9FbZ + CH3 = CH3 + FakeW-C3H4OALAD-Wv9FbZ
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Single fit error is 10.1%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 9.0%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 7.8%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 6.8%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 5.6%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 4.8%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 3.7%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 2.2%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 1.3%, which is less than the input limit of 15.0%. Using single fit.
--------------------------------


Fitting Reaction: C2H4OALD-UPQWKw + C2H3ALK-S58hH1 = C2H3ALK-S58hH1 + FakeW-C2H4OALD-UPQWKw
Reaction found to be pressure dependent. Fitting all k(T)s from all pressures.

Pressure dependence found. Fitting to PLOG form...
Single fit error is 9.1%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 8.2%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 7.4%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 6.8%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 6.0%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 5.3%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 4.6%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 4.0%, which is less than the input limit of 15.0%. Using single fit.
Single fit error is 3.1%, which is less than the input limit of 15.0%. Using single fit.
--------------------------------


Fitting Reaction: C2H4OALD-UPQWKw + C2H3ALK-S58hH1 = C3H4OALAD-Wv9FbZ + CH3
No pressure dependence. Grabbing k(T)s at 1.0 atm.

Fitting k(T,P)s to Arrhenius form...
Single fit error is 0.7%, which is less than the input limit of 15.0%. Using single fit.
--------------------------------


=========================================================
EXITING kTPDRIVER
=========================================================





          ================================================================
          ==                    EXITING AUTOMECHANIC                    ==
          ================================================================

